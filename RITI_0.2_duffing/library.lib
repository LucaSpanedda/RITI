import("stdfaust.lib");

//--------------------------------------------------- NETWORK OPERATIONS ---
// Vectorial operations
vecOp(vectorsList, op) =
vectorsList : seq(i, vecDim - 1, vecOp2D , vecBus(vecDim - 2 - i))
with {
    vecBus(0) = par(i, vecLen, 0 : !);
    vecBus(dim) = par(i, dim, si.bus(vecLen));
    vecOp2D = ro.interleave(vecLen, 2) : par(i, vecLen, op);
    vecDim = outputs(vectorsList) / vecLen;
    vecLen = outputs(ba.take(1, vectorsList));
};
// Network inputs
netInsx(N) = vecOp((si.bus(N), si.bus(N)), +);
// Network Matrix - fully connected (normalized)
vecMx(N) = si.bus(N) <: 
    par(i, N, (vecOp((si.bus(N), par(i, N, 1/N)), *) :> +));

//----------------------------------------------------- BASIC OPERATIONS ---
// Saturation function
saturator(l, x) = l * ma.tanh(x / (max(l, ma.EPSILON)));
// DC blocker filter
dcblocker(zero, pole, x) = x : dcblockerout
        with{
            onezero =  _ <: _, mem : _,* (zero) : -;
            onepole = + ~ * (pole);
            dcblockerout = _ : onezero : onepole;
        };

//-------------------------------------------------------------- FILTERS ---
// TPT version of the One-Pole Filter by Vadim Zavalishin
onePoleTPT(cf, x) = loop ~ _ : ! , si.bus(3)
    with {
        g = tan(cf * ma.PI * ma.T);
        G = g / (1.0 + g);
        loop(s) = u , lp , hp , ap
            with {
            v = (x - s) * G; u = v + lp; lp = v + s; hp = x - lp; ap = lp - hp;
            };
    };

// Lowpass  TPT
LPTPT(cf, x) = onePoleTPT(cf, x) : (_ , ! , !);

// Highpass TPT
HPTPT(cf, x) = onePoleTPT(cf, x) : (! , _ , !);

// LP + HP
LPHPTPT(cfHP, cfLP) =   _ : (onePoleTPT(cfHP) : (! , _ , !)): 
                            (onePoleTPT(cfLP) : (_ , ! , !));

// SVF BP TPT version of the One-Pole Filter by Vadim Zavalishin
BPTPT(bw, cf, x) = loop ~ si.bus(2) : (! , ! , _)
with {
    g = tan(cf * ma.PI * (1.0/ma.SR));
    Q = cf / max(ma.EPSILON, bw);
    R = 1.0 / (Q + Q);
    G = 1.0 / (1.0 + 2.0 * R * g + g * g);
    loop(s1, s2) = u1 , u2 , bp
        with {
            bp = (g * (x - s2) + s1) * G;
            bp2 = bp + bp;
            v2 = bp2 * g;
            u1 = bp2 - s1;
            u2 = v2 + s2;
        };
};

//-------------------------------------------------- AMPLITUDE FOLLOWERS ---
// holdTime in Seconds
peakHolder(holdTime, x) = loop ~ si.bus(2) : ! , _
with {
    loop(timerState, outState) = timer , output
    with {
        isNewPeak = abs(x) >= outState;
        isTimeOut = timerState >= (holdTime * ma.SR - 1);
        bypass = isNewPeak | isTimeOut;
        timer = ba.if(bypass, 0, timerState + 1);
        output = ba.if(bypass, abs(x), outState);
    };
};

// Peak Envelope Follower with t60 Decay
peakenvelope(t60, x) = abs(x) <: loop ~ _ * rt60(t60)
with{
    loop(y,z) = y, z : max;
    rt60(t) = 0.001 ^ ((1/ma.SR) / t);
};

// lookahead limiter with: peakHolder, lowpass & peakenvelope
// All the credits of the original version goes to Dario Sanfilippo 
LookaheadLimiter(threshold, holdSec, decaySec, x) = 
    (x : peakHolder(holdSec) : LPTPT(1/holdSec) : peakenvelope(decaySec)) : 
        (min(1, threshold) / max(1, _)) * 
            (x @ (holdSec * ma.SR)); 

//------------------------------------------------- BANDPASS FILTER BANK ---
BPBANK(N, Freqslist, Amplslist, Fshift, Ashift, BW, Bypass, x) =  
            ( x * Bypass <: 
                vecOp( ((Freqslist : par(k, N, _ * Fshift)), si.bus(N)), BPTPT(BW) ) : 
                vecOp( ((Amplslist : par(k, N, _ * Ashift)), si.bus(N)), *) :> _ / N 
            ) + (x * (1 - Bypass));

//------------------------------------------------ ALLPASS FILTER LATTICE ---
// parallel, sequency, min. of distribution, max. of distribution, par offset, allpasses gain
apfLattice(columns, rows, minN, maxN, verticalOffset, g) = APFgrid 
with{
    // (t, g) = give: delay in samples, feedback gain 0-1
    apf(del, g, x) = x : (+ : _ <: @(del  - 1), *(g))~ *(-g) : mem, _ : + : _;
    rangeN = maxN - minN;
    step = rangeN / rows;
    primesNum(i) = ba.take(i, PrimesNL);
    ms2samp(t) = (t / 1000) * ma.SR;
    APFgrid = 
        par(j, columns, 
                seq(i, rows, 
                    apf(primesNum(int(i * step + minN + j * verticalOffset)) : ms2samp, g) 
                )
        );
};