#define PRESETDIR "auto"
/* ------------------------------------------------------------
author: "Luca Spanedda"
copyright: "Copyright (C) 2023 Luca Spanedda <lucaspanedda1995@gmail dot com>"
license: "MIT license"
name: "Room Is The Instrument"
version: "1.4"
Code generated with Faust 2.68.1 (https://faust.grame.fr)
Compilation options: -a /usr/local/share/faust/ca-gtk.cpp -lang cpp -i -ct 1 -es 1 -mcd 16 -double -ftz 0
------------------------------------------------------------ */

#ifndef  __mydsp_H__
#define  __mydsp_H__

/************************************************************************
 IMPORTANT NOTE : this file contains two clearly delimited sections :
 the ARCHITECTURE section (in two parts) and the USER section. Each section
 is governed by its own copyright and license. Please check individually
 each section for license and copyright information.
 *************************************************************************/

/******************* BEGIN ca-gtk.cpp ****************/

/************************************************************************
 FAUST Architecture File
 Copyright (C) 2021 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 
 ************************************************************************
 ************************************************************************/

#include <libgen.h>
#include <stdlib.h>
#include <iostream>
#include <string>
#include <list>

/************************** BEGIN proxy-dsp.h ***************************
FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
***************************************************************************/

#ifndef __proxy_dsp__
#define __proxy_dsp__

#include <vector>
#include <map>

/************************** BEGIN dsp.h ********************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __dsp__
#define __dsp__

#include <string>
#include <vector>
#include <cstdint>

/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ***************************************************************************/

#ifndef __export__
#define __export__

// Version as a global string
#define FAUSTVERSION "2.68.1"

// Version as separated [major,minor,patch] values
#define FAUSTMAJORVERSION 2
#define FAUSTMINORVERSION 68
#define FAUSTPATCHVERSION 1

// Use FAUST_API for code that is part of the external API but is also compiled in faust and libfaust
// Use LIBFAUST_API for code that is compiled in faust and libfaust

#ifdef _WIN32
    #pragma warning (disable: 4251)
    #ifdef FAUST_EXE
        #define FAUST_API
        #define LIBFAUST_API
    #elif FAUST_LIB
        #define FAUST_API __declspec(dllexport)
        #define LIBFAUST_API __declspec(dllexport)
    #else
        #define FAUST_API
        #define LIBFAUST_API 
    #endif
#else
    #ifdef FAUST_EXE
        #define FAUST_API
        #define LIBFAUST_API
    #else
        #define FAUST_API __attribute__((visibility("default")))
        #define LIBFAUST_API __attribute__((visibility("default")))
    #endif
#endif

#endif

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

struct FAUST_API UI;
struct FAUST_API Meta;

/**
 * DSP memory manager.
 */

struct FAUST_API dsp_memory_manager {
    
    virtual ~dsp_memory_manager() {}
    
    /**
     * Inform the Memory Manager with the number of expected memory zones.
     * @param count - the number of expected memory zones
     */
    virtual void begin(size_t /*count*/) {}
    
    /**
     * Give the Memory Manager information on a given memory zone.
     * @param size - the size in bytes of the memory zone
     * @param reads - the number of Read access to the zone used to compute one frame
     * @param writes - the number of Write access to the zone used to compute one frame
     */
    virtual void info(size_t /*size*/, size_t /*reads*/, size_t /*writes*/) {}

    /**
     * Inform the Memory Manager that all memory zones have been described,
     * to possibly start a 'compute the best allocation strategy' step.
     */
    virtual void end() {}
    
    /**
     * Allocate a memory zone.
     * @param size - the memory zone size in bytes
     */
    virtual void* allocate(size_t size) = 0;
    
    /**
     * Destroy a memory zone.
     * @param ptr - the memory zone pointer to be deallocated
     */
    virtual void destroy(void* ptr) = 0;
    
};

/**
* Signal processor definition.
*/

class FAUST_API dsp {

    public:

        dsp() {}
        virtual ~dsp() {}

        /* Return instance number of audio inputs */
        virtual int getNumInputs() = 0;
    
        /* Return instance number of audio outputs */
        virtual int getNumOutputs() = 0;
    
        /**
         * Trigger the ui_interface parameter with instance specific calls
         * to 'openTabBox', 'addButton', 'addVerticalSlider'... in order to build the UI.
         *
         * @param ui_interface - the user interface builder
         */
        virtual void buildUserInterface(UI* ui_interface) = 0;
    
        /* Return the sample rate currently used by the instance */
        virtual int getSampleRate() = 0;
    
        /**
         * Global init, calls the following methods:
         * - static class 'classInit': static tables initialization
         * - 'instanceInit': constants and instance state initialization
         *
         * @param sample_rate - the sampling rate in Hz
         */
        virtual void init(int sample_rate) = 0;

        /**
         * Init instance state
         *
         * @param sample_rate - the sampling rate in Hz
         */
        virtual void instanceInit(int sample_rate) = 0;
    
        /**
         * Init instance constant state
         *
         * @param sample_rate - the sampling rate in Hz
         */
        virtual void instanceConstants(int sample_rate) = 0;
    
        /* Init default control parameters values */
        virtual void instanceResetUserInterface() = 0;
    
        /* Init instance state (like delay lines...) but keep the control parameter values */
        virtual void instanceClear() = 0;
 
        /**
         * Return a clone of the instance.
         *
         * @return a copy of the instance on success, otherwise a null pointer.
         */
        virtual dsp* clone() = 0;
    
        /**
         * Trigger the Meta* parameter with instance specific calls to 'declare' (key, value) metadata.
         *
         * @param m - the Meta* meta user
         */
        virtual void metadata(Meta* m) = 0;
    
        /**
         * DSP instance computation, to be called with successive in/out audio buffers.
         *
         * @param count - the number of frames to compute
         * @param inputs - the input audio buffers as an array of non-interleaved FAUSTFLOAT samples (eiher float, double or quad)
         * @param outputs - the output audio buffers as an array of non-interleaved FAUSTFLOAT samples (eiher float, double or quad)
         *
         */
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) = 0;
    
        /**
         * DSP instance computation: alternative method to be used by subclasses.
         *
         * @param date_usec - the timestamp in microsec given by audio driver.
         * @param count - the number of frames to compute
         * @param inputs - the input audio buffers as an array of non-interleaved FAUSTFLOAT samples (either float, double or quad)
         * @param outputs - the output audio buffers as an array of non-interleaved FAUSTFLOAT samples (either float, double or quad)
         *
         */
        virtual void compute(double /*date_usec*/, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }
       
};

/**
 * Generic DSP decorator.
 */

class FAUST_API decorator_dsp : public dsp {

    protected:

        dsp* fDSP;

    public:

        decorator_dsp(dsp* dsp = nullptr):fDSP(dsp) {}
        virtual ~decorator_dsp() { delete fDSP; }

        virtual int getNumInputs() { return fDSP->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP->getNumOutputs(); }
        virtual void buildUserInterface(UI* ui_interface) { fDSP->buildUserInterface(ui_interface); }
        virtual int getSampleRate() { return fDSP->getSampleRate(); }
        virtual void init(int sample_rate) { fDSP->init(sample_rate); }
        virtual void instanceInit(int sample_rate) { fDSP->instanceInit(sample_rate); }
        virtual void instanceConstants(int sample_rate) { fDSP->instanceConstants(sample_rate); }
        virtual void instanceResetUserInterface() { fDSP->instanceResetUserInterface(); }
        virtual void instanceClear() { fDSP->instanceClear(); }
        virtual decorator_dsp* clone() { return new decorator_dsp(fDSP->clone()); }
        virtual void metadata(Meta* m) { fDSP->metadata(m); }
        // Beware: subclasses usually have to overload the two 'compute' methods
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { fDSP->compute(count, inputs, outputs); }
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { fDSP->compute(date_usec, count, inputs, outputs); }
    
};

/**
 * DSP factory class, used with LLVM and Interpreter backends
 * to create DSP instances from a compiled DSP program.
 */

class FAUST_API dsp_factory {
    
    protected:
    
        // So that to force sub-classes to use deleteDSPFactory(dsp_factory* factory);
        virtual ~dsp_factory() {}
    
    public:
    
        /* Return factory name */
        virtual std::string getName() = 0;
    
        /* Return factory SHA key */
        virtual std::string getSHAKey() = 0;
    
        /* Return factory expanded DSP code */
        virtual std::string getDSPCode() = 0;
    
        /* Return factory compile options */
        virtual std::string getCompileOptions() = 0;
    
        /* Get the Faust DSP factory list of library dependancies */
        virtual std::vector<std::string> getLibraryList() = 0;
    
        /* Get the list of all used includes */
        virtual std::vector<std::string> getIncludePathnames() = 0;
    
        /* Get warning messages list for a given compilation */
        virtual std::vector<std::string> getWarningMessages() = 0;
    
        /* Create a new DSP instance, to be deleted with C++ 'delete' */
        virtual dsp* createDSPInstance() = 0;
    
        /* Static tables initialization, possibly implemened in sub-classes*/
        virtual void classInit(int sample_rate) {};
    
        /* Set a custom memory manager to be used when creating instances */
        virtual void setMemoryManager(dsp_memory_manager* manager) = 0;
    
        /* Return the currently set custom memory manager */
        virtual dsp_memory_manager* getMemoryManager() = 0;
    
};

// Denormal handling

#if defined (__SSE__)
#include <xmmintrin.h>
#endif

class FAUST_API ScopedNoDenormals {
    
    private:
    
        intptr_t fpsr = 0;
        
        void setFpStatusRegister(intptr_t fpsr_aux) noexcept
        {
        #if defined (__arm64__) || defined (__aarch64__)
            asm volatile("msr fpcr, %0" : : "ri" (fpsr_aux));
        #elif defined (__SSE__)
            // The volatile keyword here is needed to workaround a bug in AppleClang 13.0
            // which aggressively optimises away the variable otherwise
            volatile uint32_t fpsr_w = static_cast<uint32_t>(fpsr_aux);
            _mm_setcsr(fpsr_w);
        #endif
        }
        
        void getFpStatusRegister() noexcept
        {
        #if defined (__arm64__) || defined (__aarch64__)
            asm volatile("mrs %0, fpcr" : "=r" (fpsr));
        #elif defined (__SSE__)
            fpsr = static_cast<intptr_t>(_mm_getcsr());
        #endif
        }
    
    public:
    
        ScopedNoDenormals() noexcept
        {
        #if defined (__arm64__) || defined (__aarch64__)
            intptr_t mask = (1 << 24 /* FZ */);
        #elif defined (__SSE__)
        #if defined (__SSE2__)
            intptr_t mask = 0x8040;
        #else
            intptr_t mask = 0x8000;
        #endif
        #else
            intptr_t mask = 0x0000;
        #endif
            getFpStatusRegister();
            setFpStatusRegister(fpsr | mask);
        }
        
        ~ScopedNoDenormals() noexcept
        {
            setFpStatusRegister(fpsr);
        }

};

#define AVOIDDENORMALS ScopedNoDenormals ftz_scope;

#endif

/************************** END dsp.h **************************/
/************************** BEGIN JSONUIDecoder.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 *************************************************************************/

#ifndef __JSONUIDecoder__
#define __JSONUIDecoder__

#include <vector>
#include <map>
#include <utility>
#include <cstdlib>
#include <sstream>
#include <functional>

/************************** BEGIN CGlue.h *****************************
FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
*************************************************************************/

#ifndef CGLUE_H
#define CGLUE_H

/************************** BEGIN UI.h *****************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ********************************************************************/

#ifndef __UI_H__
#define __UI_H__


#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

/*******************************************************************************
 * UI : Faust DSP User Interface
 * User Interface as expected by the buildUserInterface() method of a DSP.
 * This abstract class contains only the method that the Faust compiler can
 * generate to describe a DSP user interface.
 ******************************************************************************/

struct Soundfile;

template <typename REAL>
struct FAUST_API UIReal {
    
    UIReal() {}
    virtual ~UIReal() {}
    
    // -- widget's layouts
    
    virtual void openTabBox(const char* label) = 0;
    virtual void openHorizontalBox(const char* label) = 0;
    virtual void openVerticalBox(const char* label) = 0;
    virtual void closeBox() = 0;
    
    // -- active widgets
    
    virtual void addButton(const char* label, REAL* zone) = 0;
    virtual void addCheckButton(const char* label, REAL* zone) = 0;
    virtual void addVerticalSlider(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step) = 0;
    virtual void addHorizontalSlider(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step) = 0;
    virtual void addNumEntry(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step) = 0;
    
    // -- passive widgets
    
    virtual void addHorizontalBargraph(const char* label, REAL* zone, REAL min, REAL max) = 0;
    virtual void addVerticalBargraph(const char* label, REAL* zone, REAL min, REAL max) = 0;
    
    // -- soundfiles
    
    virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) = 0;
    
    // -- metadata declarations
    
    virtual void declare(REAL* /*zone*/, const char* /*key*/, const char* /*val*/) {}

    // To be used by LLVM client
    virtual int sizeOfFAUSTFLOAT() { return sizeof(FAUSTFLOAT); }
};

struct FAUST_API UI : public UIReal<FAUSTFLOAT> {
    UI() {}
    virtual ~UI() {}
};

#endif
/**************************  END  UI.h **************************/
/************************** BEGIN CInterface.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 *************************************************************************/

#ifndef CINTERFACE_H
#define CINTERFACE_H

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif
    
struct Soundfile;

/*******************************************************************************
 * UI, Meta and MemoryManager structures for C code.
 ******************************************************************************/

// -- widget's layouts

typedef void (* openTabBoxFun) (void* ui_interface, const char* label);
typedef void (* openHorizontalBoxFun) (void* ui_interface, const char* label);
typedef void (* openVerticalBoxFun) (void* ui_interface, const char* label);
typedef void (* closeBoxFun) (void* ui_interface);

// -- active widgets

typedef void (* addButtonFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone);
typedef void (* addCheckButtonFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone);
typedef void (* addVerticalSliderFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step);
typedef void (* addHorizontalSliderFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step);
typedef void (* addNumEntryFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step);

// -- passive widgets

typedef void (* addHorizontalBargraphFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max);
typedef void (* addVerticalBargraphFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max);

// -- soundfiles
    
typedef void (* addSoundfileFun) (void* ui_interface, const char* label, const char* url, struct Soundfile** sf_zone);

typedef void (* declareFun) (void* ui_interface, FAUSTFLOAT* zone, const char* key, const char* value);

typedef struct {

    void* uiInterface;

    openTabBoxFun openTabBox;
    openHorizontalBoxFun openHorizontalBox;
    openVerticalBoxFun openVerticalBox;
    closeBoxFun closeBox;
    addButtonFun addButton;
    addCheckButtonFun addCheckButton;
    addVerticalSliderFun addVerticalSlider;
    addHorizontalSliderFun addHorizontalSlider;
    addNumEntryFun addNumEntry;
    addHorizontalBargraphFun addHorizontalBargraph;
    addVerticalBargraphFun addVerticalBargraph;
    addSoundfileFun addSoundfile;
    declareFun declare;

} UIGlue;

typedef void (* metaDeclareFun) (void* ui_interface, const char* key, const char* value);

typedef struct {

    void* metaInterface;
    
    metaDeclareFun declare;

} MetaGlue;

/***************************************
 *  Interface for the DSP object
 ***************************************/

typedef char dsp_imp;
    
typedef dsp_imp* (* newDspFun) ();
typedef void (* destroyDspFun) (dsp_imp* dsp);
typedef int (* getNumInputsFun) (dsp_imp* dsp);
typedef int (* getNumOutputsFun) (dsp_imp* dsp);
typedef void (* buildUserInterfaceFun) (dsp_imp* dsp, UIGlue* ui);
typedef int (* getSampleRateFun) (dsp_imp* dsp);
typedef void (* initFun) (dsp_imp* dsp, int sample_rate);
typedef void (* classInitFun) (int sample_rate);
typedef void (* instanceInitFun) (dsp_imp* dsp, int sample_rate);
typedef void (* instanceConstantsFun) (dsp_imp* dsp, int sample_rate);
typedef void (* instanceResetUserInterfaceFun) (dsp_imp* dsp);
typedef void (* instanceClearFun) (dsp_imp* dsp);
typedef void (* computeFun) (dsp_imp* dsp, int len, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs);
typedef void (* metadataFun) (MetaGlue* meta);
    
/***************************************
 * DSP memory manager functions
 ***************************************/

typedef void* (* allocateFun) (void* manager_interface, size_t size);
typedef void (* destroyFun) (void* manager_interface, void* ptr);

typedef struct {
    
    void* managerInterface;
    
    allocateFun allocate;
    destroyFun destroy;
    
} MemoryManagerGlue;

#ifdef __cplusplus
}
#endif

#endif
/**************************  END  CInterface.h **************************/
/************************** BEGIN meta.h *******************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __meta__
#define __meta__


/**
 The base class of Meta handler to be used in dsp::metadata(Meta* m) method to retrieve (key, value) metadata.
 */
struct FAUST_API Meta {
    virtual ~Meta() {}
    virtual void declare(const char* key, const char* value) = 0;
};

#endif
/**************************  END  meta.h **************************/

#ifdef __cplusplus
extern "C" {
#endif

/*******************************************************************************
 * UI glue code
 ******************************************************************************/
 
class UIFloat
{

    public:

        UIFloat() {}

        virtual ~UIFloat() {}

        // -- widget's layouts

        virtual void openTabBox(const char* label) = 0;
        virtual void openHorizontalBox(const char* label) = 0;
        virtual void openVerticalBox(const char* label) = 0;
        virtual void closeBox() = 0;

        // -- active widgets

        virtual void addButton(const char* label, float* zone) = 0;
        virtual void addCheckButton(const char* label, float* zone) = 0;
        virtual void addVerticalSlider(const char* label, float* zone, float init, float min, float max, float step) = 0;
        virtual void addHorizontalSlider(const char* label, float* zone, float init, float min, float max, float step) = 0;
        virtual void addNumEntry(const char* label, float* zone, float init, float min, float max, float step) = 0;

        // -- passive widgets

        virtual void addHorizontalBargraph(const char* label, float* zone, float min, float max) = 0;
        virtual void addVerticalBargraph(const char* label, float* zone, float min, float max) = 0;
    
        // -- soundfiles
    
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) = 0;

        // -- metadata declarations

        virtual void declare(float* zone, const char* key, const char* val) {}
};

static void openTabBoxGlueFloat(void* cpp_interface, const char* label)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->openTabBox(label);
}

static void openHorizontalBoxGlueFloat(void* cpp_interface, const char* label)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->openHorizontalBox(label);
}

static void openVerticalBoxGlueFloat(void* cpp_interface, const char* label)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->openVerticalBox(label);
}

static void closeBoxGlueFloat(void* cpp_interface)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->closeBox();
}

static void addButtonGlueFloat(void* cpp_interface, const char* label, float* zone)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addButton(label, zone);
}

static void addCheckButtonGlueFloat(void* cpp_interface, const char* label, float* zone)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addCheckButton(label, zone);
}

static void addVerticalSliderGlueFloat(void* cpp_interface, const char* label, float* zone, float init, float min, float max, float step)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addVerticalSlider(label, zone, init, min, max, step);
}

static void addHorizontalSliderGlueFloat(void* cpp_interface, const char* label, float* zone, float init, float min, float max, float step)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addHorizontalSlider(label, zone, init, min, max, step);
}

static void addNumEntryGlueFloat(void* cpp_interface, const char* label, float* zone, float init, float min, float max, float step)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addNumEntry(label, zone, init, min, max, step);
}

static void addHorizontalBargraphGlueFloat(void* cpp_interface, const char* label, float* zone, float min, float max)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addHorizontalBargraph(label, zone, min, max);
}

static void addVerticalBargraphGlueFloat(void* cpp_interface, const char* label, float* zone, float min, float max)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addVerticalBargraph(label, zone, min, max);
}
    
static void addSoundfileGlueFloat(void* cpp_interface, const char* label, const char* url, Soundfile** sf_zone)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addSoundfile(label, url, sf_zone);
}

static void declareGlueFloat(void* cpp_interface, float* zone, const char* key, const char* value)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->declare(zone, key, value);
}

class UIDouble
{

    public:

        UIDouble() {}

        virtual ~UIDouble() {}

        // -- widget's layouts

        virtual void openTabBox(const char* label) = 0;
        virtual void openHorizontalBox(const char* label) = 0;
        virtual void openVerticalBox(const char* label) = 0;
        virtual void closeBox() = 0;

        // -- active widgets

        virtual void addButton(const char* label, double* zone) = 0;
        virtual void addCheckButton(const char* label, double* zone) = 0;
        virtual void addVerticalSlider(const char* label, double* zone, double init, double min, double max, double step) = 0;
        virtual void addHorizontalSlider(const char* label, double* zone, double init, double min, double max, double step) = 0;
        virtual void addNumEntry(const char* label, double* zone, double init, double min, double max, double step) = 0;

        // -- passive widgets

        virtual void addHorizontalBargraph(const char* label, double* zone, double min, double max) = 0;
        virtual void addVerticalBargraph(const char* label, double* zone, double min, double max) = 0;
    
        // -- soundfiles
    
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) = 0;

        // -- metadata declarations

        virtual void declare(double* zone, const char* key, const char* val) {}
};

static void openTabBoxGlueDouble(void* cpp_interface, const char* label)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->openTabBox(label);
}

static void openHorizontalBoxGlueDouble(void* cpp_interface, const char* label)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->openHorizontalBox(label);
}

static void openVerticalBoxGlueDouble(void* cpp_interface, const char* label)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->openVerticalBox(label);
}

static void closeBoxGlueDouble(void* cpp_interface)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->closeBox();
}

static void addButtonGlueDouble(void* cpp_interface, const char* label, double* zone)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addButton(label, zone);
}

static void addCheckButtonGlueDouble(void* cpp_interface, const char* label, double* zone)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addCheckButton(label, zone);
}

static void addVerticalSliderGlueDouble(void* cpp_interface, const char* label, double* zone, double init, double min, double max, double step)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addVerticalSlider(label, zone, init, min, max, step);
}

static void addHorizontalSliderGlueDouble(void* cpp_interface, const char* label, double* zone, double init, double min, double max, double step)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addHorizontalSlider(label, zone, init, min, max, step);
}

static void addNumEntryGlueDouble(void* cpp_interface, const char* label, double* zone, double init, double min, double max, double step)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addNumEntry(label, zone, init, min, max, step);
}

static void addHorizontalBargraphGlueDouble(void* cpp_interface, const char* label, double* zone, double min, double max)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addHorizontalBargraph(label, zone, min, max);
}

static void addVerticalBargraphGlueDouble(void* cpp_interface, const char* label, double* zone, double min, double max)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addVerticalBargraph(label, zone, min, max);
}
    
static void addSoundfileGlueDouble(void* cpp_interface, const char* label, const char* url, Soundfile** sf_zone)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addSoundfile(label, url, sf_zone);
}

static void declareGlueDouble(void* cpp_interface, double* zone, const char* key, const char* value)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->declare(zone, key, value);
}

static void buildUIGlue(UIGlue* glue, UI* ui_interface, bool is_double)
{
    glue->uiInterface = ui_interface;
    
    if (is_double) {
        glue->openTabBox = reinterpret_cast<openTabBoxFun>(openTabBoxGlueDouble);
        glue->openHorizontalBox = reinterpret_cast<openHorizontalBoxFun>(openHorizontalBoxGlueDouble);
        glue->openVerticalBox = reinterpret_cast<openVerticalBoxFun>(openVerticalBoxGlueDouble);
        glue->closeBox = reinterpret_cast<closeBoxFun>(closeBoxGlueDouble);
        glue->addButton = reinterpret_cast<addButtonFun>(addButtonGlueDouble);
        glue->addCheckButton = reinterpret_cast<addCheckButtonFun>(addCheckButtonGlueDouble);
        glue->addVerticalSlider = reinterpret_cast<addVerticalSliderFun>(addVerticalSliderGlueDouble);
        glue->addHorizontalSlider = reinterpret_cast<addHorizontalSliderFun>(addHorizontalSliderGlueDouble);
        glue->addNumEntry = reinterpret_cast<addNumEntryFun>(addNumEntryGlueDouble);
        glue->addHorizontalBargraph = reinterpret_cast<addHorizontalBargraphFun>(addHorizontalBargraphGlueDouble);
        glue->addVerticalBargraph = reinterpret_cast<addVerticalBargraphFun>(addVerticalBargraphGlueDouble);
        glue->addSoundfile = reinterpret_cast<addSoundfileFun>(addSoundfileGlueDouble);
        glue->declare = reinterpret_cast<declareFun>(declareGlueDouble);
    } else {
        glue->openTabBox = reinterpret_cast<openTabBoxFun>(openTabBoxGlueFloat);
        glue->openHorizontalBox = reinterpret_cast<openHorizontalBoxFun>(openHorizontalBoxGlueFloat);
        glue->openVerticalBox = reinterpret_cast<openVerticalBoxFun>(openVerticalBoxGlueFloat);
        glue->closeBox = reinterpret_cast<closeBoxFun>(closeBoxGlueFloat);
        glue->addButton = reinterpret_cast<addButtonFun>(addButtonGlueFloat);
        glue->addCheckButton = reinterpret_cast<addCheckButtonFun>(addCheckButtonGlueFloat);
        glue->addVerticalSlider = reinterpret_cast<addVerticalSliderFun>(addVerticalSliderGlueFloat);
        glue->addHorizontalSlider = reinterpret_cast<addHorizontalSliderFun>(addHorizontalSliderGlueFloat);
        glue->addNumEntry = reinterpret_cast<addNumEntryFun>(addNumEntryGlueFloat);
        glue->addHorizontalBargraph = reinterpret_cast<addHorizontalBargraphFun>(addHorizontalBargraphGlueFloat);
        glue->addVerticalBargraph = reinterpret_cast<addVerticalBargraphFun>(addVerticalBargraphGlueFloat);
        glue->addSoundfile = reinterpret_cast<addSoundfileFun>(addSoundfileGlueFloat);
        glue->declare = reinterpret_cast<declareFun>(declareGlueFloat);
    }
}
    
// Base class
    
struct UIInterface
{
    virtual ~UIInterface() {}
    
    virtual int sizeOfFAUSTFLOAT() = 0;
    
    // -- widget's layouts
    
    virtual void openTabBox(const char* label) = 0;
    virtual void openHorizontalBox(const char* label) = 0;
    virtual void openVerticalBox(const char* label) = 0;
    virtual void closeBox() = 0;
    
    // float version
    
    // -- active widgets
    
    virtual void addButton(const char* label, float* zone) = 0;
    virtual void addCheckButton(const char* label, float* zone) = 0;
    
    virtual void addVerticalSlider(const char* label, float* zone, float init, float min, float max, float step) = 0;
    virtual void addHorizontalSlider(const char* label, float* zone, float init, float min, float max, float step) = 0;
    virtual void addNumEntry(const char* label, float* zone, float init, float min, float max, float step) = 0;
    
    // -- passive widgets
    
    virtual void addHorizontalBargraph(const char* label, float* zone, float min, float max) = 0;
    virtual void addVerticalBargraph(const char* label, float* zone, float min, float max) = 0;
    
    // -- metadata declarations
    
    virtual void declare(float* zone, const char* key, const char* val) = 0;
    
    // double version
    
    virtual void addButton(const char* label, double* zone) = 0;
    virtual void addCheckButton(const char* label, double* zone) = 0;
  
    virtual void addVerticalSlider(const char* label, double* zone, double init, double min, double max, double step) = 0;
    virtual void addHorizontalSlider(const char* label, double* zone, double init, double min, double max, double step) = 0;
    
    virtual void addNumEntry(const char* label, double* zone, double init, double min, double max, double step) = 0;
    
    // -- soundfiles
    
    virtual void addSoundfile(const char* label, const char* url, Soundfile** sf_zone) = 0;
    
    // -- passive widgets
    
    virtual void addHorizontalBargraph(const char* label, double* zone, double min, double max) = 0;
    virtual void addVerticalBargraph(const char* label, double* zone, double min, double max) = 0;
     
    // -- metadata declarations
    
    virtual void declare(double* zone, const char* key, const char* val) = 0;
    
};
    
struct UITemplate : public UIInterface
{
 
    void* fCPPInterface;

    UITemplate(void* cpp_interface):fCPPInterface(cpp_interface)
    {}
    virtual ~UITemplate() {}
    
    int sizeOfFAUSTFLOAT()
    {
        return reinterpret_cast<UI*>(fCPPInterface)->sizeOfFAUSTFLOAT();
    }
    
    // -- widget's layouts
    
    void openTabBox(const char* label)
    {
        openTabBoxGlueFloat(fCPPInterface, label);
    }
    void openHorizontalBox(const char* label)
    {
        openHorizontalBoxGlueFloat(fCPPInterface, label);
    }
    void openVerticalBox(const char* label)
    {
        openVerticalBoxGlueFloat(fCPPInterface, label);
    }
    void closeBox()
    {
        closeBoxGlueFloat(fCPPInterface);
    }
    
    // float version
    
    // -- active widgets
    
    void addButton(const char* label, float* zone)
    {
        addButtonGlueFloat(fCPPInterface, label, zone);
    }
    void addCheckButton(const char* label, float* zone)
    {
        addCheckButtonGlueFloat(fCPPInterface, label, zone);
    }
    
    void addVerticalSlider(const char* label, float* zone, float init, float min, float max, float step)
    {
        addVerticalSliderGlueFloat(fCPPInterface, label, zone, init, min, max, step);
    }
    
    void addHorizontalSlider(const char* label, float* zone, float init, float min, float max, float step)
    {
        addHorizontalSliderGlueFloat(fCPPInterface, label, zone, init, min, max, step);
    }
    
    void addNumEntry(const char* label, float* zone, float init, float min, float max, float step)
    {
        addNumEntryGlueFloat(fCPPInterface, label, zone, init, min, max, step);
    }
    
    // -- passive widgets
    
    void addHorizontalBargraph(const char* label, float* zone, float min, float max)
    {
        addHorizontalBargraphGlueFloat(fCPPInterface, label, zone, min, max);
    }
    
    void addVerticalBargraph(const char* label, float* zone, float min, float max)
    {
        addVerticalBargraphGlueFloat(fCPPInterface, label, zone, min, max);
    }

    // -- metadata declarations
    
    void declare(float* zone, const char* key, const char* val)
    {
        declareGlueFloat(fCPPInterface, zone, key, val);
    }
    
    // double version
    
    void addButton(const char* label, double* zone)
    {
        addButtonGlueDouble(fCPPInterface, label, zone);
    }
    void addCheckButton(const char* label, double* zone)
    {
        addCheckButtonGlueDouble(fCPPInterface, label, zone);
    }
    
    void addVerticalSlider(const char* label, double* zone, double init, double min, double max, double step)
    {
        addVerticalSliderGlueDouble(fCPPInterface, label, zone, init, min, max, step);
    }
    
    void addHorizontalSlider(const char* label, double* zone, double init, double min, double max, double step)
    {
        addHorizontalSliderGlueDouble(fCPPInterface, label, zone, init, min, max, step);
    }
    
    void addNumEntry(const char* label, double* zone, double init, double min, double max, double step)
    {
        addNumEntryGlueDouble(fCPPInterface, label, zone, init, min, max, step);
    }

    // -- soundfiles
    
    void addSoundfile(const char* label, const char* url, Soundfile** sf_zone)
    {
        addSoundfileGlueFloat(fCPPInterface, label, url, sf_zone);
    }

    // -- passive widgets
    
    void addHorizontalBargraph(const char* label, double* zone, double min, double max)
    {
        addHorizontalBargraphGlueDouble(fCPPInterface, label, zone, min, max);
    }
    
    void addVerticalBargraph(const char* label, double* zone, double min, double max)
    {
        addVerticalBargraphGlueDouble(fCPPInterface, label, zone, min, max);
    }

    // -- metadata declarations
    
    void declare(double* zone, const char* key, const char* val)
    {
        declareGlueDouble(fCPPInterface, zone, key, val);
    }

};
    
struct UIGlueTemplate : public UIInterface
{
    
    UIGlue* fGlue;
    
    UIGlueTemplate(UIGlue* glue):fGlue(glue)
    {}
    virtual ~UIGlueTemplate() {}
    
    virtual int sizeOfFAUSTFLOAT() { return sizeof(FAUSTFLOAT); }
    
    // -- widget's layouts
    
    void openTabBox(const char* label)
    {
        fGlue->openTabBox(fGlue->uiInterface, label);
    }
    void openHorizontalBox(const char* label)
    {
        fGlue->openHorizontalBox(fGlue->uiInterface, label);
    }
    void openVerticalBox(const char* label)
    {
        fGlue->openVerticalBox(fGlue->uiInterface, label);
    }
    void closeBox()
    {
        fGlue->closeBox(fGlue->uiInterface);
    }

    // float version
    
    // -- active widgets
    
    void addButton(const char* label, float* zone)
    {
        fGlue->addButton(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone));
    }
    void addCheckButton(const char* label, float* zone)
    {
        fGlue->addCheckButton(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone));
    }
    
    void addVerticalSlider(const char* label, float* zone, float init, float min, float max, float step)
    {
        fGlue->addVerticalSlider(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), init, min, max, step);
    }
    void addHorizontalSlider(const char* label, float* zone, float init, float min, float max, float step)
    {
        fGlue->addHorizontalSlider(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), init, min, max, step);
    }
    void addNumEntry(const char* label, float* zone, float init, float min, float max, float step)
    {
        fGlue->addNumEntry(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), init, min, max, step);
    }
    
    // -- passive widgets
    
    void addHorizontalBargraph(const char* label, float* zone, float min, float max)
    {
        fGlue->addHorizontalBargraph(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), min, max);
    }
    void addVerticalBargraph(const char* label, float* zone, float min, float max)
    {
        fGlue->addVerticalBargraph(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), min, max);
    }
    
    // -- metadata declarations
    
    void declare(float* zone, const char* key, const char* val)
    {
        fGlue->declare(fGlue->uiInterface, reinterpret_cast<FAUSTFLOAT*>(zone), key, val);
    }
    
    // double version
    
    void addButton(const char* label, double* zone)
    {
        fGlue->addButton(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone));
    }
    void addCheckButton(const char* label, double* zone)
    {
        fGlue->addCheckButton(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone));
    }
    
    void addVerticalSlider(const char* label, double* zone, double init, double min, double max, double step)
    {
        fGlue->addVerticalSlider(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), init, min, max, step);
    }
    void addHorizontalSlider(const char* label, double* zone, double init, double min, double max, double step)
    {
        fGlue->addHorizontalSlider(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), init, min, max, step);
    }
    void addNumEntry(const char* label, double* zone, double init, double min, double max, double step)
    {
        fGlue->addNumEntry(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), init, min, max, step);
    }
    // -- soundfiles
    
    void addSoundfile(const char* label, const char* url, Soundfile** sf_zone) {}
    
    // -- passive widgets
    
    void addHorizontalBargraph(const char* label, double* zone, double min, double max)
    {
        fGlue->addHorizontalBargraph(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), min, max);
    }
    void addVerticalBargraph(const char* label, double* zone, double min, double max)
    {
        fGlue->addVerticalBargraph(fGlue->uiInterface, label, reinterpret_cast<FAUSTFLOAT*>(zone), min, max);
    }
    
    // -- metadata declarations
    
    void declare(double* zone, const char* key, const char* val)
    {
        fGlue->declare(fGlue->uiInterface, reinterpret_cast<FAUSTFLOAT*>(zone), key, val);
    }
    
};

/*******************************************************************************
 * Meta glue code
 ******************************************************************************/

static void declareMetaGlue(void* cpp_interface, const char* key, const char* value)
{
    Meta* meta_interface = static_cast<Meta*>(cpp_interface);
    meta_interface->declare(key, value);
}

static void buildMetaGlue(MetaGlue* glue, Meta* meta)
{
    glue->metaInterface = meta;
    glue->declare = declareMetaGlue;
}
    
/*******************************************************************************
 * Memory manager glue code
 ******************************************************************************/

static void* allocateMemoryManagerGlue(void* cpp_interface, size_t size)
{
    dsp_memory_manager* manager_interface = static_cast<dsp_memory_manager*>(cpp_interface);
    return manager_interface->allocate(size);
}
    
static void destroyMemoryManagerGlue(void* cpp_interface, void* ptr)
{
    dsp_memory_manager* manager_interface = static_cast<dsp_memory_manager*>(cpp_interface);
    manager_interface->destroy(ptr);
}

static void buildManagerGlue(MemoryManagerGlue* glue, dsp_memory_manager* manager)
{
    glue->managerInterface = manager;
    glue->allocate = allocateMemoryManagerGlue;
    glue->destroy = destroyMemoryManagerGlue;
}

#ifdef __cplusplus
}
#endif

#endif
/**************************  END  CGlue.h **************************/
/************************** BEGIN SimpleParser.h *********************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ********************************************************************/

#ifndef SIMPLEPARSER_H
#define SIMPLEPARSER_H

// ---------------------------------------------------------------------
//                          Simple Parser
// A parser returns true if it was able to parse what it is
// supposed to parse and advance the pointer. Otherwise it returns false
// and the pointer is not advanced so that another parser can be tried.
// ---------------------------------------------------------------------

#include <vector>
#include <map>
#include <string>
#include <cmath>
#include <fstream>
#include <sstream>
#include <stdio.h> // We use the lighter fprintf code
#include <ctype.h>
#include <assert.h>

#ifndef _WIN32
# pragma GCC diagnostic ignored "-Wunused-function"
#endif

struct itemInfo {
    std::string type;
    std::string label;
    std::string shortname;
    std::string address;
    std::string url;
    int index;
    double init;
    double fmin;
    double fmax;
    double step;
    std::vector<std::pair<std::string, std::string> > meta;
    
    itemInfo():index(0), init(0.), fmin(0.), fmax(0.), step(0.)
    {}
};

// ---------------------------------------------------------------------
//                          Elementary parsers
// ---------------------------------------------------------------------

// Report a parsing error
static bool parseError(const char*& p, const char* errmsg)
{
    fprintf(stderr, "Parse error : %s here : %s\n", errmsg, p);
    return true;
}

/**
 * @brief skipBlank : advance pointer p to the first non blank character
 * @param p the string to parse, then the remaining string
 */
static void skipBlank(const char*& p)
{
    while (isspace(*p)) { p++; }
}

// Parse character x, but don't report error if fails
static bool tryChar(const char*& p, char x)
{
    skipBlank(p);
    if (x == *p) {
        p++;
        return true;
    } else {
        return false;
    }
}

/**
 * @brief parseChar : parse a specific character x
 * @param p the string to parse, then the remaining string
 * @param x the character to recognize
 * @return true if x was found at the begin of p
 */
static bool parseChar(const char*& p, char x)
{
    skipBlank(p);
    if (x == *p) {
        p++;
        return true;
    } else {
        return false;
    }
}

/**
 * @brief parseWord : parse a specific string w
 * @param p the string to parse, then the remaining string
 * @param w the string to recognize
 * @return true if string w was found at the begin of p
 */
static bool parseWord(const char*& p, const char* w)
{
    skipBlank(p);
    const char* saved = p;  // to restore position if we fail
    while ((*w == *p) && (*w)) {++w; ++p;}
    if (*w) {
        p = saved;
        return false;
    } else {
        return true;
    }
}

/**
 * @brief parseDouble : parse number [s]dddd[.dddd] or [s]d[.dddd][E|e][s][dddd] and store the result in x
 * @param p the string to parse, then the remaining string
 * @param x the float number found if any
 * @return true if a float number was found at the begin of p
 */
static bool parseDouble(const char*& p, double& x)
{
    double sign = 1.0;     // sign of the number
    double ipart = 0;      // integral part of the number
    double dpart = 0;      // decimal part of the number before division
    double dcoef = 1.0;    // division factor for the decimal part
    double expsign = 1.0;  // sign of the E|e part
    double expcoef = 0.0;  // multiplication factor of E|e part
    
    bool valid = false;    // true if the number contains at least one digit
    
    skipBlank(p);
    const char* saved = p;  // to restore position if we fail
    
    // Sign
    if (parseChar(p, '+')) {
        sign = 1.0;
    } else if (parseChar(p, '-')) {
        sign = -1.0;
    }
    
    // Integral part
    while (isdigit(*p)) {
        valid = true;
        ipart = ipart*10 + (*p - '0');
        p++;
    }
    
    // Possible decimal part
    if (parseChar(p, '.')) {
        while (isdigit(*p)) {
            valid = true;
            dpart = dpart*10 + (*p - '0');
            dcoef *= 10.0;
            p++;
        }
    }
    
    // Possible E|e part
    if (parseChar(p, 'E') || parseChar(p, 'e')) {
        if (parseChar(p, '+')) {
            expsign = 1.0;
        } else if (parseChar(p, '-')) {
            expsign = -1.0;
        }
        while (isdigit(*p)) {
            expcoef = expcoef*10 + (*p - '0');
            p++;
        }
    }
    
    if (valid)  {
        x = (sign*(ipart + dpart/dcoef)) * std::pow(10.0, expcoef*expsign);
    } else {
        p = saved;
    }
    return valid;
}

/**
 * @brief parseString, parse an arbitrary quoted string q...q and store the result in s
 * @param p the string to parse, then the remaining string
 * @param quote the character used to quote the string
 * @param s the (unquoted) string found if any
 * @return true if a string was found at the begin of p
 */
static bool parseString(const char*& p, char quote, std::string& s)
{
    std::string str;
    skipBlank(p);
    
    const char* saved = p;  // to restore position if we fail
    if (*p++ == quote) {
        while ((*p != 0) && (*p != quote)) {
            str += *p++;
        }
        if (*p++ == quote) {
            s = str;
            return true;
        }
    }
    p = saved;
    return false;
}

/**
 * @brief parseSQString, parse a single quoted string '...' and store the result in s
 * @param p the string to parse, then the remaining string
 * @param s the (unquoted) string found if any
 * @return true if a string was found at the begin of p
 */
static bool parseSQString(const char*& p, std::string& s)
{
    return parseString(p, '\'', s);
}

/**
 * @brief parseDQString, parse a double quoted string "..." and store the result in s
 * @param p the string to parse, then the remaining string
 * @param s the (unquoted) string found if any
 * @return true if a string was found at the begin of p
 */
static bool parseDQString(const char*& p, std::string& s)
{
    return parseString(p, '"', s);
}

// ---------------------------------------------------------------------
//
//                          IMPLEMENTATION
// 
// ---------------------------------------------------------------------

/**
 * @brief parseMenuItem, parse a menu item ...'low':440.0...
 * @param p the string to parse, then the remaining string
 * @param name the name found
 * @param value the value found
 * @return true if a nemu item was found
 */
static bool parseMenuItem(const char*& p, std::string& name, double& value)
{
    const char* saved = p;  // to restore position if we fail
    if (parseSQString(p, name) && parseChar(p, ':') && parseDouble(p, value)) {
        return true;
    } else {
        p = saved;
        return false;
    }
}

static bool parseMenuItem2(const char*& p, std::string& name)
{
    const char* saved = p;  // to restore position if we fail
    // single quoted
    if (parseSQString(p, name)) {
        return true;
    } else {
        p = saved;
        return false;
    }
}

/**
 * @brief parseMenuList, parse a menu list {'low' : 440.0; 'mid' : 880.0; 'hi' : 1760.0}...
 * @param p the string to parse, then the remaining string
 * @param names the vector of names found
 * @param values the vector of values found
 * @return true if a menu list was found
 */
static bool parseMenuList(const char*& p, std::vector<std::string>& names, std::vector<double>& values)
{
    std::vector<std::string> tmpnames;
    std::vector<double> tmpvalues;
    const char* saved = p; // to restore position if we fail

    if (parseChar(p, '{')) {
        do {
            std::string n;
            double v;
            if (parseMenuItem(p, n, v)) {
                tmpnames.push_back(n);
                tmpvalues.push_back(v);
            } else {
                p = saved;
                return false;
            }
        } while (parseChar(p, ';'));
        if (parseChar(p, '}')) {
            // we suceeded
            names = tmpnames;
            values = tmpvalues;
            return true;
        }
    }
    p = saved;
    return false;
}

static bool parseMenuList2(const char*& p, std::vector<std::string>& names, bool debug)
{
    std::vector<std::string> tmpnames;
    const char* saved = p;  // to restore position if we fail
    
    if (parseChar(p, '{')) {
        do {
            std::string n;
            if (parseMenuItem2(p, n)) {
                tmpnames.push_back(n);
            } else {
                goto error;
            }
        } while (parseChar(p, ';'));
        if (parseChar(p, '}')) {
            // we suceeded
            names = tmpnames;
            return true;
        }
    }
    
error:
    if (debug) { fprintf(stderr, "parseMenuList2 : (%s) is not a valid list !\n", p); }
    p = saved;
    return false;
}

/// ---------------------------------------------------------------------
// Parse list of strings
/// ---------------------------------------------------------------------
static bool parseList(const char*& p, std::vector<std::string>& items)
{
    const char* saved = p;  // to restore position if we fail
    if (parseChar(p, '[')) {
        do {
            std::string item;
            if (!parseDQString(p, item)) {
                p = saved;
                return false;
            }
            items.push_back(item);
        } while (tryChar(p, ','));
        return parseChar(p, ']');
    } else {
        p = saved;
        return false;
    }
}

static bool parseMetaData(const char*& p, std::map<std::string, std::string>& metadatas)
{
    const char* saved = p; // to restore position if we fail
    std::string metaKey, metaValue;
    if (parseChar(p, ':') && parseChar(p, '[')) {
        do { 
            if (parseChar(p, '{') && parseDQString(p, metaKey) && parseChar(p, ':') && parseDQString(p, metaValue) && parseChar(p, '}')) {
                metadatas[metaKey] = metaValue;
            }
        } while (tryChar(p, ','));
        return parseChar(p, ']');
    } else {
        p = saved;
        return false;
    }
}

static bool parseItemMetaData(const char*& p, std::vector<std::pair<std::string, std::string> >& metadatas)
{
    const char* saved = p; // to restore position if we fail
    std::string metaKey, metaValue;
    if (parseChar(p, ':') && parseChar(p, '[')) {
        do { 
            if (parseChar(p, '{') && parseDQString(p, metaKey) && parseChar(p, ':') && parseDQString(p, metaValue) && parseChar(p, '}')) {
                metadatas.push_back(std::make_pair(metaKey, metaValue));
            }
        } while (tryChar(p, ','));
        return parseChar(p, ']');
    } else {
        p = saved;
        return false;
    }
}

// ---------------------------------------------------------------------
// Parse metadatas of the interface:
// "name" : "...", "inputs" : "...", "outputs" : "...", ...
// and store the result as key/value
/// ---------------------------------------------------------------------
static bool parseGlobalMetaData(const char*& p, std::string& key, std::string& value, double& dbl, std::map<std::string, std::string>& metadatas, std::vector<std::string>& items)
{
    const char* saved = p; // to restore position if we fail
    if (parseDQString(p, key)) {
        if (key == "meta") {
            return parseMetaData(p, metadatas);
        } else {
            return parseChar(p, ':') && (parseDQString(p, value) || parseList(p, items) || parseDouble(p, dbl));
        }
    } else {
        p = saved;
        return false;
    }
}

// ---------------------------------------------------------------------
// Parse gui:
// "type" : "...", "label" : "...", "address" : "...", ...
// and store the result in uiItems Vector
/// ---------------------------------------------------------------------
static bool parseUI(const char*& p, std::vector<itemInfo>& uiItems, int& numItems)
{
    const char* saved = p; // to restore position if we fail
    if (parseChar(p, '{')) {
   
        std::string label;
        std::string value;
        double dbl = 0;
        
        do {
            if (parseDQString(p, label)) {
                if (label == "type") {
                    if (uiItems.size() != 0) {
                        numItems++;
                    }
                    if (parseChar(p, ':') && parseDQString(p, value)) {   
                        itemInfo item;
                        item.type = value;
                        uiItems.push_back(item);
                    }
                }
                
                else if (label == "label") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].label = value;
                    }
                }
                
                else if (label == "shortname") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].shortname = value;
                    }
                }
                
                else if (label == "address") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].address = value;
                    }
                }
                
                else if (label == "url") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].url = value;
                    }
                }
                
                else if (label == "index") {
                    if (parseChar(p, ':') && parseDouble(p, dbl)) {
                        uiItems[numItems].index = int(dbl);
                    }
                }
                
                else if (label == "meta") {
                    if (!parseItemMetaData(p, uiItems[numItems].meta)) {
                        return false;
                    }
                }
                
                else if (label == "init") {
                    if (parseChar(p, ':') && parseDouble(p, dbl)) {
                        uiItems[numItems].init = dbl;
                    }
                }
                
                else if (label == "min") {
                    if (parseChar(p, ':') && parseDouble(p, dbl)) {
                        uiItems[numItems].fmin = dbl;
                    }
                }
                
                else if (label == "max") {
                    if (parseChar(p, ':') && parseDouble(p, dbl)) {
                        uiItems[numItems].fmax = dbl;
                    }
                }
                
                else if (label == "step") {
                    if (parseChar(p, ':') && parseDouble(p, dbl)) {
                        uiItems[numItems].step = dbl;
                    }
                }
                
                else if (label == "items") {
                    if (parseChar(p, ':') && parseChar(p, '[')) {
                        do {
                            if (!parseUI(p, uiItems, numItems)) {
                                p = saved;
                                return false;
                            }
                        } while (tryChar(p, ','));
                        if (parseChar(p, ']')) {
                            itemInfo item;
                            item.type = "close";
                            uiItems.push_back(item);
                            numItems++;
                        }
                    }
            
                } else {
                    fprintf(stderr, "Parse error unknown : %s \n", label.c_str());
                    assert(false);
                }
            } else {
                p = saved;
                return false;
            }
            
        } while (tryChar(p, ','));
    
        return parseChar(p, '}');
    } else {
        return true; // "items": [] is valid
    }
}

// ---------------------------------------------------------------------
// Parse full JSON record describing a JSON/Faust interface :
// {"metadatas": "...", "ui": [{ "type": "...", "label": "...", "items": [...], "address": "...","init": "...", "min": "...", "max": "...","step": "..."}]}
//
// and store the result in map Metadatas and vector containing the items of the interface. Returns true if parsing was successfull.
/// ---------------------------------------------------------------------
static bool parseJson(const char*& p,
                      std::map<std::string, std::pair<std::string, double> >& metaDatas0,
                      std::map<std::string, std::string>& metaDatas1,
                      std::map<std::string, std::vector<std::string> >& metaDatas2,
                      std::vector<itemInfo>& uiItems)
{
    parseChar(p, '{');
    
    do {
        std::string key;
        std::string value;
        double dbl = 0;
        std::vector<std::string> items;
        if (parseGlobalMetaData(p, key, value, dbl, metaDatas1, items)) {
            if (key != "meta") {
                // keep "name", "inputs", "outputs" key/value pairs
                if (items.size() > 0) {
                    metaDatas2[key] = items;
                    items.clear();
                } else if (value != "") {
                    metaDatas0[key].first = value;
                } else {
                    metaDatas0[key].second = dbl;
                }
            }
        } else if (key == "ui") {
            int numItems = 0;
            parseChar(p, '[') && parseUI(p, uiItems, numItems);
        }
    } while (tryChar(p, ','));
    
    return parseChar(p, '}');
}

#endif // SIMPLEPARSER_H
/**************************  END  SimpleParser.h **************************/

#ifdef _WIN32
#include <windows.h>
#define snprintf _snprintf
#define STRDUP _strdup
#else
#define STRDUP strdup
#endif

//------------------------------------------------------------------------------------------
//  Decode a dsp JSON description and implement 'buildUserInterface' and 'metadata' methods
//------------------------------------------------------------------------------------------

#define REAL_UI(ui_interface) reinterpret_cast<UIReal<REAL>*>(ui_interface)
#define REAL_ADR(index)      reinterpret_cast<REAL*>(&memory_block[index])
#define REAL_EXT_ADR(index)  reinterpret_cast<FAUSTFLOAT*>(&memory_block[index])
#define SOUNDFILE_ADR(index) reinterpret_cast<Soundfile**>(&memory_block[index])

typedef std::function<void(FAUSTFLOAT)> ReflectFunction;
typedef std::function<FAUSTFLOAT()> ModifyFunction;

struct FAUST_API ExtZoneParam {

    virtual void reflectZone() = 0;
    virtual void modifyZone() = 0;
    
    virtual void setReflectZoneFun(ReflectFunction reflect) = 0;
    virtual void setModifyZoneFun(ModifyFunction modify) = 0;
    
    virtual ~ExtZoneParam()
    {}
    
};

// Templated decoder

struct FAUST_API JSONUIDecoderBase
{
    virtual ~JSONUIDecoderBase()
    {}
    
    virtual void metadata(Meta* m) = 0;
    virtual void metadata(MetaGlue* glue) = 0;
    virtual int getDSPSize() = 0;
    virtual std::string getName() = 0;
    virtual std::string getLibVersion() = 0;
    virtual std::string getCompileOptions() = 0;
    virtual std::vector<std::string> getLibraryList() = 0;
    virtual std::vector<std::string> getIncludePathnames() = 0;
    virtual int getNumInputs() = 0;
    virtual int getNumOutputs() = 0;
    virtual int getSampleRate(char* memory_block) = 0;
    virtual void setReflectZoneFun(int index, ReflectFunction fun) = 0;
    virtual void setModifyZoneFun(int index, ModifyFunction fun) = 0;
    virtual void setupDSPProxy(UI* ui_interface, char* memory_block) = 0;
    virtual bool hasDSPProxy() = 0;
    virtual std::vector<ExtZoneParam*>& getInputControls() = 0;
    virtual std::vector<ExtZoneParam*>& getOutputControls() = 0;
    virtual void resetUserInterface() = 0;
    virtual void resetUserInterface(char* memory_block, Soundfile* defaultsound = nullptr) = 0;
    virtual void buildUserInterface(UI* ui_interface) = 0;
    virtual void buildUserInterface(UI* ui_interface, char* memory_block) = 0;
    virtual void buildUserInterface(UIGlue* ui_interface, char* memory_block) = 0;
    virtual bool hasCompileOption(const std::string& option) = 0;
};

template <typename REAL>
struct FAUST_API JSONUIDecoderReal : public JSONUIDecoderBase {
    
    struct ZoneParam : public ExtZoneParam {
        
        FAUSTFLOAT fZone;
        ReflectFunction fReflect;
        ModifyFunction fModify;
        
    #if defined(TARGET_OS_IPHONE) || defined(WIN32)
        ZoneParam(ReflectFunction reflect = nullptr, ModifyFunction modify = nullptr)
        :fReflect(reflect), fModify(modify)
        {}
        void reflectZone() { if (fReflect) fReflect(fZone); }
        void modifyZone() { if (fModify) fZone = fModify(); }
    #else
        ZoneParam(ReflectFunction reflect = [](FAUSTFLOAT value) {}, ModifyFunction modify = []() { return FAUSTFLOAT(-1); })
        :fReflect(reflect), fModify(modify)
        {}
        void reflectZone() { fReflect(fZone); }
        void modifyZone() { fZone = fModify(); }
    #endif
        
        void setReflectZoneFun(ReflectFunction reflect) { fReflect = reflect; }
        void setModifyZoneFun(ModifyFunction modify) { fModify = modify; }
        
    };
    
    typedef std::vector<ExtZoneParam*> controlMap;
  
    std::string fName;
    std::string fFileName;
    std::string fJSON;
    std::string fVersion;
    std::string fCompileOptions;
    
    std::map<std::string, std::string> fMetadata;
    std::vector<itemInfo> fUiItems;
    
    std::vector<std::string> fLibraryList;
    std::vector<std::string> fIncludePathnames;
    
    int fNumInputs, fNumOutputs, fSRIndex;
    int fDSPSize;
    bool fDSPProxy;
    
    controlMap fPathInputTable;     // [path, ZoneParam]
    controlMap fPathOutputTable;    // [path, ZoneParam]
    
    bool startWith(const std::string& str, const std::string& prefix)
    {
        return (str.substr(0, prefix.size()) == prefix);
    }

    bool isInput(const std::string& type)
    {
        return (type == "vslider" || type == "hslider" || type == "nentry" || type == "button" || type == "checkbox");
    }
    bool isOutput(const std::string& type) { return (type == "hbargraph" || type == "vbargraph"); }
    bool isSoundfile(const std::string& type) { return (type == "soundfile"); }
    
    std::string getString(std::map<std::string, std::pair<std::string, double> >& map, const std::string& key)
    {
        return (map.find(key) != map.end()) ? map[key].first : "";
    }
    
    int getInt(std::map<std::string, std::pair<std::string, double> >& map, const std::string& key)
    {
        return (map.find(key) != map.end()) ? int(map[key].second) : -1;
    }
    
    void setReflectZoneFun(int index, ReflectFunction fun)
    {
        fPathInputTable[index]->setReflectZoneFun(fun);
    }
    
    void setModifyZoneFun(int index, ModifyFunction fun)
    {
        fPathOutputTable[index]->setModifyZoneFun(fun);
    }

    JSONUIDecoderReal(const std::string& json)
    {
        fJSON = json;
        const char* p = fJSON.c_str();
        std::map<std::string, std::pair<std::string, double> > meta_data1;
        std::map<std::string, std::vector<std::string> > meta_data2;
        parseJson(p, meta_data1, fMetadata, meta_data2, fUiItems);
        
        // meta_data1 contains <name : val>, <inputs : val>, <ouputs : val> pairs etc...
        fName = getString(meta_data1, "name");
        fFileName = getString(meta_data1, "filename");
        fVersion = getString(meta_data1, "version");
        fCompileOptions = getString(meta_data1, "compile_options");
        
        if (meta_data2.find("library_list") != meta_data2.end()) {
            fLibraryList = meta_data2["library_list"];
        } else {
            // 'library_list' is coded as successive 'library_pathN' metadata
            for (const auto& it : fMetadata) {
                if (startWith(it.first, "library_path")) {
                    fLibraryList.push_back(it.second);
                }
            }
        }
        if (meta_data2.find("include_pathnames") != meta_data2.end()) {
            fIncludePathnames = meta_data2["include_pathnames"];
        }
        
        fDSPSize = getInt(meta_data1, "size");
        fNumInputs = getInt(meta_data1, "inputs");
        fNumOutputs = getInt(meta_data1, "outputs");
        fSRIndex = getInt(meta_data1, "sr_index");
        fDSPProxy = false;
        
        // Prepare the fPathTable and init zone
        for (const auto& it : fUiItems) {
            std::string type = it.type;
            // Meta data declaration for input items
            if (isInput(type)) {
                ZoneParam* param = new ZoneParam();
                fPathInputTable.push_back(param);
                param->fZone = it.init;
            }
            // Meta data declaration for output items
            else if (isOutput(type)) {
                ZoneParam* param = new ZoneParam();
                fPathOutputTable.push_back(param);
                param->fZone = REAL(0);
            }
        }
    }
    
    virtual ~JSONUIDecoderReal()
    {
        for (const auto& it : fPathInputTable) {
            delete it;
        }
        for (const auto& it : fPathOutputTable) {
            delete it;
        }
    }
    
    void metadata(Meta* m)
    {
        for (const auto& it : fMetadata) {
            m->declare(it.first.c_str(), it.second.c_str());
        }
    }
    
    void metadata(MetaGlue* m)
    {
        for (const auto& it : fMetadata) {
            m->declare(m->metaInterface, it.first.c_str(), it.second.c_str());
        }
    }
    
    void resetUserInterface()
    {
        int item = 0;
        for (const auto& it : fUiItems) {
            if (isInput(it.type)) {
                static_cast<ZoneParam*>(fPathInputTable[item++])->fZone = it.init;
            }
        }
    }
    
    void resetUserInterface(char* memory_block, Soundfile* defaultsound = nullptr)
    {
        for (const auto& it : fUiItems) {
            int index = it.index;
            if (isInput(it.type)) {
                *REAL_ADR(index) = it.init;
            } else if (isSoundfile(it.type)) {
                if (*SOUNDFILE_ADR(index) == nullptr) {
                    *SOUNDFILE_ADR(index) = defaultsound;
                }
            }
        }
    }
    
    int getSampleRate(char* memory_block)
    {
        return *reinterpret_cast<int*>(&memory_block[fSRIndex]);
    }
    
    void setupDSPProxy(UI* ui_interface, char* memory_block)
    {
        if (!fDSPProxy) {
            fDSPProxy = true;
            int countIn = 0;
            int countOut = 0;
            for (const auto& it : fUiItems) {
                std::string type = it.type;
                int index = it.index;
                if (isInput(type)) {
                    fPathInputTable[countIn++]->setReflectZoneFun([=](FAUSTFLOAT value) { *REAL_ADR(index) = REAL(value); });
                } else if (isOutput(type)) {
                    fPathOutputTable[countOut++]->setModifyZoneFun([=]() { return FAUSTFLOAT(*REAL_ADR(index)); });
                }
            }
        }
        
        // Setup soundfile in any case
        for (const auto& it : fUiItems) {
            if (isSoundfile(it.type)) {
                ui_interface->addSoundfile(it.label.c_str(), it.url.c_str(), SOUNDFILE_ADR(it.index));
            }
        }
    }
    
    bool hasDSPProxy() { return fDSPProxy; }
  
    void buildUserInterface(UI* ui_interface)
    {
        // MANDATORY: to be sure floats or double are correctly parsed
        char* tmp_local = setlocale(LC_ALL, nullptr);
        if (tmp_local != NULL) {
            tmp_local = STRDUP(tmp_local);
        }
        setlocale(LC_ALL, "C");
        
        int countIn = 0;
        int countOut = 0;
        int countSound = 0;
        
        for (const auto& it : fUiItems) {
            
            std::string type = it.type;
            REAL init = REAL(it.init);
            REAL min = REAL(it.fmin);
            REAL max = REAL(it.fmax);
            REAL step = REAL(it.step);
            
            // Meta data declaration for input items
            if (isInput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    ui_interface->declare(&static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone, it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for output items
            else if (isOutput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    ui_interface->declare(&static_cast<ZoneParam*>(fPathOutputTable[countOut])->fZone, it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for group opening or closing
            else {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    ui_interface->declare(0, it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            
            if (type == "hgroup") {
                ui_interface->openHorizontalBox(it.label.c_str());
            } else if (type == "vgroup") {
                ui_interface->openVerticalBox(it.label.c_str());
            } else if (type == "tgroup") {
                ui_interface->openTabBox(it.label.c_str());
            } else if (type == "vslider") {
                ui_interface->addVerticalSlider(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone, init, min, max, step);
            } else if (type == "hslider") {
                ui_interface->addHorizontalSlider(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone, init, min, max, step);
            } else if (type == "checkbox") {
                ui_interface->addCheckButton(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone);
            } else if (type == "soundfile") {
                // Nothing
            } else if (type == "hbargraph") {
                ui_interface->addHorizontalBargraph(it.label.c_str(), &static_cast<ZoneParam*>(fPathOutputTable[countOut])->fZone, min, max);
            } else if (type == "vbargraph") {
                ui_interface->addVerticalBargraph(it.label.c_str(), &static_cast<ZoneParam*>(fPathOutputTable[countOut])->fZone, min, max);
            } else if (type == "nentry") {
                ui_interface->addNumEntry(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone, init, min, max, step);
            } else if (type == "button") {
                ui_interface->addButton(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone);
            } else if (type == "close") {
                ui_interface->closeBox();
            }
            
            if (isInput(type)) {
                countIn++;
            } else if (isOutput(type)) {
                countOut++;
            } else if (isSoundfile(type)) {
                countSound++;
            }
        }
        
        if (tmp_local != NULL) {
            setlocale(LC_ALL, tmp_local);
            free(tmp_local);
        }
    }
    
    void buildUserInterface(UI* ui_interface, char* memory_block)
    {
        // MANDATORY: to be sure floats or double are correctly parsed
        char* tmp_local = setlocale(LC_ALL, nullptr);
        if (tmp_local != NULL) {
            tmp_local = STRDUP(tmp_local);
        }
        setlocale(LC_ALL, "C");
        
        for (const auto& it : fUiItems) {
            
            std::string type = it.type;
            int index = it.index;
            REAL init = REAL(it.init);
            REAL min = REAL(it.fmin);
            REAL max = REAL(it.fmax);
            REAL step = REAL(it.step);
            
            // Meta data declaration for input items
            if (isInput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    REAL_UI(ui_interface)->declare(REAL_ADR(index), it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for output items
            else if (isOutput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    REAL_UI(ui_interface)->declare(REAL_ADR(index), it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for group opening or closing
            else {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    REAL_UI(ui_interface)->declare(0, it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            
            if (type == "hgroup") {
                REAL_UI(ui_interface)->openHorizontalBox(it.label.c_str());
            } else if (type == "vgroup") {
                REAL_UI(ui_interface)->openVerticalBox(it.label.c_str());
            } else if (type == "tgroup") {
                REAL_UI(ui_interface)->openTabBox(it.label.c_str());
            } else if (type == "vslider") {
                REAL_UI(ui_interface)->addVerticalSlider(it.label.c_str(), REAL_ADR(index), init, min, max, step);
            } else if (type == "hslider") {
                REAL_UI(ui_interface)->addHorizontalSlider(it.label.c_str(), REAL_ADR(index), init, min, max, step);
            } else if (type == "checkbox") {
                REAL_UI(ui_interface)->addCheckButton(it.label.c_str(), REAL_ADR(index));
            } else if (type == "soundfile") {
                REAL_UI(ui_interface)->addSoundfile(it.label.c_str(), it.url.c_str(), SOUNDFILE_ADR(index));
            } else if (type == "hbargraph") {
                REAL_UI(ui_interface)->addHorizontalBargraph(it.label.c_str(), REAL_ADR(index), min, max);
            } else if (type == "vbargraph") {
                REAL_UI(ui_interface)->addVerticalBargraph(it.label.c_str(), REAL_ADR(index), min, max);
            } else if (type == "nentry") {
                REAL_UI(ui_interface)->addNumEntry(it.label.c_str(), REAL_ADR(index), init, min, max, step);
            } else if (type == "button") {
                REAL_UI(ui_interface)->addButton(it.label.c_str(), REAL_ADR(index));
            } else if (type == "close") {
                REAL_UI(ui_interface)->closeBox();
            }
        }
        
        if (tmp_local != NULL) {
            setlocale(LC_ALL, tmp_local);
            free(tmp_local);
        }
    }
    
    void buildUserInterface(UIGlue* ui_interface, char* memory_block)
    {
        // MANDATORY: to be sure floats or double are correctly parsed
        char* tmp_local = setlocale(LC_ALL, nullptr);
        if (tmp_local != NULL) {
            tmp_local = STRDUP(tmp_local);
        }
        setlocale(LC_ALL, "C");
        
        for (const auto& it : fUiItems) {
            
            std::string type = it.type;
            int index = it.index;
            REAL init = REAL(it.init);
            REAL min = REAL(it.fmin);
            REAL max = REAL(it.fmax);
            REAL step = REAL(it.step);
            
            // Meta data declaration for input items
            if (isInput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    ui_interface->declare(ui_interface->uiInterface, REAL_EXT_ADR(index), it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for output items
            else if (isOutput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    ui_interface->declare(ui_interface->uiInterface, REAL_EXT_ADR(index), it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for group opening or closing
            else {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    ui_interface->declare(ui_interface->uiInterface, 0, it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            
            if (type == "hgroup") {
                ui_interface->openHorizontalBox(ui_interface->uiInterface, it.label.c_str());
            } else if (type == "vgroup") {
                ui_interface->openVerticalBox(ui_interface->uiInterface, it.label.c_str());
            } else if (type == "tgroup") {
                ui_interface->openTabBox(ui_interface->uiInterface, it.label.c_str());
            } else if (type == "vslider") {
                ui_interface->addVerticalSlider(ui_interface->uiInterface, it.label.c_str(), REAL_EXT_ADR(index), init, min, max, step);
            } else if (type == "hslider") {
                ui_interface->addHorizontalSlider(ui_interface->uiInterface, it.label.c_str(), REAL_EXT_ADR(index), init, min, max, step);
            } else if (type == "checkbox") {
                ui_interface->addCheckButton(ui_interface->uiInterface, it.label.c_str(), REAL_EXT_ADR(index));
            } else if (type == "soundfile") {
                ui_interface->addSoundfile(ui_interface->uiInterface, it.label.c_str(), it.url.c_str(), SOUNDFILE_ADR(index));
            } else if (type == "hbargraph") {
                ui_interface->addHorizontalBargraph(ui_interface->uiInterface, it.label.c_str(), REAL_EXT_ADR(index), min, max);
            } else if (type == "vbargraph") {
                ui_interface->addVerticalBargraph(ui_interface->uiInterface, it.label.c_str(), REAL_EXT_ADR(index), min, max);
            } else if (type == "nentry") {
                ui_interface->addNumEntry(ui_interface->uiInterface, it.label.c_str(), REAL_EXT_ADR(index), init, min, max, step);
            } else if (type == "button") {
                ui_interface->addButton(ui_interface->uiInterface, it.label.c_str(), REAL_EXT_ADR(index));
            } else if (type == "close") {
                ui_interface->closeBox(ui_interface->uiInterface);
            }
        }
        
        if (tmp_local != NULL) {
            setlocale(LC_ALL, tmp_local);
            free(tmp_local);
        }
    }
    
    bool hasCompileOption(const std::string& option)
    {
        std::istringstream iss(fCompileOptions);
        std::string token;
        while (std::getline(iss, token, ' ')) {
            if (token == option) return true;
        }
        return false;
    }
    
    int getDSPSize() { return fDSPSize; }
    std::string getName() { return fName; }
    std::string getLibVersion() { return fVersion; }
    std::string getCompileOptions() { return fCompileOptions; }
    std::vector<std::string> getLibraryList() { return fLibraryList; }
    std::vector<std::string> getIncludePathnames() { return fIncludePathnames; }
    int getNumInputs() { return fNumInputs; }
    int getNumOutputs() { return fNumOutputs; }
    
    std::vector<ExtZoneParam*>& getInputControls()
    {
        return fPathInputTable;
    }
    std::vector<ExtZoneParam*>& getOutputControls()
    {
        return fPathOutputTable;
    }
    
};

// FAUSTFLOAT templated decoder

struct FAUST_API JSONUIDecoder : public JSONUIDecoderReal<FAUSTFLOAT>
{
    JSONUIDecoder(const std::string& json):JSONUIDecoderReal<FAUSTFLOAT>(json)
    {}
};

// Generic factory

static JSONUIDecoderBase* createJSONUIDecoder(const std::string& json)
{
    JSONUIDecoder decoder(json);
    if (decoder.hasCompileOption("-double")) {
        return new JSONUIDecoderReal<double>(json);
    } else {
        return new JSONUIDecoderReal<float>(json);
    }
}

#endif
/**************************  END  JSONUIDecoder.h **************************/
/************************** BEGIN JSONUI.h *****************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef FAUST_JSONUI_H
#define FAUST_JSONUI_H

#include <vector>
#include <map>
#include <string>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <limits>

/************************** BEGIN PathBuilder.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __PathBuilder__
#define __PathBuilder__

#include <vector>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <regex>


/*******************************************************************************
 * PathBuilder : Faust User Interface
 * Helper class to build complete hierarchical path for UI items.
 ******************************************************************************/

class FAUST_API PathBuilder {

    protected:
    
        std::vector<std::string> fControlsLevel;
        std::vector<std::string> fFullPaths;
        std::map<std::string, std::string> fFull2Short;  // filled by computeShortNames()
    
        /**
         * @brief check if a character is acceptable for an ID
         *
         * @param c
         * @return true is the character is acceptable for an ID
         */
        bool isIDChar(char c) const
        {
            return ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) || ((c >= '0') && (c <= '9'));
        }
    
        /**
         * @brief remove all "/0x00" parts
         *
         * @param src
         * @return modified string
         */
        std::string remove0x00(const std::string& src) const
        {
            return std::regex_replace(src, std::regex("/0x00"), "");
        }
    
        /**
         * @brief replace all non ID char with '_' (one '_' may replace several non ID char)
         *
         * @param src
         * @return modified string
         */
        std::string str2ID(const std::string& src) const
        {
            std::string dst;
            bool need_underscore = false;
            for (char c : src) {
                if (isIDChar(c) || (c == '/')) {
                    if (need_underscore) {
                        dst.push_back('_');
                        need_underscore = false;
                    }
                    dst.push_back(c);
                } else {
                    need_underscore = true;
                }
            }
            return dst;
        }
    
        /**
         * @brief Keep only the last n slash-parts
         *
         * @param src
         * @param n : 1 indicates the last slash-part
         * @return modified string
         */
        std::string cut(const std::string& src, int n) const
        {
            std::string rdst;
            for (int i = int(src.length())-1; i >= 0; i--) {
                char c = src[i];
                if (c != '/') {
                    rdst.push_back(c);
                } else if (n == 1) {
                    std::string dst;
                    for (int j = int(rdst.length())-1; j >= 0; j--) {
                        dst.push_back(rdst[j]);
                    }
                    return dst;
                } else {
                    n--;
                    rdst.push_back(c);
                }
            }
            return src;
        }
    
        void addFullPath(const std::string& label) { fFullPaths.push_back(buildPath(label)); }
    
        /**
         * @brief Compute the mapping between full path and short names
         */
        void computeShortNames()
        {
            std::vector<std::string>           uniquePaths;  // all full paths transformed but made unique with a prefix
            std::map<std::string, std::string> unique2full;  // all full paths transformed but made unique with a prefix
            char num_buffer[16];
            int pnum = 0;
            
            for (const auto& s : fFullPaths) {
                // Using snprintf since Teensy does not have the std::to_string function
                snprintf(num_buffer, 16, "%d", pnum++);
                std::string u = "/P" + std::string(num_buffer) + str2ID(remove0x00(s));
                uniquePaths.push_back(u);
                unique2full[u] = s;  // remember the full path associated to a unique path
            }
        
            std::map<std::string, int> uniquePath2level;                // map path to level
            for (const auto& s : uniquePaths) uniquePath2level[s] = 1;   // we init all levels to 1
            bool have_collisions = true;
        
            while (have_collisions) {
                // compute collision list
                std::set<std::string>              collisionSet;
                std::map<std::string, std::string> short2full;
                have_collisions = false;
                for (const auto& it : uniquePath2level) {
                    std::string u = it.first;
                    int n = it.second;
                    std::string shortName = cut(u, n);
                    auto p = short2full.find(shortName);
                    if (p == short2full.end()) {
                        // no collision
                        short2full[shortName] = u;
                    } else {
                        // we have a collision, add the two paths to the collision set
                        have_collisions = true;
                        collisionSet.insert(u);
                        collisionSet.insert(p->second);
                    }
                }
                for (const auto& s : collisionSet) uniquePath2level[s]++;  // increase level of colliding path
            }
        
            for (const auto& it : uniquePath2level) {
                std::string u = it.first;
                int n = it.second;
                std::string shortName = replaceCharList(cut(u, n), {'/'}, '_');
                fFull2Short[unique2full[u]] = shortName;
            }
        }
    
        std::string replaceCharList(const std::string& str, const std::vector<char>& ch1, char ch2)
        {
            auto beg = ch1.begin();
            auto end = ch1.end();
            std::string res = str;
            for (size_t i = 0; i < str.length(); ++i) {
                if (std::find(beg, end, str[i]) != end) res[i] = ch2;
            }
            return res;
        }
     
    public:
    
        PathBuilder() {}
        virtual ~PathBuilder() {}
    
        // Return true for the first level of groups
        bool pushLabel(const std::string& label) { fControlsLevel.push_back(label); return fControlsLevel.size() == 1;}
    
        // Return true for the last level of groups
        bool popLabel() { fControlsLevel.pop_back(); return fControlsLevel.size() == 0; }
    
        // Return a complete path built from a label
        std::string buildPath(const std::string& label)
        {
            std::string res = "/";
            for (size_t i = 0; i < fControlsLevel.size(); i++) {
                res = res + fControlsLevel[i] + "/";
            }
            res += label;
            return replaceCharList(res, {' ', '#', '*', ',', '?', '[', ']', '{', '}', '(', ')'}, '_');
        }
    
        // Assuming shortnames have been built, return the shortname from a label
        std::string buildShortname(const std::string& label)
        {
            return (hasShortname()) ? fFull2Short[buildPath(label)] : "";
        }
    
        bool hasShortname() { return fFull2Short.size() > 0; }
    
};

#endif  // __PathBuilder__
/**************************  END  PathBuilder.h **************************/

/*******************************************************************************
 * JSONUI : Faust User Interface
 * This class produce a complete JSON decription of the DSP instance.
 *
 * Since 'shortname' can only be computed when all paths have been created,
 * the fAllUI vector is progressively filled with partially built UI items,
 * which are finally created in the JSON(...) method.
 ******************************************************************************/

// Instruction complexity statistics
struct InstComplexity {
    
    int fLoad = 0;
    int fStore = 0;
    int fBinop = 0;
    int fMathop = 0;
    int fNumbers = 0;
    int fDeclare = 0;
    int fCast = 0;
    int fSelect = 0;
    int fLoop = 0;
    
    std::map<std::string, int> fFunctionSymbolTable;
    std::map<std::string, int> fBinopSymbolTable;
   
    InstComplexity operator+(const InstComplexity& icomp)
    {
        fLoad += icomp.fLoad;
        fStore += icomp.fStore;
        fBinop += icomp.fBinop;
        fMathop += icomp.fMathop;
        fNumbers += icomp.fNumbers;
        fDeclare += icomp.fDeclare;
        fCast += icomp.fCast;
        fSelect += icomp.fSelect;
        fLoop += icomp.fLoop;
        return *this;
    }
};

// DSP or field name, type, size, size-in-bytes, reads, writes
typedef std::tuple<std::string, std::string, int, int, int, int> MemoryLayoutItem;
typedef std::vector<MemoryLayoutItem> MemoryLayoutType;
typedef std::map<std::string, int> PathTableType;

/*
    Build a JSON description of the DSP.
 */
template <typename REAL>
class FAUST_API JSONUIReal : public PathBuilder, public Meta, public UIReal<REAL> {

    protected:
    
        std::stringstream fUI;
        std::vector<std::string> fAllUI;
        std::stringstream fMeta;
        std::vector<std::pair <std::string, std::string> > fMetaAux;
        std::string fVersion;           // Compiler version
        std::string fCompileOptions;    // Compilation options
        std::vector<std::string> fLibraryList;
        std::vector<std::string> fIncludePathnames;
        std::string fName;
        std::string fFileName;
        std::string fExpandedCode;
        std::string fSHAKey;
        std::string fJSON;
        int fDSPSize;                   // In bytes
        PathTableType fPathTable;
        MemoryLayoutType fMemoryLayout;
        InstComplexity fIComp;
        bool fExtended;
    
        char fCloseUIPar;
        char fCloseMetaPar;
        int fTab;
    
        int fInputs, fOutputs, fSRIndex;
         
        void tab(int n, std::ostream& fout)
        {
            fout << '\n';
            while (n-- > 0) {
                fout << '\t';
            }
        }
    
        std::string flatten(const std::string& src)
        {
            std::string dst;
            for (size_t i = 0; i < src.size(); i++) {
                switch (src[i]) {
                    case '\n':
                    case '\t':
                        break;
                    default:
                        dst += src[i];
                        break;
                }
            }
            return dst;
        }
    
        void addMeta(int tab_val, bool quote = true)
        {
            if (fMetaAux.size() > 0) {
                tab(tab_val, fUI); fUI << "\"meta\": [";
                std::string sep = "";
                for (size_t i = 0; i < fMetaAux.size(); i++) {
                    fUI << sep;
                    tab(tab_val + 1, fUI); fUI << "{ \"" << fMetaAux[i].first << "\": \"" << fMetaAux[i].second << "\" }";
                    sep = ",";
                }
                tab(tab_val, fUI); fUI << ((quote) ? "],": "]");
                fMetaAux.clear();
            }
        }
    
        int getAddressIndex(const std::string& path)
        {
            return (fPathTable.find(path) != fPathTable.end()) ? fPathTable[path] : -1;
        }
      
     public:
     
        JSONUIReal(const std::string& name,
                  const std::string& filename,
                  int inputs,
                  int outputs,
                  int sr_index,
                  const std::string& sha_key,
                  const std::string& dsp_code,
                  const std::string& version,
                  const std::string& compile_options,
                  const std::vector<std::string>& library_list,
                  const std::vector<std::string>& include_pathnames,
                  int size,
                  const PathTableType& path_table,
                  MemoryLayoutType memory_layout,
                  InstComplexity inst_comp)
        {
            init(name, filename, inputs, outputs, sr_index, sha_key, dsp_code, version, compile_options, library_list, include_pathnames, size, path_table, memory_layout, inst_comp);
        }

        JSONUIReal(const std::string& name, const std::string& filename, int inputs, int outputs)
        {
            init(name, filename, inputs, outputs, -1, "", "", "", "", std::vector<std::string>(), std::vector<std::string>(), -1, PathTableType(), MemoryLayoutType(), InstComplexity());
        }

        JSONUIReal(int inputs, int outputs)
        {
            init("", "", inputs, outputs, -1, "", "","", "", std::vector<std::string>(), std::vector<std::string>(), -1, PathTableType(), MemoryLayoutType(), InstComplexity());
        }
        
        JSONUIReal()
        {
            init("", "", -1, -1, -1, "", "", "", "", std::vector<std::string>(), std::vector<std::string>(), -1, PathTableType(), MemoryLayoutType(), InstComplexity());
        }
 
        virtual ~JSONUIReal() {}
        
        void setInputs(int inputs) { fInputs = inputs; }
        void setOutputs(int outputs) { fOutputs = outputs; }
    
        void setSRIndex(int sr_index) { fSRIndex = sr_index; }
    
        // Init may be called multiple times so fMeta and fUI are reinitialized
        void init(const std::string& name,
                  const std::string& filename,
                  int inputs,
                  int outputs,
                  int sr_index,
                  const std::string& sha_key,
                  const std::string& dsp_code,
                  const std::string& version,
                  const std::string& compile_options,
                  const std::vector<std::string>& library_list,
                  const std::vector<std::string>& include_pathnames,
                  int size,
                  const PathTableType& path_table,
                  MemoryLayoutType memory_layout,
                  InstComplexity inst_comp,
                  bool extended = false)
        {
            fTab = 1;
            fExtended = extended;
            if (fExtended) {
                fUI << std::setprecision(std::numeric_limits<REAL>::max_digits10);
                fMeta << std::setprecision(std::numeric_limits<REAL>::max_digits10);
            }
        
            fIComp = inst_comp;
            
            // Start Meta generation
            fMeta.str("");
            tab(fTab, fMeta); fMeta << "\"meta\": [";
            fCloseMetaPar = ' ';
            
            // Start UI generation
            fUI.str("");
            tab(fTab, fUI); fUI << "\"ui\": [";
            fCloseUIPar = ' ';
            fTab += 1;
            
            fName = name;
            fFileName = filename;
            fInputs = inputs;
            fOutputs = outputs;
            fSRIndex = sr_index;
            fExpandedCode = dsp_code;
            fSHAKey = sha_key;
            fDSPSize = size;
            fPathTable = path_table;
            fVersion = version;
            fCompileOptions = compile_options;
            fLibraryList = library_list;
            fIncludePathnames = include_pathnames;
            fMemoryLayout = memory_layout;
        }
   
        // -- widget's layouts
    
        virtual void openGenericBox(const char* label, const char* name)
        {
            pushLabel(label);
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << name << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\",";
            addMeta(fTab);
            tab(fTab, fUI); fUI << "\"items\": [";
            fCloseUIPar = ' ';
            fTab += 1;
        }

        virtual void openTabBox(const char* label)
        {
            openGenericBox(label, "tgroup");
        }
    
        virtual void openHorizontalBox(const char* label)
        {
            openGenericBox(label, "hgroup");
        }
    
        virtual void openVerticalBox(const char* label)
        {
            openGenericBox(label, "vgroup");
        }
    
        virtual void closeBox()
        {
            if (popLabel()) {
                // Shortnames can be computed when all fullnames are known
                computeShortNames();
            }
            fTab -= 1;
            tab(fTab, fUI); fUI << "]";
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }
    
        // -- active widgets
  
        virtual void addGenericButton(const char* label, const char* name)
        {
            std::string path = buildPath(label);
            fFullPaths.push_back(path);
            
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << name << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\",";
        
            // Generate 'shortname' entry
            tab(fTab, fUI); fUI << "\"shortname\": \"";
        
            // Add fUI section
            fAllUI.push_back(fUI.str());
            fUI.str("");
        
            if (fPathTable.size() > 0) {
                tab(fTab, fUI); fUI << "\"address\": \"" << path << "\",";
                tab(fTab, fUI); fUI << "\"index\": " << getAddressIndex(path) << ((fMetaAux.size() > 0) ? "," : "");
            } else {
                tab(fTab, fUI); fUI << "\"address\": \"" << path << "\"" << ((fMetaAux.size() > 0) ? "," : "");
            }
            addMeta(fTab, false);
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }

        virtual void addButton(const char* label, REAL* zone)
        {
            addGenericButton(label, "button");
        }
    
        virtual void addCheckButton(const char* label, REAL* zone)
        {
            addGenericButton(label, "checkbox");
        }

        virtual void addGenericRange(const char* label, const char* name, REAL init, REAL min, REAL max, REAL step)
        {
            std::string path = buildPath(label);
            fFullPaths.push_back(path);
            
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << name << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\",";
         
            // Generate 'shortname' entry
            tab(fTab, fUI); fUI << "\"shortname\": \"";
        
            // Add fUI section
            fAllUI.push_back(fUI.str());
            fUI.str("");
        
            tab(fTab, fUI); fUI << "\"address\": \"" << path << "\",";
            if (fPathTable.size() > 0) {
                tab(fTab, fUI); fUI << "\"index\": " << getAddressIndex(path) << ",";
            }
            addMeta(fTab);
            tab(fTab, fUI); fUI << "\"init\": " << init << ",";
            tab(fTab, fUI); fUI << "\"min\": " << min << ",";
            tab(fTab, fUI); fUI << "\"max\": " << max << ",";
            tab(fTab, fUI); fUI << "\"step\": " << step;
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }
    
        virtual void addVerticalSlider(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step)
        {
            addGenericRange(label, "vslider", init, min, max, step);
        }
    
        virtual void addHorizontalSlider(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step)
        {
            addGenericRange(label, "hslider", init, min, max, step);
        }
    
        virtual void addNumEntry(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step)
        {
            addGenericRange(label, "nentry", init, min, max, step);
        }

        // -- passive widgets
    
        virtual void addGenericBargraph(const char* label, const char* name, REAL min, REAL max) 
        {
            std::string path = buildPath(label);
            fFullPaths.push_back(path);
            
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << name << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\",";
         
            // Generate 'shortname' entry
            tab(fTab, fUI); fUI << "\"shortname\": \"";
        
            // Add fUI section
            fAllUI.push_back(fUI.str());
            fUI.str("");
            
            tab(fTab, fUI); fUI << "\"address\": \"" << path << "\",";
            if (fPathTable.size() > 0) {
                tab(fTab, fUI); fUI << "\"index\": " << getAddressIndex(path) << ",";
            }
            addMeta(fTab);
            tab(fTab, fUI); fUI << "\"min\": " << min << ",";
            tab(fTab, fUI); fUI << "\"max\": " << max;
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }

        virtual void addHorizontalBargraph(const char* label, REAL* zone, REAL min, REAL max) 
        {
            addGenericBargraph(label, "hbargraph", min, max);
        }
    
        virtual void addVerticalBargraph(const char* label, REAL* zone, REAL min, REAL max)
        {
            addGenericBargraph(label, "vbargraph", min, max);
        }
    
        virtual void addSoundfile(const char* label, const char* url, Soundfile** zone)
        {
            std::string path = buildPath(label);
            
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << "soundfile" << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\"" << ",";
            tab(fTab, fUI); fUI << "\"url\": \"" << url << "\"" << ",";
            tab(fTab, fUI); fUI << "\"address\": \"" << path << "\"" << ((fPathTable.size() > 0) ? "," : "");
            if (fPathTable.size() > 0) {
                tab(fTab, fUI); fUI << "\"index\": " << getAddressIndex(path);
            }
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }

        // -- metadata declarations

        virtual void declare(REAL* zone, const char* key, const char* val)
        {
            fMetaAux.push_back(std::make_pair(key, val));
        }
    
        // Meta interface
        virtual void declare(const char* key, const char* value)
        {
            fMeta << fCloseMetaPar;
            // fName found in metadata
            if ((strcmp(key, "name") == 0) && (fName == "")) fName = value;
            // fFileName found in metadata
            if ((strcmp(key, "filename") == 0) && (fFileName == "")) fFileName = value;
            tab(fTab, fMeta); fMeta << "{ " << "\"" << key << "\"" << ": " << "\"" << value << "\" }";
            fCloseMetaPar = ',';
        }
    
        std::string JSON(bool flat = false)
        {
            if (fJSON.empty()) {
                fTab = 0;
                std::stringstream JSON;
                if (fExtended) {
                    JSON << std::setprecision(std::numeric_limits<REAL>::max_digits10);
                }
                JSON << "{";
                fTab += 1;
                tab(fTab, JSON); JSON << "\"name\": \"" << fName << "\",";
                tab(fTab, JSON); JSON << "\"filename\": \"" << fFileName << "\",";
                if (fVersion != "") { tab(fTab, JSON); JSON << "\"version\": \"" << fVersion << "\","; }
                if (fCompileOptions != "") { tab(fTab, JSON); JSON << "\"compile_options\": \"" <<  fCompileOptions << "\","; }
                if (fLibraryList.size() > 0) {
                    tab(fTab, JSON);
                    JSON << "\"library_list\": [";
                    for (size_t i = 0; i < fLibraryList.size(); i++) {
                        JSON << "\"" << fLibraryList[i] << "\"";
                        if (i < (fLibraryList.size() - 1)) JSON << ",";
                    }
                    JSON << "],";
                }
                if (fIncludePathnames.size() > 0) {
                    tab(fTab, JSON);
                    JSON << "\"include_pathnames\": [";
                    for (size_t i = 0; i < fIncludePathnames.size(); i++) {
                        JSON << "\"" << fIncludePathnames[i] << "\"";
                        if (i < (fIncludePathnames.size() - 1)) JSON << ",";
                    }
                    JSON << "],";
                }
                if (fDSPSize != -1) { tab(fTab, JSON); JSON << "\"size\": " << fDSPSize << ","; }
                if (fMemoryLayout.size() > 0) {
                    tab(fTab, JSON);
                    JSON << "\"memory_layout\": [";
                    for (size_t i = 0; i < fMemoryLayout.size(); i++) {
                        // DSP or field name, type, size, size-in-bytes, reads, writes
                        MemoryLayoutItem item = fMemoryLayout[i];
                        tab(fTab + 1, JSON);
                        JSON << "{ \"name\": \"" << std::get<0>(item) << "\", ";
                        JSON << "\"type\": \"" << std::get<1>(item) << "\", ";
                        JSON << "\"size\": " << std::get<2>(item) << ", ";
                        JSON << "\"size_bytes\": " << std::get<3>(item) << ", ";
                        JSON << "\"read\": " << std::get<4>(item) << ", ";
                        JSON << "\"write\": " << std::get<5>(item) << " }";
                        if (i < (fMemoryLayout.size() - 1)) JSON << ",";
                    }
                    tab(fTab, JSON);
                    JSON << "],";
                    
                    // Compute statistics
                    tab(fTab, JSON);
                    JSON << "\"compute_cost\": [{";
                    tab(fTab + 1, JSON);
                    JSON << "\"load\": " << fIComp.fLoad << ", ";
                    tab(fTab + 1, JSON);
                    JSON << "\"store\": " << fIComp.fStore << ", ";
                    tab(fTab + 1, JSON);
                    JSON << "\"declare\": " << fIComp.fDeclare << ", ";
                    tab(fTab + 1, JSON);
                    JSON << "\"number\": " << fIComp.fNumbers << ", ";
                    tab(fTab + 1, JSON);
                    JSON << "\"cast\": " << fIComp.fCast << ", ";
                    tab(fTab + 1, JSON);
                    JSON << "\"select\": " << fIComp.fSelect << ", ";
                    tab(fTab + 1, JSON);
                    JSON << "\"loop\": " << fIComp.fLoop << ", ";
                    tab(fTab + 1, JSON);
                    JSON << "\"binop\": [{ ";
                    JSON << "\"total\": " << fIComp.fBinop;
                    int size1 = (int)fIComp.fBinopSymbolTable.size();
                    if (size1 > 0) {
                        JSON << ", ";
                        for (const auto& it : fIComp.fBinopSymbolTable) {
                            JSON << "\"" << it.first << "\": " << it.second;
                            JSON << ((--size1 == 0) ? " }" : ", ");
                        }
                    } else {
                        JSON << " }";
                    }
                    JSON << "], ";
                    tab(fTab + 1, JSON);
                    JSON << "\"mathop\": [{ ";
                    JSON << "\"total\": " << fIComp.fMathop;
                    int size2 = (int)fIComp.fFunctionSymbolTable.size();
                    if (size2 > 0) {
                        JSON << ", ";
                        for (const auto& it : fIComp.fFunctionSymbolTable) {
                            JSON << "\"" << it.first << "\": " << it.second;
                            JSON << ((--size2 == 0) ? " }" : ", ");
                        }
                    } else {
                        JSON << " }";
                    }
                    JSON << "]";
                    tab(fTab, JSON);
                    JSON << "}],";
                }
                if (fSHAKey != "") { tab(fTab, JSON); JSON << "\"sha_key\": \"" << fSHAKey << "\","; }
                if (fExpandedCode != "") { tab(fTab, JSON); JSON << "\"code\": \"" << fExpandedCode << "\","; }
                tab(fTab, JSON); JSON << "\"inputs\": " << fInputs << ",";
                tab(fTab, JSON); JSON << "\"outputs\": " << fOutputs << ",";
                if (fSRIndex != -1) { tab(fTab, JSON); JSON << "\"sr_index\": " << fSRIndex << ","; }
                tab(fTab, fMeta); fMeta << "],";
              
                // Add last UI section
                fAllUI.push_back(fUI.str());
                // Finalize UI generation
                fUI.str("");
                // Add N-1 sections
                for (size_t i = 0; i < fAllUI.size()-1; i++) {
                    fUI << fAllUI[i] << fFull2Short[fFullPaths[i]] << "\",";
                }
                // And the last one
                fUI << fAllUI[fAllUI.size()-1];
                // Terminates the UI section
                tab(fTab, fUI); fUI << "]";
            
                fTab -= 1;
                if (fCloseMetaPar == ',') { // If "declare" has been called, fCloseMetaPar state is now ','
                    JSON << fMeta.str() << fUI.str();
                } else {
                    JSON << fUI.str();
                }
                
                tab(fTab, JSON); JSON << "}";
                
                // Keep result in fJSON
                fJSON = JSON.str();
            }
            return (flat) ? flatten(fJSON) : fJSON;
        }
    
};

// Externally available class using FAUSTFLOAT

struct FAUST_API JSONUI : public JSONUIReal<FAUSTFLOAT>, public UI {
    
    JSONUI(const std::string& name,
           const std::string& filename,
           int inputs,
           int outputs,
           int sr_index,
           const std::string& sha_key,
           const std::string& dsp_code,
           const std::string& version,
           const std::string& compile_options,
           const std::vector<std::string>& library_list,
           const std::vector<std::string>& include_pathnames,
           int size,
           const PathTableType& path_table,
           MemoryLayoutType memory_layout,
           InstComplexity inst_comp):
    JSONUIReal<FAUSTFLOAT>(name, filename,
                          inputs, outputs,
                          sr_index,
                          sha_key, dsp_code,
                          version, compile_options,
                          library_list, include_pathnames,
                          size, path_table,
                          memory_layout, inst_comp)
    {}
    
    JSONUI(const std::string& name, const std::string& filename, int inputs, int outputs):
    JSONUIReal<FAUSTFLOAT>(name, filename, inputs, outputs)
    {}
    
    JSONUI(int inputs, int outputs):JSONUIReal<FAUSTFLOAT>(inputs, outputs)
    {}
    
    JSONUI():JSONUIReal<FAUSTFLOAT>()
    {}

    virtual void openTabBox(const char* label)
    {
        JSONUIReal<FAUSTFLOAT>::openTabBox(label);
    }
    virtual void openHorizontalBox(const char* label)
    {
        JSONUIReal<FAUSTFLOAT>::openHorizontalBox(label);
    }
    virtual void openVerticalBox(const char* label)
    {
        JSONUIReal<FAUSTFLOAT>::openVerticalBox(label);
    }
    virtual void closeBox()
    {
        JSONUIReal<FAUSTFLOAT>::closeBox();
    }
    
    // -- active widgets
    
    virtual void addButton(const char* label, FAUSTFLOAT* zone)
    {
        JSONUIReal<FAUSTFLOAT>::addButton(label, zone);
    }
    virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)
    {
        JSONUIReal<FAUSTFLOAT>::addCheckButton(label, zone);
    }
    virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
    {
        JSONUIReal<FAUSTFLOAT>::addVerticalSlider(label, zone, init, min, max, step);
    }
    virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
    {
        JSONUIReal<FAUSTFLOAT>::addHorizontalSlider(label, zone, init, min, max, step);
    }
    virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
    {
        JSONUIReal<FAUSTFLOAT>::addNumEntry(label, zone, init, min, max, step);
    }
    
    // -- passive widgets
    
    virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
    {
        JSONUIReal<FAUSTFLOAT>::addHorizontalBargraph(label, zone, min, max);
    }
    virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
    {
        JSONUIReal<FAUSTFLOAT>::addVerticalBargraph(label, zone, min, max);
    }
    
    // -- soundfiles
    
    virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone)
    {
        JSONUIReal<FAUSTFLOAT>::addSoundfile(label, filename, sf_zone);
    }
    
    // -- metadata declarations
    
    virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val)
    {
        JSONUIReal<FAUSTFLOAT>::declare(zone, key, val);
    }

    virtual void declare(const char* key, const char* val)
    {
        JSONUIReal<FAUSTFLOAT>::declare(key, val);
    }

    virtual ~JSONUI() {}
    
};

#endif // FAUST_JSONUI_H
/**************************  END  JSONUI.h **************************/

/**
 * Proxy dsp definition created from the DSP JSON description.
 * This class allows a 'proxy' dsp to control a real dsp
 * possibly running somewhere else.
 */
class proxy_dsp : public dsp {

    protected:
    
        JSONUIDecoder* fDecoder;
        int fSampleRate;
    
        void init(const std::string& json)
        {
            fDecoder = new JSONUIDecoder(json);
            fSampleRate = -1;
        }
        
    public:
    
        proxy_dsp():fDecoder(nullptr), fSampleRate(-1)
        {}
    
        proxy_dsp(const std::string& json)
        {
            init(json);
        }
          
        proxy_dsp(dsp* dsp)
        {
            JSONUI builder(dsp->getNumInputs(), dsp->getNumOutputs());
            dsp->metadata(&builder);
            dsp->buildUserInterface(&builder);
            fSampleRate = dsp->getSampleRate();
            fDecoder = new JSONUIDecoder(builder.JSON());
        }
      
        virtual ~proxy_dsp()
        {
            delete fDecoder;
        }
    
        virtual int getNumInputs() { return fDecoder->fNumInputs; }
        virtual int getNumOutputs() { return fDecoder->fNumOutputs; }
        
        virtual void buildUserInterface(UI* ui) { fDecoder->buildUserInterface(ui); }
        
        // To possibly implement in a concrete proxy dsp 
        virtual void init(int sample_rate)
        {
            instanceInit(sample_rate);
        }
        virtual void instanceInit(int sample_rate)
        {
            instanceConstants(sample_rate);
            instanceResetUserInterface();
            instanceClear();
        }
        virtual void instanceConstants(int sample_rate) { fSampleRate = sample_rate; }
        virtual void instanceResetUserInterface() { fDecoder->resetUserInterface(); }
        virtual void instanceClear() {}
    
        virtual int getSampleRate() { return fSampleRate; }
    
        virtual proxy_dsp* clone() { return new proxy_dsp(fDecoder->fJSON); }
        virtual void metadata(Meta* m) { fDecoder->metadata(m); }
    
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {}
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {} 
        
};

#endif
/************************** END proxy-dsp.h **************************/
/************************** BEGIN timed-dsp.h *****************************
FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
***************************************************************************/

#ifndef __timed_dsp__
#define __timed_dsp__

#include <set>
#include <float.h>
#include <assert.h>

/************************** BEGIN GUI.h **********************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 *************************************************************************/

#ifndef __GUI_H__
#define __GUI_H__

#include <list>
#include <map>
#include <vector>
#include <assert.h>

#ifdef _WIN32
# pragma warning (disable: 4100)
#else
# pragma GCC diagnostic ignored "-Wunused-parameter"
#endif

/************************** BEGIN ValueConverter.h ********************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ********************************************************************/

#ifndef __ValueConverter__
#define __ValueConverter__

/***************************************************************************************
 ValueConverter.h
 (GRAME, Copyright 2015-2019)
 
 Set of conversion objects used to map user interface values (for example a gui slider
 delivering values between 0 and 1) to faust values (for example a vslider between
 20 and 20000) using a log scale.
 
 -- Utilities
 
 Range(lo,hi) : clip a value x between lo and hi
 Interpolator(lo,hi,v1,v2) : Maps a value x between lo and hi to a value y between v1 and v2
 Interpolator3pt(lo,mi,hi,v1,vm,v2) : Map values between lo mid hi to values between v1 vm v2
 
 -- Value Converters
 
 ValueConverter::ui2faust(x)
 ValueConverter::faust2ui(x)
 
 -- ValueConverters used for sliders depending of the scale
 
 LinearValueConverter(umin, umax, fmin, fmax)
 LinearValueConverter2(lo, mi, hi, v1, vm, v2) using 2 segments
 LogValueConverter(umin, umax, fmin, fmax)
 ExpValueConverter(umin, umax, fmin, fmax)
 
 -- ValueConverters used for accelerometers based on 3 points
 
 AccUpConverter(amin, amid, amax, fmin, fmid, fmax)        -- curve 0
 AccDownConverter(amin, amid, amax, fmin, fmid, fmax)      -- curve 1
 AccUpDownConverter(amin, amid, amax, fmin, fmid, fmax)    -- curve 2
 AccDownUpConverter(amin, amid, amax, fmin, fmid, fmax)    -- curve 3
 
 -- lists of ZoneControl are used to implement accelerometers metadata for each axes
 
 ZoneControl(zone, valueConverter) : a zone with an accelerometer data converter
 
 -- ZoneReader are used to implement screencolor metadata
 
 ZoneReader(zone, valueConverter) : a zone with a data converter

****************************************************************************************/

#include <float.h>
#include <algorithm>    // std::max
#include <cmath>
#include <vector>
#include <assert.h>


//--------------------------------------------------------------------------------------
// Interpolator(lo,hi,v1,v2)
// Maps a value x between lo and hi to a value y between v1 and v2
// y = v1 + (x-lo)/(hi-lo)*(v2-v1)
// y = v1 + (x-lo) * coef           with coef = (v2-v1)/(hi-lo)
// y = v1 + x*coef - lo*coef
// y = v1 - lo*coef + x*coef
// y = offset + x*coef              with offset = v1 - lo*coef
//--------------------------------------------------------------------------------------
class FAUST_API Interpolator {
    
    private:

        //--------------------------------------------------------------------------------------
        // Range(lo,hi) clip a value between lo and hi
        //--------------------------------------------------------------------------------------
        struct Range
        {
            double fLo;
            double fHi;

            Range(double x, double y) : fLo(std::min<double>(x,y)), fHi(std::max<double>(x,y)) {}
            double operator()(double x) { return (x<fLo) ? fLo : (x>fHi) ? fHi : x; }
        };

        Range fRange;
        double fCoef;
        double fOffset;

    public:

        Interpolator(double lo, double hi, double v1, double v2) : fRange(lo,hi)
        {
            if (hi != lo) {
                // regular case
                fCoef = (v2-v1)/(hi-lo);
                fOffset = v1 - lo*fCoef;
            } else {
                // degenerate case, avoids division by zero
                fCoef = 0;
                fOffset = (v1+v2)/2;
            }
        }
        double operator()(double v)
        {
            double x = fRange(v);
            return  fOffset + x*fCoef;
        }

        void getLowHigh(double& amin, double& amax)
        {
            amin = fRange.fLo;
            amax = fRange.fHi;
        }
};

//--------------------------------------------------------------------------------------
// Interpolator3pt(lo,mi,hi,v1,vm,v2)
// Map values between lo mid hi to values between v1 vm v2
//--------------------------------------------------------------------------------------
class FAUST_API Interpolator3pt {

    private:

        Interpolator fSegment1;
        Interpolator fSegment2;
        double fMid;

    public:

        Interpolator3pt(double lo, double mi, double hi, double v1, double vm, double v2) :
            fSegment1(lo, mi, v1, vm),
            fSegment2(mi, hi, vm, v2),
            fMid(mi) {}
        double operator()(double x) { return  (x < fMid) ? fSegment1(x) : fSegment2(x); }

        void getMappingValues(double& amin, double& amid, double& amax)
        {
            fSegment1.getLowHigh(amin, amid);
            fSegment2.getLowHigh(amid, amax);
        }
};

//--------------------------------------------------------------------------------------
// Abstract ValueConverter class. Converts values between UI and Faust representations
//--------------------------------------------------------------------------------------
class FAUST_API ValueConverter {

    public:

        virtual ~ValueConverter() {}
        virtual double ui2faust(double x) { return x; };
        virtual double faust2ui(double x) { return x; };
};

//--------------------------------------------------------------------------------------
// A converter than can be updated
//--------------------------------------------------------------------------------------

class FAUST_API UpdatableValueConverter : public ValueConverter {
    
    protected:
        
        bool fActive;
        
    public:
        
        UpdatableValueConverter():fActive(true)
        {}
        virtual ~UpdatableValueConverter()
        {}
        
        virtual void setMappingValues(double amin, double amid, double amax, double min, double init, double max) = 0;
        virtual void getMappingValues(double& amin, double& amid, double& amax) = 0;
        
        void setActive(bool on_off) { fActive = on_off; }
        bool getActive() { return fActive; }
    
};

//--------------------------------------------------------------------------------------
// Linear conversion between ui and Faust values
//--------------------------------------------------------------------------------------
class FAUST_API LinearValueConverter : public ValueConverter {
    
    private:
        
        Interpolator fUI2F;
        Interpolator fF2UI;
        
    public:
        
        LinearValueConverter(double umin, double umax, double fmin, double fmax) :
            fUI2F(umin,umax,fmin,fmax), fF2UI(fmin,fmax,umin,umax)
        {}
        
        LinearValueConverter() : fUI2F(0.,0.,0.,0.), fF2UI(0.,0.,0.,0.)
        {}
        virtual double ui2faust(double x) { return fUI2F(x); }
        virtual double faust2ui(double x) { return fF2UI(x); }
    
};

//--------------------------------------------------------------------------------------
// Two segments linear conversion between ui and Faust values
//--------------------------------------------------------------------------------------
class FAUST_API LinearValueConverter2 : public UpdatableValueConverter {
    
    private:
    
        Interpolator3pt fUI2F;
        Interpolator3pt fF2UI;
        
    public:
    
        LinearValueConverter2(double amin, double amid, double amax, double min, double init, double max) :
            fUI2F(amin, amid, amax, min, init, max), fF2UI(min, init, max, amin, amid, amax)
        {}
        
        LinearValueConverter2() : fUI2F(0.,0.,0.,0.,0.,0.), fF2UI(0.,0.,0.,0.,0.,0.)
        {}
    
        virtual double ui2faust(double x) { return fUI2F(x); }
        virtual double faust2ui(double x) { return fF2UI(x); }
    
        virtual void setMappingValues(double amin, double amid, double amax, double min, double init, double max)
        {
            fUI2F = Interpolator3pt(amin, amid, amax, min, init, max);
            fF2UI = Interpolator3pt(min, init, max, amin, amid, amax);
        }

        virtual void getMappingValues(double& amin, double& amid, double& amax)
        {
            fUI2F.getMappingValues(amin, amid, amax);
        }
    
};

//--------------------------------------------------------------------------------------
// Logarithmic conversion between ui and Faust values
//--------------------------------------------------------------------------------------
class FAUST_API LogValueConverter : public LinearValueConverter {

    public:
    
        // We use DBL_EPSILON which is bigger than DBL_MIN (safer)
        LogValueConverter(double umin, double umax, double fmin, double fmax) :
            LinearValueConverter(umin, umax, std::log(std::max<double>(DBL_EPSILON, fmin)), std::log(std::max<double>(DBL_EPSILON, fmax)))
        {}

        virtual double ui2faust(double x) { return std::exp(LinearValueConverter::ui2faust(x)); }
        virtual double faust2ui(double x) { return LinearValueConverter::faust2ui(std::log(std::max<double>(DBL_EPSILON, x))); }

};

//--------------------------------------------------------------------------------------
// Exponential conversion between ui and Faust values
//--------------------------------------------------------------------------------------
class FAUST_API ExpValueConverter : public LinearValueConverter {

    public:

        ExpValueConverter(double umin, double umax, double fmin, double fmax) :
            LinearValueConverter(umin, umax, std::min<double>(DBL_MAX, std::exp(fmin)), std::min<double>(DBL_MAX, std::exp(fmax)))
        {}

        virtual double ui2faust(double x) { return std::log(LinearValueConverter::ui2faust(x)); }
        virtual double faust2ui(double x) { return LinearValueConverter::faust2ui(std::min<double>(DBL_MAX, std::exp(x))); }

};

//--------------------------------------------------------------------------------------
// Convert accelerometer or gyroscope values to Faust values
// Using an Up curve (curve 0)
//--------------------------------------------------------------------------------------
class FAUST_API AccUpConverter : public UpdatableValueConverter {

    private:

        Interpolator3pt fA2F;
        Interpolator3pt fF2A;

    public:

        AccUpConverter(double amin, double amid, double amax, double fmin, double fmid, double fmax) :
            fA2F(amin,amid,amax,fmin,fmid,fmax),
            fF2A(fmin,fmid,fmax,amin,amid,amax)
        {}

        virtual double ui2faust(double x) { return fA2F(x); }
        virtual double faust2ui(double x) { return fF2A(x); }

        virtual void setMappingValues(double amin, double amid, double amax, double fmin, double fmid, double fmax)
        {
            //__android_log_print(ANDROID_LOG_ERROR, "Faust", "AccUpConverter update %f %f %f %f %f %f", amin,amid,amax,fmin,fmid,fmax);
            fA2F = Interpolator3pt(amin, amid, amax, fmin, fmid, fmax);
            fF2A = Interpolator3pt(fmin, fmid, fmax, amin, amid, amax);
        }

        virtual void getMappingValues(double& amin, double& amid, double& amax)
        {
            fA2F.getMappingValues(amin, amid, amax);
        }

};

//--------------------------------------------------------------------------------------
// Convert accelerometer or gyroscope values to Faust values
// Using a Down curve (curve 1)
//--------------------------------------------------------------------------------------
class FAUST_API AccDownConverter : public UpdatableValueConverter {

    private:

        Interpolator3pt	fA2F;
        Interpolator3pt	fF2A;

    public:

        AccDownConverter(double amin, double amid, double amax, double fmin, double fmid, double fmax) :
            fA2F(amin,amid,amax,fmax,fmid,fmin),
            fF2A(fmin,fmid,fmax,amax,amid,amin)
        {}

        virtual double ui2faust(double x) { return fA2F(x); }
        virtual double faust2ui(double x) { return fF2A(x); }

        virtual void setMappingValues(double amin, double amid, double amax, double fmin, double fmid, double fmax)
        {
             //__android_log_print(ANDROID_LOG_ERROR, "Faust", "AccDownConverter update %f %f %f %f %f %f", amin,amid,amax,fmin,fmid,fmax);
            fA2F = Interpolator3pt(amin, amid, amax, fmax, fmid, fmin);
            fF2A = Interpolator3pt(fmin, fmid, fmax, amax, amid, amin);
        }

        virtual void getMappingValues(double& amin, double& amid, double& amax)
        {
            fA2F.getMappingValues(amin, amid, amax);
        }
};

//--------------------------------------------------------------------------------------
// Convert accelerometer or gyroscope values to Faust values
// Using an Up-Down curve (curve 2)
//--------------------------------------------------------------------------------------
class FAUST_API AccUpDownConverter : public UpdatableValueConverter {

    private:

        Interpolator3pt	fA2F;
        Interpolator fF2A;

    public:

        AccUpDownConverter(double amin, double amid, double amax, double fmin, double fmid, double fmax) :
            fA2F(amin,amid,amax,fmin,fmax,fmin),
            fF2A(fmin,fmax,amin,amax)				// Special, pseudo inverse of a non monotonic function
        {}

        virtual double ui2faust(double x) { return fA2F(x); }
        virtual double faust2ui(double x) { return fF2A(x); }

        virtual void setMappingValues(double amin, double amid, double amax, double fmin, double fmid, double fmax)
        {
            //__android_log_print(ANDROID_LOG_ERROR, "Faust", "AccUpDownConverter update %f %f %f %f %f %f", amin,amid,amax,fmin,fmid,fmax);
            fA2F = Interpolator3pt(amin, amid, amax, fmin, fmax, fmin);
            fF2A = Interpolator(fmin, fmax, amin, amax);
        }

        virtual void getMappingValues(double& amin, double& amid, double& amax)
        {
            fA2F.getMappingValues(amin, amid, amax);
        }
};

//--------------------------------------------------------------------------------------
// Convert accelerometer or gyroscope values to Faust values
// Using a Down-Up curve (curve 3)
//--------------------------------------------------------------------------------------
class FAUST_API AccDownUpConverter : public UpdatableValueConverter {

    private:

        Interpolator3pt	fA2F;
        Interpolator fF2A;

    public:

        AccDownUpConverter(double amin, double amid, double amax, double fmin, double fmid, double fmax) :
            fA2F(amin,amid,amax,fmax,fmin,fmax),
            fF2A(fmin,fmax,amin,amax)				// Special, pseudo inverse of a non monotonic function
        {}

        virtual double ui2faust(double x) { return fA2F(x); }
        virtual double faust2ui(double x) { return fF2A(x); }

        virtual void setMappingValues(double amin, double amid, double amax, double fmin, double fmid, double fmax)
        {
            //__android_log_print(ANDROID_LOG_ERROR, "Faust", "AccDownUpConverter update %f %f %f %f %f %f", amin,amid,amax,fmin,fmid,fmax);
            fA2F = Interpolator3pt(amin, amid, amax, fmax, fmin, fmax);
            fF2A = Interpolator(fmin, fmax, amin, amax);
        }

        virtual void getMappingValues(double& amin, double& amid, double& amax)
        {
            fA2F.getMappingValues(amin, amid, amax);
        }
};

//--------------------------------------------------------------------------------------
// Base class for ZoneControl
//--------------------------------------------------------------------------------------
class FAUST_API ZoneControl {

    protected:

        FAUSTFLOAT*	fZone;

    public:

        ZoneControl(FAUSTFLOAT* zone) : fZone(zone) {}
        virtual ~ZoneControl() {}

        virtual void update(double v) const {}

        virtual void setMappingValues(int curve, double amin, double amid, double amax, double min, double init, double max) {}
        virtual void getMappingValues(double& amin, double& amid, double& amax) {}

        FAUSTFLOAT* getZone() { return fZone; }

        virtual void setActive(bool on_off) {}
        virtual bool getActive() { return false; }

        virtual int getCurve() { return -1; }

};

//--------------------------------------------------------------------------------------
//  Useful to implement accelerometers metadata as a list of ZoneControl for each axes
//--------------------------------------------------------------------------------------
class FAUST_API ConverterZoneControl : public ZoneControl {

    protected:

        ValueConverter* fValueConverter;

    public:

        ConverterZoneControl(FAUSTFLOAT* zone, ValueConverter* converter) : ZoneControl(zone), fValueConverter(converter) {}
        virtual ~ConverterZoneControl() { delete fValueConverter; } // Assuming fValueConverter is not kept elsewhere...

        virtual void update(double v) const { *fZone = FAUSTFLOAT(fValueConverter->ui2faust(v)); }

        ValueConverter* getConverter() { return fValueConverter; }

};

//--------------------------------------------------------------------------------------
// Association of a zone and a four value converter, each one for each possible curve.
// Useful to implement accelerometers metadata as a list of ZoneControl for each axes
//--------------------------------------------------------------------------------------
class FAUST_API CurveZoneControl : public ZoneControl {

    private:

        std::vector<UpdatableValueConverter*> fValueConverters;
        int fCurve;

    public:

        CurveZoneControl(FAUSTFLOAT* zone, int curve, double amin, double amid, double amax, double min, double init, double max) : ZoneControl(zone), fCurve(0)
        {
            assert(curve >= 0 && curve <= 3);
            fValueConverters.push_back(new AccUpConverter(amin, amid, amax, min, init, max));
            fValueConverters.push_back(new AccDownConverter(amin, amid, amax, min, init, max));
            fValueConverters.push_back(new AccUpDownConverter(amin, amid, amax, min, init, max));
            fValueConverters.push_back(new AccDownUpConverter(amin, amid, amax, min, init, max));
            fCurve = curve;
        }
        virtual ~CurveZoneControl()
        {
            for (const auto& it : fValueConverters) { delete it; }
        }
        void update(double v) const { if (fValueConverters[fCurve]->getActive()) *fZone = FAUSTFLOAT(fValueConverters[fCurve]->ui2faust(v)); }

        void setMappingValues(int curve, double amin, double amid, double amax, double min, double init, double max)
        {
            fValueConverters[curve]->setMappingValues(amin, amid, amax, min, init, max);
            fCurve = curve;
        }

        void getMappingValues(double& amin, double& amid, double& amax)
        {
            fValueConverters[fCurve]->getMappingValues(amin, amid, amax);
        }

        void setActive(bool on_off)
        {
            for (const auto& it : fValueConverters) { it->setActive(on_off); }
        }

        int getCurve() { return fCurve; }
};

class FAUST_API ZoneReader {

    private:

        FAUSTFLOAT* fZone;
        Interpolator fInterpolator;

    public:

        ZoneReader(FAUSTFLOAT* zone, double lo, double hi) : fZone(zone), fInterpolator(lo, hi, 0, 255) {}

        virtual ~ZoneReader() {}

        int getValue()
        {
            return (fZone != nullptr) ? int(fInterpolator(*fZone)) : 127;
        }

};

#endif
/**************************  END  ValueConverter.h **************************/
/************************** BEGIN MetaDataUI.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef MetaData_UI_H
#define MetaData_UI_H

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

#include <map>
#include <set>
#include <string>
#include <string.h>
#include <assert.h>
#include <stdio.h> // We use the lighter fprintf code


static bool startWith(const std::string& str, const std::string& prefix)
{
    return (str.substr(0, prefix.size()) == prefix);
}

/**
 * Convert a dB value into a scale between 0 and 1 (following IEC standard ?)
 */
static FAUSTFLOAT dB2Scale(FAUSTFLOAT dB)
{
    FAUSTFLOAT scale = FAUSTFLOAT(1.0);
    
    /*if (dB < -70.0f)
     scale = 0.0f;
     else*/
    if (dB < FAUSTFLOAT(-60.0))
        scale = (dB + FAUSTFLOAT(70.0)) * FAUSTFLOAT(0.0025);
    else if (dB < FAUSTFLOAT(-50.0))
        scale = (dB + FAUSTFLOAT(60.0)) * FAUSTFLOAT(0.005) + FAUSTFLOAT(0.025);
    else if (dB < FAUSTFLOAT(-40.0))
        scale = (dB + FAUSTFLOAT(50.0)) * FAUSTFLOAT(0.0075) + FAUSTFLOAT(0.075);
    else if (dB < FAUSTFLOAT(-30.0))
        scale = (dB + FAUSTFLOAT(40.0)) * FAUSTFLOAT(0.015) + FAUSTFLOAT(0.15);
    else if (dB < FAUSTFLOAT(-20.0))
        scale = (dB + FAUSTFLOAT(30.0)) * FAUSTFLOAT(0.02) + FAUSTFLOAT(0.3);
    else if (dB < FAUSTFLOAT(-0.001) || dB > FAUSTFLOAT(0.001))  /* if (dB < 0.0) */
        scale = (dB + FAUSTFLOAT(20.0)) * FAUSTFLOAT(0.025) + FAUSTFLOAT(0.5);
    
    return scale;
}

/*******************************************************************************
 * MetaDataUI : Common class for MetaData handling
 ******************************************************************************/

//============================= BEGIN GROUP LABEL METADATA===========================
// Unlike widget's label, metadata inside group's label are not extracted directly by
// the Faust compiler. Therefore they must be extracted within the architecture file
//-----------------------------------------------------------------------------------

class MetaDataUI {
    
    protected:
        
        std::string                         fGroupTooltip;
        std::map<FAUSTFLOAT*, FAUSTFLOAT>   fGuiSize;            // map widget zone with widget size coef
        std::map<FAUSTFLOAT*, std::string>  fTooltip;            // map widget zone with tooltip strings
        std::map<FAUSTFLOAT*, std::string>  fUnit;               // map widget zone to unit string (i.e. "dB")
        std::map<FAUSTFLOAT*, std::string>  fRadioDescription;   // map zone to {'low':440; ...; 'hi':1000.0}
        std::map<FAUSTFLOAT*, std::string>  fMenuDescription;    // map zone to {'low':440; ...; 'hi':1000.0}
        std::set<FAUSTFLOAT*>               fKnobSet;            // set of widget zone to be knobs
        std::set<FAUSTFLOAT*>               fLedSet;             // set of widget zone to be LEDs
        std::set<FAUSTFLOAT*>               fNumSet;             // set of widget zone to be numerical bargraphs
        std::set<FAUSTFLOAT*>               fLogSet;             // set of widget zone having a log UI scale
        std::set<FAUSTFLOAT*>               fExpSet;             // set of widget zone having an exp UI scale
        std::set<FAUSTFLOAT*>               fHiddenSet;          // set of hidden widget zone
        
        void clearMetadata()
        {
            fGuiSize.clear();
            fTooltip.clear();
            fUnit.clear();
            fRadioDescription.clear();
            fMenuDescription.clear();
            fKnobSet.clear();
            fLedSet.clear();
            fNumSet.clear();
            fLogSet.clear();
            fExpSet.clear();
            fHiddenSet.clear();
            fGroupTooltip = "";
        }
        
        /**
         * rmWhiteSpaces(): Remove the leading and trailing white spaces of a string
         * (but not those in the middle of the string)
         */
        static std::string rmWhiteSpaces(const std::string& s)
        {
            size_t i = s.find_first_not_of(" \t");
            size_t j = s.find_last_not_of(" \t");
            if ((i != std::string::npos) && (j != std::string::npos)) {
                return s.substr(i, 1+j-i);
            } else {
                return "";
            }
        }
        
        /**
         * Format tooltip string by replacing some white spaces by
         * return characters so that line width doesn't exceed n.
         * Limitation : long words exceeding n are not cut.
         */
        std::string formatTooltip(int n, const std::string& tt)
        {
            std::string ss = tt;  // ss string we are going to format
            int lws = 0;          // last white space encountered
            int lri = 0;          // last return inserted
            for (int i = 0; i < (int)tt.size(); i++) {
                if (tt[i] == ' ') lws = i;
                if (((i-lri) >= n) && (lws > lri)) {
                    // insert return here
                    ss[lws] = '\n';
                    lri = lws;
                }
            }
            return ss;
        }
        
    public:
        
        virtual ~MetaDataUI()
        {}
        
        enum Scale {
            kLin,
            kLog,
            kExp
        };
        
        Scale getScale(FAUSTFLOAT* zone)
        {
            if (fLogSet.count(zone) > 0) return kLog;
            if (fExpSet.count(zone) > 0) return kExp;
            return kLin;
        }
        
        bool isKnob(FAUSTFLOAT* zone)
        {
            return fKnobSet.count(zone) > 0;
        }
        
        bool isRadio(FAUSTFLOAT* zone)
        {
            return fRadioDescription.count(zone) > 0;
        }
        
        bool isMenu(FAUSTFLOAT* zone)
        {
            return fMenuDescription.count(zone) > 0;
        }
        
        bool isLed(FAUSTFLOAT* zone)
        {
            return fLedSet.count(zone) > 0;
        }
        
        bool isNumerical(FAUSTFLOAT* zone)
        {
            return fNumSet.count(zone) > 0;
        }
        
        bool isHidden(FAUSTFLOAT* zone)
        {
            return fHiddenSet.count(zone) > 0;
        }
        
        /**
         * Extracts metadata from a label : 'vol [unit: dB]' -> 'vol' + metadata(unit=dB)
         */
        static void extractMetadata(const std::string& fulllabel, std::string& label, std::map<std::string, std::string>& metadata)
        {
            enum {kLabel, kEscape1, kEscape2, kEscape3, kKey, kValue};
            int state = kLabel; int deep = 0;
            std::string key, value;
            
            for (unsigned int i = 0; i < fulllabel.size(); i++) {
                char c = fulllabel[i];
                switch (state) {
                    case kLabel :
                        assert(deep == 0);
                        switch (c) {
                            case '\\' : state = kEscape1; break;
                            case '[' : state = kKey; deep++; break;
                            default : label += c;
                        }
                        break;
                        
                    case kEscape1:
                        label += c;
                        state = kLabel;
                        break;
                        
                    case kEscape2:
                        key += c;
                        state = kKey;
                        break;
                        
                    case kEscape3:
                        value += c;
                        state = kValue;
                        break;
                        
                    case kKey:
                        assert(deep > 0);
                        switch (c) {
                            case '\\':
                                state = kEscape2;
                                break;
                                
                            case '[':
                                deep++;
                                key += c;
                                break;
                                
                            case ':':
                                if (deep == 1) {
                                    state = kValue;
                                } else {
                                    key += c;
                                }
                                break;
                            case ']':
                                deep--;
                                if (deep < 1) {
                                    metadata[rmWhiteSpaces(key)] = "";
                                    state = kLabel;
                                    key = "";
                                    value = "";
                                } else {
                                    key += c;
                                }
                                break;
                            default : key += c;
                        }
                        break;
                        
                    case kValue:
                        assert(deep > 0);
                        switch (c) {
                            case '\\':
                                state = kEscape3;
                                break;
                                
                            case '[':
                                deep++;
                                value += c;
                                break;
                                
                            case ']':
                                deep--;
                                if (deep < 1) {
                                    metadata[rmWhiteSpaces(key)] = rmWhiteSpaces(value);
                                    state = kLabel;
                                    key = "";
                                    value = "";
                                } else {
                                    value += c;
                                }
                                break;
                            default : value += c;
                        }
                        break;
                        
                    default:
                        fprintf(stderr, "ERROR unrecognized state %d\n", state);
                }
            }
            label = rmWhiteSpaces(label);
        }
        
        /**
         * Analyses the widget zone metadata declarations and takes appropriate actions.
         */
        void declare(FAUSTFLOAT* zone, const char* key, const char* value)
        {
            if (zone == 0) {
                // special zone 0 means group metadata
                if (strcmp(key, "tooltip") == 0) {
                    // only group tooltip are currently implemented
                    fGroupTooltip = formatTooltip(30, value);
                } else if ((strcmp(key, "hidden") == 0) && (strcmp(value, "1") == 0)) {
                    fHiddenSet.insert(zone);
                }
            } else {
                if (strcmp(key, "size") == 0) {
                    fGuiSize[zone] = atof(value);
                }
                else if (strcmp(key, "tooltip") == 0) {
                    fTooltip[zone] = formatTooltip(30, value);
                }
                else if (strcmp(key, "unit") == 0) {
                    fUnit[zone] = value;
                }
                else if ((strcmp(key, "hidden") == 0) && (strcmp(value, "1") == 0)) {
                    fHiddenSet.insert(zone);
                }
                else if (strcmp(key, "scale") == 0) {
                    if (strcmp(value, "log") == 0) {
                        fLogSet.insert(zone);
                    } else if (strcmp(value, "exp") == 0) {
                        fExpSet.insert(zone);
                    }
                }
                else if (strcmp(key, "style") == 0) {
                    if (strcmp(value, "knob") == 0) {
                        fKnobSet.insert(zone);
                    } else if (strcmp(value, "led") == 0) {
                        fLedSet.insert(zone);
                    } else if (strcmp(value, "numerical") == 0) {
                        fNumSet.insert(zone);
                    } else {
                        const char* p = value;
                        if (parseWord(p, "radio")) {
                            fRadioDescription[zone] = std::string(p);
                        } else if (parseWord(p, "menu")) {
                            fMenuDescription[zone] = std::string(p);
                        }
                    }
                }
            }
        }
    
};

#endif
/**************************  END  MetaDataUI.h **************************/
/************************** BEGIN ring-buffer.h **************************/
/*
  Copyright (C) 2000 Paul Davis
  Copyright (C) 2003 Rohan Drape
  Copyright (C) 2016 GRAME (renaming for internal use)

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 2.1 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  ISO/POSIX C version of Paul Davis's lock free ringbuffer C++ code.
  This is safe for the case of one read thread and one write thread.
*/

#ifndef __ring_buffer__
#define __ring_buffer__

#include <stdlib.h>
#include <string.h>

#ifdef WIN32
# pragma warning (disable: 4334)
#else
# pragma GCC diagnostic ignored "-Wunused-function"
#endif

typedef struct {
    char *buf;
    size_t len;
}
ringbuffer_data_t;

typedef struct {
    char *buf;
    volatile size_t write_ptr;
    volatile size_t read_ptr;
    size_t	size;
    size_t	size_mask;
    int	mlocked;
}
ringbuffer_t;

static ringbuffer_t *ringbuffer_create(size_t sz);
static void ringbuffer_free(ringbuffer_t *rb);
static void ringbuffer_get_read_vector(const ringbuffer_t *rb,
                                         ringbuffer_data_t *vec);
static void ringbuffer_get_write_vector(const ringbuffer_t *rb,
                                          ringbuffer_data_t *vec);
static size_t ringbuffer_read(ringbuffer_t *rb, char *dest, size_t cnt);
static size_t ringbuffer_peek(ringbuffer_t *rb, char *dest, size_t cnt);
static void ringbuffer_read_advance(ringbuffer_t *rb, size_t cnt);
static size_t ringbuffer_read_space(const ringbuffer_t *rb);
static int ringbuffer_mlock(ringbuffer_t *rb);
static void ringbuffer_reset(ringbuffer_t *rb);
static void ringbuffer_reset_size (ringbuffer_t * rb, size_t sz);
static size_t ringbuffer_write(ringbuffer_t *rb, const char *src,
                                 size_t cnt);
static void ringbuffer_write_advance(ringbuffer_t *rb, size_t cnt);
static size_t ringbuffer_write_space(const ringbuffer_t *rb);

/* Create a new ringbuffer to hold at least `sz' bytes of data. The
   actual buffer size is rounded up to the next power of two. */

static ringbuffer_t *
ringbuffer_create (size_t sz)
{
	size_t power_of_two;
	ringbuffer_t *rb;

	if ((rb = (ringbuffer_t *) malloc (sizeof (ringbuffer_t))) == NULL) {
		return NULL;
	}

	for (power_of_two = 1u; 1u << power_of_two < sz; power_of_two++);

	rb->size = 1u << power_of_two;
	rb->size_mask = rb->size;
	rb->size_mask -= 1;
	rb->write_ptr = 0;
	rb->read_ptr = 0;
	if ((rb->buf = (char *) malloc (rb->size)) == NULL) {
		free (rb);
		return NULL;
	}
	rb->mlocked = 0;

	return rb;
}

/* Free all data associated with the ringbuffer `rb'. */

static void
ringbuffer_free (ringbuffer_t * rb)
{
#ifdef USE_MLOCK
	if (rb->mlocked) {
		munlock (rb->buf, rb->size);
	}
#endif /* USE_MLOCK */
	free (rb->buf);
	free (rb);
}

/* Lock the data block of `rb' using the system call 'mlock'.  */

static int
ringbuffer_mlock (ringbuffer_t * rb)
{
#ifdef USE_MLOCK
	if (mlock (rb->buf, rb->size)) {
		return -1;
	}
#endif /* USE_MLOCK */
	rb->mlocked = 1;
	return 0;
}

/* Reset the read and write pointers to zero. This is not thread
   safe. */

static void
ringbuffer_reset (ringbuffer_t * rb)
{
	rb->read_ptr = 0;
	rb->write_ptr = 0;
    memset(rb->buf, 0, rb->size);
}

/* Reset the read and write pointers to zero. This is not thread
   safe. */

static void
ringbuffer_reset_size (ringbuffer_t * rb, size_t sz)
{
    rb->size = sz;
    rb->size_mask = rb->size;
    rb->size_mask -= 1;
    rb->read_ptr = 0;
    rb->write_ptr = 0;
}

/* Return the number of bytes available for reading. This is the
   number of bytes in front of the read pointer and behind the write
   pointer.  */

static size_t
ringbuffer_read_space (const ringbuffer_t * rb)
{
	size_t w, r;

	w = rb->write_ptr;
	r = rb->read_ptr;

	if (w > r) {
		return w - r;
	} else {
		return (w - r + rb->size) & rb->size_mask;
	}
}

/* Return the number of bytes available for writing. This is the
   number of bytes in front of the write pointer and behind the read
   pointer.  */

static size_t
ringbuffer_write_space (const ringbuffer_t * rb)
{
	size_t w, r;

	w = rb->write_ptr;
	r = rb->read_ptr;

	if (w > r) {
		return ((r - w + rb->size) & rb->size_mask) - 1;
	} else if (w < r) {
		return (r - w) - 1;
	} else {
		return rb->size - 1;
	}
}

/* The copying data reader. Copy at most `cnt' bytes from `rb' to
   `dest'.  Returns the actual number of bytes copied. */

static size_t
ringbuffer_read (ringbuffer_t * rb, char *dest, size_t cnt)
{
	size_t free_cnt;
	size_t cnt2;
	size_t to_read;
	size_t n1, n2;

	if ((free_cnt = ringbuffer_read_space (rb)) == 0) {
		return 0;
	}

	to_read = cnt > free_cnt ? free_cnt : cnt;

	cnt2 = rb->read_ptr + to_read;

	if (cnt2 > rb->size) {
		n1 = rb->size - rb->read_ptr;
		n2 = cnt2 & rb->size_mask;
	} else {
		n1 = to_read;
		n2 = 0;
	}

	memcpy (dest, &(rb->buf[rb->read_ptr]), n1);
	rb->read_ptr = (rb->read_ptr + n1) & rb->size_mask;

	if (n2) {
		memcpy (dest + n1, &(rb->buf[rb->read_ptr]), n2);
		rb->read_ptr = (rb->read_ptr + n2) & rb->size_mask;
	}

	return to_read;
}

/* The copying data reader w/o read pointer advance. Copy at most
   `cnt' bytes from `rb' to `dest'.  Returns the actual number of bytes
   copied. */

static size_t
ringbuffer_peek (ringbuffer_t * rb, char *dest, size_t cnt)
{
	size_t free_cnt;
	size_t cnt2;
	size_t to_read;
	size_t n1, n2;
	size_t tmp_read_ptr;

	tmp_read_ptr = rb->read_ptr;

	if ((free_cnt = ringbuffer_read_space (rb)) == 0) {
		return 0;
	}

	to_read = cnt > free_cnt ? free_cnt : cnt;

	cnt2 = tmp_read_ptr + to_read;

	if (cnt2 > rb->size) {
		n1 = rb->size - tmp_read_ptr;
		n2 = cnt2 & rb->size_mask;
	} else {
		n1 = to_read;
		n2 = 0;
	}

	memcpy (dest, &(rb->buf[tmp_read_ptr]), n1);
	tmp_read_ptr = (tmp_read_ptr + n1) & rb->size_mask;

	if (n2) {
		memcpy (dest + n1, &(rb->buf[tmp_read_ptr]), n2);
	}

	return to_read;
}

/* The copying data writer. Copy at most `cnt' bytes to `rb' from
   `src'.  Returns the actual number of bytes copied. */

static size_t
ringbuffer_write (ringbuffer_t * rb, const char *src, size_t cnt)
{
	size_t free_cnt;
	size_t cnt2;
	size_t to_write;
	size_t n1, n2;

	if ((free_cnt = ringbuffer_write_space (rb)) == 0) {
		return 0;
	}

	to_write = cnt > free_cnt ? free_cnt : cnt;

	cnt2 = rb->write_ptr + to_write;

	if (cnt2 > rb->size) {
		n1 = rb->size - rb->write_ptr;
		n2 = cnt2 & rb->size_mask;
	} else {
		n1 = to_write;
		n2 = 0;
	}

	memcpy (&(rb->buf[rb->write_ptr]), src, n1);
	rb->write_ptr = (rb->write_ptr + n1) & rb->size_mask;

	if (n2) {
		memcpy (&(rb->buf[rb->write_ptr]), src + n1, n2);
		rb->write_ptr = (rb->write_ptr + n2) & rb->size_mask;
	}

	return to_write;
}

/* Advance the read pointer `cnt' places. */

static void
ringbuffer_read_advance (ringbuffer_t * rb, size_t cnt)
{
	size_t tmp = (rb->read_ptr + cnt) & rb->size_mask;
	rb->read_ptr = tmp;
}

/* Advance the write pointer `cnt' places. */

static void
ringbuffer_write_advance (ringbuffer_t * rb, size_t cnt)
{
	size_t tmp = (rb->write_ptr + cnt) & rb->size_mask;
	rb->write_ptr = tmp;
}

/* The non-copying data reader. `vec' is an array of two places. Set
   the values at `vec' to hold the current readable data at `rb'. If
   the readable data is in one segment the second segment has zero
   length. */

static void
ringbuffer_get_read_vector (const ringbuffer_t * rb,
				 ringbuffer_data_t * vec)
{
	size_t free_cnt;
	size_t cnt2;
	size_t w, r;

	w = rb->write_ptr;
	r = rb->read_ptr;

	if (w > r) {
		free_cnt = w - r;
	} else {
		free_cnt = (w - r + rb->size) & rb->size_mask;
	}

	cnt2 = r + free_cnt;

	if (cnt2 > rb->size) {

		/* Two part vector: the rest of the buffer after the current write
		   ptr, plus some from the start of the buffer. */

		vec[0].buf = &(rb->buf[r]);
		vec[0].len = rb->size - r;
		vec[1].buf = rb->buf;
		vec[1].len = cnt2 & rb->size_mask;

	} else {

		/* Single part vector: just the rest of the buffer */

		vec[0].buf = &(rb->buf[r]);
		vec[0].len = free_cnt;
		vec[1].len = 0;
	}
}

/* The non-copying data writer. `vec' is an array of two places. Set
   the values at `vec' to hold the current writeable data at `rb'. If
   the writeable data is in one segment the second segment has zero
   length. */

static void
ringbuffer_get_write_vector (const ringbuffer_t * rb,
				  ringbuffer_data_t * vec)
{
	size_t free_cnt;
	size_t cnt2;
	size_t w, r;

	w = rb->write_ptr;
	r = rb->read_ptr;

	if (w > r) {
		free_cnt = ((r - w + rb->size) & rb->size_mask) - 1;
	} else if (w < r) {
		free_cnt = (r - w) - 1;
	} else {
		free_cnt = rb->size - 1;
	}

	cnt2 = w + free_cnt;

	if (cnt2 > rb->size) {

		/* Two part vector: the rest of the buffer after the current write
		   ptr, plus some from the start of the buffer. */

		vec[0].buf = &(rb->buf[w]);
		vec[0].len = rb->size - w;
		vec[1].buf = rb->buf;
		vec[1].len = cnt2 & rb->size_mask;
	} else {
		vec[0].buf = &(rb->buf[w]);
		vec[0].len = free_cnt;
		vec[1].len = 0;
	}
}

#endif // __ring_buffer__
/**************************  END  ring-buffer.h **************************/

/*******************************************************************************
 * GUI : Abstract Graphic User Interface
 * Provides additional mechanisms to synchronize widgets and zones. Widgets
 * should both reflect the value of a zone and allow to change this value.
 ******************************************************************************/

class uiItem;
class GUI;
struct clist;

typedef void (*uiCallback)(FAUSTFLOAT val, void* data);

/**
 * Base class for uiTypedItem: memory zones that can be grouped and synchronized, using an internal cache.
 */
struct uiItemBase
{
    
    uiItemBase(GUI* ui, FAUSTFLOAT* zone)
    {
        assert(ui);
        assert(zone);
    }
    
    virtual ~uiItemBase()
    {}
    
    /**
     * This method will be called when the value changes externally,
     * and will signal the new value to all linked uItem
     * when the value is different from the cached one.
     *
     * @param v - the new value
     */
    virtual void modifyZone(FAUSTFLOAT v) = 0;
    
    /**
     * This method will be called when the value changes externally,
     * and will signal the new value to all linked uItem
     * when the value is different from the cached one.
     *
     * @param date - the timestamp of the received value in usec
     * @param v - the new value
     */
    virtual void modifyZone(double date, FAUSTFLOAT v) {}
    
    /**
     * This method is called by the synchronisation mecanism and is expected
     * to 'reflect' the new value, by changing the Widget layout for instance,
     * or sending a message (OSC, MIDI...)
     */
    virtual void reflectZone() = 0;
    
    /**
     * Return the cached value.
     *
     * @return - the cached value
     */
    virtual double cache() = 0;
    
};

// Declared as 'static' to avoid code duplication at link time
static void deleteClist(clist* cl);

/**
 * A list containing all groupe uiItemBase objects.
 */
struct clist : public std::list<uiItemBase*>
{
    
    virtual ~clist()
    {
        deleteClist(this);
    }
        
};

static void createUiCallbackItem(GUI* ui, FAUSTFLOAT* zone, uiCallback foo, void* data);

typedef std::map<FAUSTFLOAT*, clist*> zmap;

typedef std::map<FAUSTFLOAT*, ringbuffer_t*> ztimedmap;

class GUI : public UI
{
		
    private:
     
        static std::list<GUI*> fGuiList;
        zmap fZoneMap;
        bool fStopped;
    
     public:
            
        GUI():fStopped(false)
        {	
            fGuiList.push_back(this);
        }
        
        virtual ~GUI() 
        {   
            // delete all items
            for (const auto& it : fZoneMap) {
                delete it.second;
            }
            // suppress 'this' in static fGuiList
            fGuiList.remove(this);
        }

        // -- registerZone(z,c) : zone management
        
        void registerZone(FAUSTFLOAT* z, uiItemBase* c)
        {
            if (fZoneMap.find(z) == fZoneMap.end()) fZoneMap[z] = new clist();
            fZoneMap[z]->push_back(c);
        }
    
        void updateZone(FAUSTFLOAT* z)
        {
            FAUSTFLOAT v = *z;
            clist* cl = fZoneMap[z];
            for (const auto& c : *cl) {
                if (c->cache() != v) c->reflectZone();
            }
        }
    
        void updateAllZones()
        {
            for (const auto& m : fZoneMap) {
                updateZone(m.first);
            }
        }
    
        static void updateAllGuis()
        {
            for (const auto& g : fGuiList) {
                g->updateAllZones();
            }
        }
    
        void addCallback(FAUSTFLOAT* zone, uiCallback foo, void* data)
        {
            createUiCallbackItem(this, zone, foo, data);
        }

        // Start event or message processing
        virtual bool run() { return false; };
        // Stop event or message processing
        virtual void stop() { fStopped = true; }
        bool stopped() { return fStopped; }
    
        // -- widget's layouts
        
        virtual void openTabBox(const char* label) {}
        virtual void openHorizontalBox(const char* label) {}
        virtual void openVerticalBox(const char* label) {}
        virtual void closeBox() {}
        
        // -- active widgets
        
        virtual void addButton(const char* label, FAUSTFLOAT* zone) {}
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone) {}
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    
        // -- passive widgets
        
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
    
        // -- soundfiles
    
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}
    
        // -- metadata declarations

        virtual void declare(FAUSTFLOAT*, const char*, const char*) {}
    
        // Static global for timed zones, shared between all UI that will set timed values
        static ztimedmap gTimedZoneMap;

};

/**
 * User Interface Item: abstract definition.
 */
template <typename REAL>
class uiTypedItemReal : public uiItemBase
{
    protected:
        
        GUI* fGUI;
        REAL* fZone;
        REAL fCache;
        
        uiTypedItemReal(GUI* ui, REAL* zone):uiItemBase(ui, static_cast<FAUSTFLOAT*>(zone)),
        fGUI(ui), fZone(zone), fCache(REAL(-123456.654321))
        {
            ui->registerZone(zone, this);
        }
        
    public:
        
        virtual ~uiTypedItemReal()
        {}
    
        void modifyZone(REAL v)
        {
            fCache = v;
            if (*fZone != v) {
                *fZone = v;
                fGUI->updateZone(fZone);
            }
        }
    
        double cache() { return fCache; }
    
};

class uiItem : public uiTypedItemReal<FAUSTFLOAT> {
    
    protected:
    
        uiItem(GUI* ui, FAUSTFLOAT* zone):uiTypedItemReal<FAUSTFLOAT>(ui, zone)
        {}

    public:

        virtual ~uiItem() 
        {}

		void modifyZone(FAUSTFLOAT v)
		{
			fCache = v;
			if (*fZone != v) {
				*fZone = v;
				fGUI->updateZone(fZone);
			}
		}

};

/**
 * Base class for items with a value converter.
 */
struct uiConverter {
    
    ValueConverter* fConverter;
    
    uiConverter(MetaDataUI::Scale scale, FAUSTFLOAT umin, FAUSTFLOAT umax, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
    {
        // Select appropriate converter according to scale mode
        if (scale == MetaDataUI::kLog) {
            fConverter = new LogValueConverter(umin, umax, fmin, fmax);
        } else if (scale == MetaDataUI::kExp) {
            fConverter = new ExpValueConverter(umin, umax, fmin, fmax);
        } else {
            fConverter = new LinearValueConverter(umin, umax, fmin, fmax);
        }
    }
    
    virtual ~uiConverter()
    {
        delete fConverter;
    }
};

/**
 * User Interface item owned (and so deleted) by external code.
 */
class uiOwnedItem : public uiItem {
    
    protected:
    
        uiOwnedItem(GUI* ui, FAUSTFLOAT* zone):uiItem(ui, zone)
        {}
    
     public:
    
        virtual ~uiOwnedItem()
        {}
    
        virtual void reflectZone() {}
};

/**
 * Callback Item.
 */
class uiCallbackItem : public uiItem {
    
    protected:
    
        uiCallback fCallback;
        void* fData;
    
    public:
    
        uiCallbackItem(GUI* ui, FAUSTFLOAT* zone, uiCallback foo, void* data)
        : uiItem(ui, zone), fCallback(foo), fData(data) {}
        
        virtual void reflectZone() 
        {		
            FAUSTFLOAT v = *fZone;
            fCache = v; 
            fCallback(v, fData);	
        }
};

/**
 *  For timestamped control.
 */
struct DatedControl {
    
    double fDate;
    FAUSTFLOAT fValue;
    
    DatedControl(double d = 0., FAUSTFLOAT v = FAUSTFLOAT(0)):fDate(d), fValue(v) {}
    
};

/**
 * Base class for timed items.
 */
class uiTimedItem : public uiItem
{
    
    protected:
        
        bool fDelete;
        
    public:
    
        using uiItem::modifyZone;
        
        uiTimedItem(GUI* ui, FAUSTFLOAT* zone):uiItem(ui, zone)
        {
            if (GUI::gTimedZoneMap.find(fZone) == GUI::gTimedZoneMap.end()) {
                GUI::gTimedZoneMap[fZone] = ringbuffer_create(8192);
                fDelete = true;
            } else {
                fDelete = false;
            }
        }
        
        virtual ~uiTimedItem()
        {
            ztimedmap::iterator it;
            if (fDelete && ((it = GUI::gTimedZoneMap.find(fZone)) != GUI::gTimedZoneMap.end())) {
                ringbuffer_free((*it).second);
                GUI::gTimedZoneMap.erase(it);
            }
        }
        
        virtual void modifyZone(double date, FAUSTFLOAT v)
        {
            size_t res;
            DatedControl dated_val(date, v);
            if ((res = ringbuffer_write(GUI::gTimedZoneMap[fZone], (const char*)&dated_val, sizeof(DatedControl))) != sizeof(DatedControl)) {
                fprintf(stderr, "ringbuffer_write error DatedControl\n");
            }
        }
    
};

/**
 * Allows to group a set of zones.
 */
class uiGroupItem : public uiItem
{
    protected:
    
        std::vector<FAUSTFLOAT*> fZoneMap;

    public:
    
        uiGroupItem(GUI* ui, FAUSTFLOAT* zone):uiItem(ui, zone)
        {}
        virtual ~uiGroupItem() 
        {}
        
        virtual void reflectZone() 
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            
            // Update all zones of the same group
            for (const auto& it : fZoneMap) {
                *it = v;
            }
        }
        
        void addZone(FAUSTFLOAT* zone) { fZoneMap.push_back(zone); }

};

// Cannot be defined as method in the classes.

static void createUiCallbackItem(GUI* ui, FAUSTFLOAT* zone, uiCallback foo, void* data)
{
    new uiCallbackItem(ui, zone, foo, data);
}

static void deleteClist(clist* cl)
{
    for (const auto& it : *cl) {
        // This specific code is only used in JUCE context. TODO: use proper 'shared_ptr' based memory management.
    #if defined(JUCE_32BIT) || defined(JUCE_64BIT)
        uiOwnedItem* owned = dynamic_cast<uiOwnedItem*>(it);
        // owned items are deleted by external code
        if (!owned) {
            delete it;
        }
    #else
        delete it;
    #endif
    }
}

#endif
/**************************  END  GUI.h **************************/
/************************** BEGIN DecoratorUI.h **************************
 FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
*************************************************************************/

#ifndef Decorator_UI_H
#define Decorator_UI_H


//----------------------------------------------------------------
//  Generic UI empty implementation
//----------------------------------------------------------------

class FAUST_API GenericUI : public UI
{
    
    public:
        
        GenericUI() {}
        virtual ~GenericUI() {}
        
        // -- widget's layouts
        virtual void openTabBox(const char* label) {}
        virtual void openHorizontalBox(const char* label) {}
        virtual void openVerticalBox(const char* label) {}
        virtual void closeBox() {}
        
        // -- active widgets
        virtual void addButton(const char* label, FAUSTFLOAT* zone) {}
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone) {}
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    
        // -- passive widgets
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
    
        // -- soundfiles
        virtual void addSoundfile(const char* label, const char* soundpath, Soundfile** sf_zone) {}
    
        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val) {}
    
};

//----------------------------------------------------------------
//  Generic UI decorator
//----------------------------------------------------------------

class FAUST_API DecoratorUI : public UI
{
    
    protected:
        
        UI* fUI;
        
    public:
        
        DecoratorUI(UI* ui = 0):fUI(ui) {}
        virtual ~DecoratorUI() { delete fUI; }
        
        // -- widget's layouts
        virtual void openTabBox(const char* label)          { fUI->openTabBox(label); }
        virtual void openHorizontalBox(const char* label)   { fUI->openHorizontalBox(label); }
        virtual void openVerticalBox(const char* label)     { fUI->openVerticalBox(label); }
        virtual void closeBox()                             { fUI->closeBox(); }
        
        // -- active widgets
        virtual void addButton(const char* label, FAUSTFLOAT* zone)         { fUI->addButton(label, zone); }
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)    { fUI->addCheckButton(label, zone); }
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        { fUI->addVerticalSlider(label, zone, init, min, max, step); }
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        { fUI->addHorizontalSlider(label, zone, init, min, max, step); }
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        { fUI->addNumEntry(label, zone, init, min, max, step); }
        
        // -- passive widgets
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        { fUI->addHorizontalBargraph(label, zone, min, max); }
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        { fUI->addVerticalBargraph(label, zone, min, max); }
    
        // -- soundfiles
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) { fUI->addSoundfile(label, filename, sf_zone); }
    
        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val) { fUI->declare(zone, key, val); }
    
};

// Defined here to simplify header #include inclusion 
class FAUST_API SoundUIInterface : public GenericUI {};

#endif
/**************************  END  DecoratorUI.h **************************/

namespace {
    
#if __APPLE__
#if TARGET_OS_IPHONE
    //inline double GetCurrentTimeInUsec() { return double(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000.; }
    // TODO
    inline double GetCurrentTimeInUsec() { return 0.0; }
#else
    #include <CoreAudio/HostTime.h>
    inline double GetCurrentTimeInUsec() { return double(AudioConvertHostTimeToNanos(AudioGetCurrentHostTime())) / 1000.; }
#endif
#endif

#if __linux__
#include <sys/time.h>
inline double GetCurrentTimeInUsec() 
{
    struct timeval tv;
    (void)gettimeofday(&tv, (struct timezone *)NULL);
    return double((tv.tv_sec * 1000000) + tv.tv_usec);
}
#endif

#if _WIN32
#include <windows.h>
inline double GetCurrentTimeInUsec(void)
{
    LARGE_INTEGER time;
    LARGE_INTEGER frequency;
    QueryPerformanceFrequency(&frequency);
    QueryPerformanceCounter(&time);
    return double(time.QuadPart) / double(frequency.QuadPart) * 1000000.0;
}
#endif
    
}

/**
 * ZoneUI : this class collect zones in a set.
 */

struct ZoneUI : public GenericUI {
    
    std::set<FAUSTFLOAT*> fZoneSet;
    
    ZoneUI():GenericUI() {}
    virtual ~ZoneUI() {}
    
    void insertZone(FAUSTFLOAT* zone) 
    { 
        if (GUI::gTimedZoneMap.find(zone) != GUI::gTimedZoneMap.end()) {
            fZoneSet.insert(zone);
        } 
    }
    
    // -- active widgets
    void addButton(const char* label, FAUSTFLOAT* zone)
    {
        insertZone(zone);
    }
    void addCheckButton(const char* label, FAUSTFLOAT* zone)
    {
        insertZone(zone);
    }
    void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
    {
        insertZone(zone);
    }
    void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
    {
        insertZone(zone);
    }
    void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
    {
        insertZone(zone);
    }
    
    // -- passive widgets
    void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
    {
        insertZone(zone);
    }
    void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
    {
        insertZone(zone);
    }
  
};

/**
 * Timed signal processor that allows to handle the decorated DSP by 'slices'
 * that is, calling the 'compute' method several times and changing control
 * parameters between slices. Timestamps are in usec.
 */

class timed_dsp : public decorator_dsp {

    protected:
        
        double fDateUsec;       // Compute call date in usec
        double fOffsetUsec;     // Compute call offset in usec
        bool fFirstCallback;
        ZoneUI fZoneUI;
    
        FAUSTFLOAT** fInputsSlice;
        FAUSTFLOAT** fOutputsSlice;
    
        void computeSlice(int offset, int slice, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
        {
            if (slice > 0) {
                for (int chan = 0; chan < fDSP->getNumInputs(); chan++) {
                    fInputsSlice[chan] = &(inputs[chan][offset]);
                }
                for (int chan = 0; chan < fDSP->getNumOutputs(); chan++) {
                    fOutputsSlice[chan] = &(outputs[chan][offset]);
                }
                fDSP->compute(slice, fInputsSlice, fOutputsSlice);
            } 
        }
        
        double convertUsecToSample(double usec)
        {
            return std::max<double>(0., (double(getSampleRate()) * (usec - fDateUsec)) / 1000000.);
        }
        
        ztimedmap::iterator getNextControl(DatedControl& res)
        {
            DatedControl date1(DBL_MAX, 0);
            ztimedmap::iterator it1, it2 = GUI::gTimedZoneMap.end();
            std::set<FAUSTFLOAT*>::iterator it3;
              
            // Find date of next audio slice to compute
            for (it3 = fZoneUI.fZoneSet.begin(); it3 != fZoneUI.fZoneSet.end(); it3++) {
                // If value list is not empty, get the date and keep the minimal one
                it1 = GUI::gTimedZoneMap.find(*it3);
                if (it1 != GUI::gTimedZoneMap.end()) { // Check if zone still in global GUI::gTimedZoneMap (since MidiUI may have been desallocated)
                    DatedControl date2;
                    if (ringbuffer_peek((*it1).second, (char*)&date2, sizeof(DatedControl)) == sizeof(DatedControl) 
                        && date2.fDate < date1.fDate) {
                        it2 = it1;
                        date1 = date2;
                    }
                }
            }
            
            res = date1;
            return it2;
        }
        
        virtual void computeAux(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs, bool convert_ts)
        {
            int slice, offset = 0;
            ztimedmap::iterator it;
            DatedControl next_control;
             
            // Do audio computation "slice" by "slice"
            while ((it = getNextControl(next_control)) != GUI::gTimedZoneMap.end()) {
                
                // If needed, convert next_control in samples from begining of the buffer, possible moving to 0 (if negative)
                if (convert_ts) {
                    next_control.fDate = convertUsecToSample(next_control.fDate);
                }
                     
                // Compute audio slice
                slice = int(next_control.fDate) - offset;
                computeSlice(offset, slice, inputs, outputs);
                offset += slice;
               
                // Update control
                ringbuffer_t* control_values = (*it).second;
                *((*it).first) = next_control.fValue;
                
                // Move ringbuffer pointer
                ringbuffer_read_advance(control_values, sizeof(DatedControl));
            } 
            
            // Compute last audio slice
            slice = count - offset;
            computeSlice(offset, slice, inputs, outputs);
        }

    public:

        timed_dsp(dsp* dsp):decorator_dsp(dsp), fDateUsec(0), fOffsetUsec(0), fFirstCallback(true)
        {
            fInputsSlice = new FAUSTFLOAT*[dsp->getNumInputs()];
            fOutputsSlice = new FAUSTFLOAT*[dsp->getNumOutputs()];
        }
        virtual ~timed_dsp() 
        {
            delete [] fInputsSlice;
            delete [] fOutputsSlice;
        }
        
        virtual void init(int sample_rate)
        {
            fDSP->init(sample_rate);
        }
        
        virtual void buildUserInterface(UI* ui_interface)   
        { 
            fDSP->buildUserInterface(ui_interface); 
            // Only keep zones that are in GUI::gTimedZoneMap
            fDSP->buildUserInterface(&fZoneUI);
        }
    
        virtual timed_dsp* clone()
        {
            return new timed_dsp(fDSP->clone());
        }
    
        // Default method take a timestamp at 'compute' call time
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            compute(::GetCurrentTimeInUsec(), count, inputs, outputs);
        }    
        
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            if (date_usec == -1) {
                // Timestamp is expressed in frames
                computeAux(count, inputs, outputs, false);
            } else {
                // Save the timestamp offset in the first callback
                if (fFirstCallback) {
                    fFirstCallback = false;
                    double current_date_usec = ::GetCurrentTimeInUsec();
                    fDateUsec = current_date_usec;
                    fOffsetUsec = current_date_usec - date_usec;
                }
                
                // RtMidi mode: timestamp must be converted in frames
                computeAux(count, inputs, outputs, true);
                
                // Keep call date 
                fDateUsec = date_usec + fOffsetUsec;
            }
        }
        
};

#endif
/************************** END timed-dsp.h **************************/
/************************** BEGIN dsp-adapter.h *************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __dsp_adapter__
#define __dsp_adapter__

#ifndef _WIN32
#include <alloca.h>
#endif
#include <string.h>
#include <cmath>
#include <assert.h>
#include <stdio.h>


// Adapts a DSP for a different number of inputs/outputs
class dsp_adapter : public decorator_dsp {
    
    private:
    
        FAUSTFLOAT** fAdaptedInputs;
        FAUSTFLOAT** fAdaptedOutputs;
        int fHWInputs;
        int fHWOutputs;
        int fBufferSize;
    
        void adaptBuffers(FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            for (int i = 0; i < fHWInputs; i++) {
                fAdaptedInputs[i] = inputs[i];
            }
            for (int i = 0; i < fHWOutputs; i++) {
                fAdaptedOutputs[i] = outputs[i];
            }
        }
    
    public:
    
        dsp_adapter(dsp* dsp, int hw_inputs, int hw_outputs, int buffer_size):decorator_dsp(dsp)
        {
            fHWInputs = hw_inputs;
            fHWOutputs = hw_outputs;
            fBufferSize = buffer_size;
            
            fAdaptedInputs = new FAUSTFLOAT*[dsp->getNumInputs()];
            for (int i = 0; i < dsp->getNumInputs() - fHWInputs; i++) {
                fAdaptedInputs[i + fHWInputs] = new FAUSTFLOAT[buffer_size];
                memset(fAdaptedInputs[i + fHWInputs], 0, sizeof(FAUSTFLOAT) * buffer_size);
            }
            
            fAdaptedOutputs = new FAUSTFLOAT*[dsp->getNumOutputs()];
            for (int i = 0; i < dsp->getNumOutputs() - fHWOutputs; i++) {
                fAdaptedOutputs[i + fHWOutputs] = new FAUSTFLOAT[buffer_size];
                memset(fAdaptedOutputs[i + fHWOutputs], 0, sizeof(FAUSTFLOAT) * buffer_size);
            }
        }
    
        virtual ~dsp_adapter()
        {
            for (int i = 0; i < fDSP->getNumInputs() - fHWInputs; i++) {
                delete [] fAdaptedInputs[i + fHWInputs];
            }
            delete [] fAdaptedInputs;
            
            for (int i = 0; i < fDSP->getNumOutputs() - fHWOutputs; i++) {
                delete [] fAdaptedOutputs[i + fHWOutputs];
            }
            delete [] fAdaptedOutputs;
        }
    
        virtual int getNumInputs() { return fHWInputs; }
        virtual int getNumOutputs() { return fHWOutputs; }
    
        virtual dsp_adapter* clone() { return new dsp_adapter(fDSP->clone(), fHWInputs, fHWOutputs, fBufferSize); }
    
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            adaptBuffers(inputs, outputs);
            fDSP->compute(date_usec, count, fAdaptedInputs, fAdaptedOutputs);
        }
    
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            adaptBuffers(inputs, outputs);
            fDSP->compute(count, fAdaptedInputs, fAdaptedOutputs);
        }
};

// Adapts a DSP for a different sample size
template <typename REAL_INT, typename REAL_EXT>
class dsp_sample_adapter : public decorator_dsp {
    
    private:
    
        REAL_INT** fAdaptedInputs;
        REAL_INT** fAdaptedOutputs;
    
        void adaptInputBuffers(int count, FAUSTFLOAT** inputs)
        {
            for (int chan = 0; chan < fDSP->getNumInputs(); chan++) {
                for (int frame = 0; frame < count; frame++) {
                    fAdaptedInputs[chan][frame] = REAL_INT(reinterpret_cast<REAL_EXT**>(inputs)[chan][frame]);
                }
            }
        }
    
        void adaptOutputsBuffers(int count, FAUSTFLOAT** outputs)
        {
            for (int chan = 0; chan < fDSP->getNumOutputs(); chan++) {
                for (int frame = 0; frame < count; frame++) {
                    reinterpret_cast<REAL_EXT**>(outputs)[chan][frame] = REAL_EXT(fAdaptedOutputs[chan][frame]);
                }
            }
        }
    
    public:
    
        dsp_sample_adapter(dsp* dsp):decorator_dsp(dsp)
        {
            fAdaptedInputs = new REAL_INT*[dsp->getNumInputs()];
            for (int i = 0; i < dsp->getNumInputs(); i++) {
                fAdaptedInputs[i] = new REAL_INT[4096];
            }
            
            fAdaptedOutputs = new REAL_INT*[dsp->getNumOutputs()];
            for (int i = 0; i < dsp->getNumOutputs(); i++) {
                fAdaptedOutputs[i] = new REAL_INT[4096];
            }
        }
    
        virtual ~dsp_sample_adapter()
        {
            for (int i = 0; i < fDSP->getNumInputs(); i++) {
                delete [] fAdaptedInputs[i];
            }
            delete [] fAdaptedInputs;
            
            for (int i = 0; i < fDSP->getNumOutputs(); i++) {
                delete [] fAdaptedOutputs[i];
            }
            delete [] fAdaptedOutputs;
        }
    
        virtual dsp_sample_adapter* clone() { return new dsp_sample_adapter(fDSP->clone()); }
    
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            assert(count <= 4096);
            adaptInputBuffers(count, inputs);
            // DSP base class uses FAUSTFLOAT** type, so reinterpret_cast has to be used even if the real DSP uses REAL_INT
            fDSP->compute(count, reinterpret_cast<FAUSTFLOAT**>(fAdaptedInputs), reinterpret_cast<FAUSTFLOAT**>(fAdaptedOutputs));
            adaptOutputsBuffers(count, outputs);
        }
    
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            assert(count <= 4096);
            adaptInputBuffers(count, inputs);
            // DSP base class uses FAUSTFLOAT** type, so reinterpret_cast has to be used even if the real DSP uses REAL_INT
            fDSP->compute(date_usec, count, reinterpret_cast<FAUSTFLOAT**>(fAdaptedInputs), reinterpret_cast<FAUSTFLOAT**>(fAdaptedOutputs));
            adaptOutputsBuffers(count, outputs);
        }
};

// Template used to specialize double parameters expressed as NUM/DENOM
template <int NUM, int DENOM>
struct Double {
    static constexpr double value() { return double(NUM)/double(DENOM); }
};

// Base class for filters
template <class fVslider0, int fVslider1>
struct Filter {
    inline int getFactor() { return fVslider1; }
};

// Identity filter: copy input to output
template <class fVslider0, int fVslider1>
struct Identity : public Filter<fVslider0, fVslider1> {
    inline int getFactor() { return fVslider1; }
    
    inline void compute(int count, FAUSTFLOAT* input0, FAUSTFLOAT* output0)
    {
        memcpy(output0, input0, count * sizeof(FAUSTFLOAT));
    }
};

// Generated with process = fi.lowpass(3, ma.SR*hslider("FCFactor", 0.4, 0.4, 0.5, 0.01)/hslider("Factor", 2, 2, 8, 1));
template <class fVslider0, int fVslider1, typename REAL>
struct LowPass3 : public Filter<fVslider0, fVslider1> {
    
    REAL fVec0[2];
    REAL fRec1[2];
    REAL fRec0[3];
    
    inline REAL LowPass3_faustpower2_f(REAL value)
    {
        return (value * value);
    }
    
    LowPass3()
    {
        for (int l0 = 0; (l0 < 2); l0 = (l0 + 1)) {
            fVec0[l0] = 0.0;
        }
        for (int l1 = 0; (l1 < 2); l1 = (l1 + 1)) {
            fRec1[l1] = 0.0;
        }
        for (int l2 = 0; (l2 < 3); l2 = (l2 + 1)) {
            fRec0[l2] = 0.0;
        }
    }
    
    inline void compute(int count, FAUSTFLOAT* input0, FAUSTFLOAT* output0)
    {
        // Computed at template specialization time
        REAL fSlow0 = std::tan((3.1415926535897931 * (REAL(fVslider0::value()) / REAL(fVslider1))));
        REAL fSlow1 = (1.0 / fSlow0);
        REAL fSlow2 = (1.0 / (((fSlow1 + 1.0000000000000002) / fSlow0) + 1.0));
        REAL fSlow3 = (1.0 / (fSlow1 + 1.0));
        REAL fSlow4 = (1.0 - fSlow1);
        REAL fSlow5 = (((fSlow1 + -1.0000000000000002) / fSlow0) + 1.0);
        REAL fSlow6 = (2.0 * (1.0 - (1.0 / LowPass3_faustpower2_f(fSlow0))));
        // Computed at runtime
        for (int i = 0; (i < count); i = (i + 1)) {
            REAL fTemp0 = REAL(input0[i]);
            fVec0[0] = fTemp0;
            fRec1[0] = (0.0 - (fSlow3 * ((fSlow4 * fRec1[1]) - (fTemp0 + fVec0[1]))));
            fRec0[0] = (fRec1[0] - (fSlow2 * ((fSlow5 * fRec0[2]) + (fSlow6 * fRec0[1]))));
            output0[i] = FAUSTFLOAT((fSlow2 * (fRec0[2] + (fRec0[0] + (2.0 * fRec0[1])))));
            fVec0[1] = fVec0[0];
            fRec1[1] = fRec1[0];
            fRec0[2] = fRec0[1];
            fRec0[1] = fRec0[0];
        }
    }
};

// Generated with process = fi.lowpass(4, ma.SR*hslider("FCFactor", 0.4, 0.4, 0.5, 0.01)/hslider("Factor", 2, 2, 8, 1));
template <class fVslider0, int fVslider1, typename REAL>
struct LowPass4 : public Filter<fVslider0, fVslider1> {
    
    REAL fRec1[3];
    REAL fRec0[3];
    
    inline REAL LowPass4_faustpower2_f(REAL value)
    {
        return (value * value);
    }
    
    LowPass4()
    {
        for (int l0 = 0; (l0 < 3); l0 = (l0 + 1)) {
            fRec1[l0] = 0.0f;
        }
        for (int l1 = 0; (l1 < 3); l1 = (l1 + 1)) {
            fRec0[l1] = 0.0f;
        }
    }
    
    inline void compute(int count, FAUSTFLOAT* input0, FAUSTFLOAT* output0)
    {
        // Computed at template specialization time
        REAL fSlow0 = std::tan((3.1415926535897931 * (REAL(fVslider0::value()) / REAL(fVslider1))));
        REAL fSlow1 = (1.0 / fSlow0);
        REAL fSlow2 = (1.0 / (((fSlow1 + 0.76536686473017945) / fSlow0) + 1.0));
        REAL fSlow3 = (1.0 / (((fSlow1 + 1.8477590650225735) / fSlow0) + 1.0));
        REAL fSlow4 = (((fSlow1 + -1.8477590650225735) / fSlow0) + 1.0);
        REAL fSlow5 = (2.0 * (1.0 - (1.0 / LowPass4_faustpower2_f(fSlow0))));
        REAL fSlow6 = (((fSlow1 + -0.76536686473017945) / fSlow0) + 1.0);
        // Computed at runtime
        for (int i = 0; (i < count); i = (i + 1)) {
            fRec1[0] = (REAL(input0[i]) - (fSlow3 * ((fSlow4 * fRec1[2]) + (fSlow5 * fRec1[1]))));
            fRec0[0] = ((fSlow3 * (fRec1[2] + (fRec1[0] + (2.0 * fRec1[1])))) - (fSlow2 * ((fSlow6 * fRec0[2]) + (fSlow5 * fRec0[1]))));
            output0[i] = FAUSTFLOAT((fSlow2 * (fRec0[2] + (fRec0[0] + (2.0 * fRec0[1])))));
            fRec1[2] = fRec1[1];
            fRec1[1] = fRec1[0];
            fRec0[2] = fRec0[1];
            fRec0[1] = fRec0[0];
        }
    }
};

// Generated with process = fi.lowpass3e(ma.SR*hslider("FCFactor", 0.4, 0.4, 0.5, 0.01)/hslider("Factor", 2, 2, 8, 1));
template <class fVslider0, int fVslider1, typename REAL>
struct LowPass3e : public Filter<fVslider0, fVslider1> {
    
    REAL fRec1[3];
    REAL fVec0[2];
    REAL fRec0[2];
    
    inline REAL LowPass3e_faustpower2_f(REAL value)
    {
        return (value * value);
    }
    
    LowPass3e()
    {
        for (int l0 = 0; (l0 < 3); l0 = (l0 + 1)) {
            fRec1[l0] = 0.0;
        }
        for (int l1 = 0; (l1 < 2); l1 = (l1 + 1)) {
            fVec0[l1] = 0.0;
        }
        for (int l2 = 0; (l2 < 2); l2 = (l2 + 1)) {
            fRec0[l2] = 0.0;
        }
    }
    
    inline void compute(int count, FAUSTFLOAT* input0, FAUSTFLOAT* output0)
    {
        // Computed at template specialization time
        REAL fSlow0 = std::tan((3.1415926535897931 * (REAL(fVslider0::value()) / REAL(fVslider1))));
        REAL fSlow1 = (1.0 / fSlow0);
        REAL fSlow2 = (1.0 / (fSlow1 + 0.82244590899881598));
        REAL fSlow3 = (0.82244590899881598 - fSlow1);
        REAL fSlow4 = (1.0 / (((fSlow1 + 0.80263676416103003) / fSlow0) + 1.4122708937742039));
        REAL fSlow5 = LowPass3e_faustpower2_f(fSlow0);
        REAL fSlow6 = (0.019809144837788999 / fSlow5);
        REAL fSlow7 = (fSlow6 + 1.1615164189826961);
        REAL fSlow8 = (((fSlow1 + -0.80263676416103003) / fSlow0) + 1.4122708937742039);
        REAL fSlow9 = (2.0 * (1.4122708937742039 - (1.0 / fSlow5)));
        REAL fSlow10 = (2.0 * (1.1615164189826961 - fSlow6));
        // Computed at runtime
        for (int i = 0; (i < count); i = (i + 1)) {
            fRec1[0] = (REAL(input0[i]) - (fSlow4 * ((fSlow8 * fRec1[2]) + (fSlow9 * fRec1[1]))));
            REAL fTemp0 = (fSlow4 * (((fSlow7 * fRec1[0]) + (fSlow10 * fRec1[1])) + (fSlow7 * fRec1[2])));
            fVec0[0] = fTemp0;
            fRec0[0] = (0.0 - (fSlow2 * ((fSlow3 * fRec0[1]) - (fTemp0 + fVec0[1]))));
            output0[i] = FAUSTFLOAT(fRec0[0]);
            fRec1[2] = fRec1[1];
            fRec1[1] = fRec1[0];
            fVec0[1] = fVec0[0];
            fRec0[1] = fRec0[0];
        }
    }
};

// Generated with process = fi.lowpass6e(ma.SR*hslider("FCFactor", 0.4, 0.4, 0.5, 0.01)/hslider("Factor", 2, 2, 8, 1));
template <class fVslider0, int fVslider1, typename REAL>
struct LowPass6e : public Filter<fVslider0, fVslider1> {
    
    REAL fRec2[3];
    REAL fRec1[3];
    REAL fRec0[3];
    
    inline REAL LowPass6e_faustpower2_f(REAL value)
    {
        return (value * value);
    }
    
    LowPass6e()
    {
        for (int l0 = 0; (l0 < 3); l0 = (l0 + 1)) {
            fRec2[l0] = 0.0;
        }
        for (int l1 = 0; (l1 < 3); l1 = (l1 + 1)) {
            fRec1[l1] = 0.0;
        }
        for (int l2 = 0; (l2 < 3); l2 = (l2 + 1)) {
            fRec0[l2] = 0.0;
        }
    }
    
    inline void compute(int count, FAUSTFLOAT* input0, FAUSTFLOAT* output0)
    {
        // Computed at template specialization time
        REAL fSlow0 = std::tan((3.1415926535897931 * (REAL(fVslider0::value()) / REAL(fVslider1))));
        REAL fSlow1 = (1.0 / fSlow0);
        REAL fSlow2 = (1.0 / (((fSlow1 + 0.16840487111358901) / fSlow0) + 1.0693584077073119));
        REAL fSlow3 = LowPass6e_faustpower2_f(fSlow0);
        REAL fSlow4 = (1.0 / fSlow3);
        REAL fSlow5 = (fSlow4 + 53.536152954556727);
        REAL fSlow6 = (1.0 / (((fSlow1 + 0.51247864188914105) / fSlow0) + 0.68962136448467504));
        REAL fSlow7 = (fSlow4 + 7.6217312988706034);
        REAL fSlow8 = (1.0 / (((fSlow1 + 0.78241304682164503) / fSlow0) + 0.24529150870616001));
        REAL fSlow9 = (9.9999997054999994e-05 / fSlow3);
        REAL fSlow10 = (fSlow9 + 0.00043322720055500002);
        REAL fSlow11 = (((fSlow1 + -0.78241304682164503) / fSlow0) + 0.24529150870616001);
        REAL fSlow12 = (2.0 * (0.24529150870616001 - fSlow4));
        REAL fSlow13 = (2.0 * (0.00043322720055500002 - fSlow9));
        REAL fSlow14 = (((fSlow1 + -0.51247864188914105) / fSlow0) + 0.68962136448467504);
        REAL fSlow15 = (2.0 * (0.68962136448467504 - fSlow4));
        REAL fSlow16 = (2.0 * (7.6217312988706034 - fSlow4));
        REAL fSlow17 = (((fSlow1 + -0.16840487111358901) / fSlow0) + 1.0693584077073119);
        REAL fSlow18 = (2.0 * (1.0693584077073119 - fSlow4));
        REAL fSlow19 = (2.0 * (53.536152954556727 - fSlow4));
        // Computed at runtime
        for (int i = 0; (i < count); i = (i + 1)) {
            fRec2[0] = (REAL(input0[i]) - (fSlow8 * ((fSlow11 * fRec2[2]) + (fSlow12 * fRec2[1]))));
            fRec1[0] = ((fSlow8 * (((fSlow10 * fRec2[0]) + (fSlow13 * fRec2[1])) + (fSlow10 * fRec2[2]))) - (fSlow6 * ((fSlow14 * fRec1[2]) + (fSlow15 * fRec1[1]))));
            fRec0[0] = ((fSlow6 * (((fSlow7 * fRec1[0]) + (fSlow16 * fRec1[1])) + (fSlow7 * fRec1[2]))) - (fSlow2 * ((fSlow17 * fRec0[2]) + (fSlow18 * fRec0[1]))));
            output0[i] = FAUSTFLOAT((fSlow2 * (((fSlow5 * fRec0[0]) + (fSlow19 * fRec0[1])) + (fSlow5 * fRec0[2]))));
            fRec2[2] = fRec2[1];
            fRec2[1] = fRec2[0];
            fRec1[2] = fRec1[1];
            fRec1[1] = fRec1[0];
            fRec0[2] = fRec0[1];
            fRec0[1] = fRec0[0];
        }
    }
};

// A "si.bus(N)" like hard-coded class
struct dsp_bus : public dsp {
    
    int fChannels;
    int fSampleRate;
    
    dsp_bus(int channels):fChannels(channels), fSampleRate(-1)
    {}
    
    virtual int getNumInputs() { return fChannels; }
    virtual int getNumOutputs() { return fChannels; }
    
    virtual int getSampleRate() { return fSampleRate; }
    
    virtual void buildUserInterface(UI* ui_interface) {}
    virtual void init(int sample_rate)
    {
        //classInit(sample_rate);
        instanceInit(sample_rate);
    }
    
    virtual void instanceInit(int sample_rate)
    {
        fSampleRate = sample_rate;
        instanceConstants(sample_rate);
        instanceResetUserInterface();
        instanceClear();
    }
    
    virtual void instanceConstants(int sample_rate) {}
    virtual void instanceResetUserInterface() {}
    virtual void instanceClear() {}
    
    virtual dsp* clone() { return new dsp_bus(fChannels); }
    
    virtual void metadata(Meta* m) {}
    
    virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
    {
        for (int chan = 0; chan < fChannels; chan++) {
            memcpy(outputs[chan], inputs[chan], sizeof(FAUSTFLOAT) * count);
        }
    }
    
    virtual void compute(double /*date_usec*/, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
    {
        compute(count, inputs, outputs);
    }
    
};

// Base class for sample-rate adapter
template <typename FILTER>
class sr_sampler : public decorator_dsp {
    
    protected:
    
        std::vector<FILTER> fInputLowPass;
        std::vector<FILTER> fOutputLowPass;
    
        inline int getFactor() { return this->fOutputLowPass[0].getFactor(); }
    
    public:
    
        sr_sampler(dsp* dsp):decorator_dsp(dsp)
        {
            for (int chan = 0; chan < fDSP->getNumInputs(); chan++) {
                fInputLowPass.push_back(FILTER());
            }
            for (int chan = 0; chan < fDSP->getNumOutputs(); chan++) {
                fOutputLowPass.push_back(FILTER());
            }
        }
};

// Down sample-rate adapter
template <typename FILTER>
class dsp_down_sampler : public sr_sampler<FILTER> {
    
    public:
    
        dsp_down_sampler(dsp* dsp):sr_sampler<FILTER>(dsp)
        {}
    
        virtual void init(int sample_rate)
        {
            this->fDSP->init(sample_rate / this->getFactor());
        }
    
        virtual void instanceInit(int sample_rate)
        {
            this->fDSP->instanceInit(sample_rate / this->getFactor());
        }
    
        virtual void instanceConstants(int sample_rate)
        {
            this->fDSP->instanceConstants(sample_rate / this->getFactor());
        }
    
        virtual dsp_down_sampler* clone() { return new dsp_down_sampler(decorator_dsp::clone()); }
    
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            int real_count = count / this->getFactor();
            
            // Adapt inputs
            FAUSTFLOAT** fInputs = (FAUSTFLOAT**)alloca(this->fDSP->getNumInputs() * sizeof(FAUSTFLOAT*));
            for (int chan = 0; chan < this->fDSP->getNumInputs(); chan++) {
                // Lowpass filtering in place on 'inputs'
                this->fInputLowPass[chan].compute(count, inputs[chan], inputs[chan]);
                // Allocate fInputs with 'real_count' frames
                fInputs[chan] = (FAUSTFLOAT*)alloca(sizeof(FAUSTFLOAT) * real_count);
                // Decimate
                for (int frame = 0; frame < real_count; frame++) {
                    fInputs[chan][frame] = inputs[chan][frame * this->getFactor()];
                }
            }
            
            // Allocate fOutputs with 'real_count' frames
            FAUSTFLOAT** fOutputs = (FAUSTFLOAT**)alloca(this->fDSP->getNumOutputs() * sizeof(FAUSTFLOAT*));
            for (int chan = 0; chan < this->fDSP->getNumOutputs(); chan++) {
                fOutputs[chan] = (FAUSTFLOAT*)alloca(sizeof(FAUSTFLOAT) * real_count);
            }
            
            // Compute at lower rate
            this->fDSP->compute(real_count, fInputs, fOutputs);
            
            // Adapt outputs
            for (int chan = 0; chan < this->fDSP->getNumOutputs(); chan++) {
                // Puts zeros
                memset(outputs[chan], 0, sizeof(FAUSTFLOAT) * count);
                for (int frame = 0; frame < real_count; frame++) {
                    // Copy one sample every 'DownFactor'
                    // Apply volume
                    //outputs[chan][frame * this->getFactor()] = fOutputs[chan][frame] * this->getFactor();
                    outputs[chan][frame * this->getFactor()] = fOutputs[chan][frame];
                }
                // Lowpass filtering in place on 'outputs'
                this->fOutputLowPass[chan].compute(count, outputs[chan], outputs[chan]);
            }
        }
    
        virtual void compute(double /*date_usec*/, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }
};

// Up sample-rate adapter
template <typename FILTER>
class dsp_up_sampler : public sr_sampler<FILTER> {
    
    public:
    
        dsp_up_sampler(dsp* dsp):sr_sampler<FILTER>(dsp)
        {}
    
        virtual void init(int sample_rate)
        {
            this->fDSP->init(sample_rate * this->getFactor());
        }
    
        virtual void instanceInit(int sample_rate)
        {
            this->fDSP->instanceInit(sample_rate * this->getFactor());
        }
    
        virtual void instanceConstants(int sample_rate)
        {
            this->fDSP->instanceConstants(sample_rate * this->getFactor());
        }
    
        virtual dsp_up_sampler* clone() { return new dsp_up_sampler(decorator_dsp::clone()); }
    
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            int real_count = count * this->getFactor();
            
            // Adapt inputs
            FAUSTFLOAT** fInputs = (FAUSTFLOAT**)alloca(this->fDSP->getNumInputs() * sizeof(FAUSTFLOAT*));
            
            for (int chan = 0; chan < this->fDSP->getNumInputs(); chan++) {
                // Allocate fInputs with 'real_count' frames
                fInputs[chan] = (FAUSTFLOAT*)alloca(sizeof(FAUSTFLOAT) * real_count);
                // Puts zeros
                memset(fInputs[chan], 0, sizeof(FAUSTFLOAT) * real_count);
                for (int frame = 0; frame < count; frame++) {
                    // Copy one sample every 'UpFactor'
                    fInputs[chan][frame * this->getFactor()] = inputs[chan][frame];
                }
                // Lowpass filtering in place on 'fInputs'
                this->fInputLowPass[chan].compute(real_count, fInputs[chan], fInputs[chan]);
            }
            
            // Allocate fOutputs with 'real_count' frames
            FAUSTFLOAT** fOutputs = (FAUSTFLOAT**)alloca(this->fDSP->getNumOutputs() * sizeof(FAUSTFLOAT*));
            
            for (int chan = 0; chan < this->fDSP->getNumOutputs(); chan++) {
                fOutputs[chan] = (FAUSTFLOAT*)alloca(sizeof(FAUSTFLOAT) * real_count);
            }
            
            // Compute at upper rate
            this->fDSP->compute(real_count, fInputs, fOutputs);
            
            // Adapt outputs
            for (int chan = 0; chan < this->fDSP->getNumOutputs(); chan++) {
                // Lowpass filtering in place on 'fOutputs'
                this->fOutputLowPass[chan].compute(real_count, fOutputs[chan], fOutputs[chan]);
                // Decimate
                for (int frame = 0; frame < count; frame++) {
                    // Apply volume
                    //outputs[chan][frame] = fOutputs[chan][frame * this->getFactor()] * this->getFactor();
                    outputs[chan][frame] = fOutputs[chan][frame * this->getFactor()];
                }
            }
        }
    
        virtual void compute(double /*date_usec*/, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }
};

// Create a UP/DS + Filter adapted DSP
template <typename REAL>
dsp* createSRAdapter(dsp* DSP, int ds = 0, int us = 0, int filter = 0)
{
    if (ds > 0) {
        switch (filter) {
            case 0:
                if (ds == 2) {
                    return new dsp_down_sampler<Identity<Double<1,1>, 2>>(DSP);
                } else if (ds == 3) {
                    return new dsp_down_sampler<Identity<Double<1,1>, 3>>(DSP);
                } else if (ds == 4) {
                    return new dsp_down_sampler<Identity<Double<1,1>, 4>>(DSP);
                } else if (ds == 8) {
                    return new dsp_down_sampler<Identity<Double<1,1>, 8>>(DSP);
                } else if (ds == 16) {
                    return new dsp_down_sampler<Identity<Double<1,1>, 16>>(DSP);
                } else if (ds == 32) {
                    return new dsp_down_sampler<Identity<Double<1,1>, 32>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : ds factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            case 1:
                if (ds == 2) {
                    return new dsp_down_sampler<LowPass3<Double<45,100>, 2, REAL>>(DSP);
                } else if (ds == 3) {
                    return new dsp_down_sampler<LowPass3<Double<45,100>, 3, REAL>>(DSP);
                } else if (ds == 4) {
                    return new dsp_down_sampler<LowPass3<Double<45,100>, 4, REAL>>(DSP);
                } else if (ds == 8) {
                    return new dsp_down_sampler<LowPass3<Double<45,100>, 8, REAL>>(DSP);
                } else if (ds == 16) {
                    return new dsp_down_sampler<LowPass3<Double<45,100>, 16, REAL>>(DSP);
                } else if (ds == 32) {
                    return new dsp_down_sampler<LowPass3<Double<45,100>, 32, REAL>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : ds factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            case 2:
                if (ds == 2) {
                    return new dsp_down_sampler<LowPass4<Double<45,100>, 2, REAL>>(DSP);
                } else if (ds == 3) {
                    return new dsp_down_sampler<LowPass4<Double<45,100>, 3, REAL>>(DSP);
                } else if (ds == 4) {
                    return new dsp_down_sampler<LowPass4<Double<45,100>, 4, REAL>>(DSP);
                } else if (ds == 8) {
                    return new dsp_down_sampler<LowPass4<Double<45,100>, 8, REAL>>(DSP);
                } else if (ds == 16) {
                    return new dsp_down_sampler<LowPass4<Double<45,100>, 16, REAL>>(DSP);
                } else if (ds == 32) {
                    return new dsp_down_sampler<LowPass4<Double<45,100>, 32, REAL>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : ds factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            case 3:
                if (ds == 2) {
                    return new dsp_down_sampler<LowPass3e<Double<45,100>, 2, REAL>>(DSP);
                } else if (ds == 3) {
                    return new dsp_down_sampler<LowPass3e<Double<45,100>, 3, REAL>>(DSP);
                } else if (ds == 4) {
                    return new dsp_down_sampler<LowPass3e<Double<45,100>, 4, REAL>>(DSP);
                } else if (ds == 8) {
                    return new dsp_down_sampler<LowPass3e<Double<45,100>, 8, REAL>>(DSP);
                } else if (ds == 16) {
                    return new dsp_down_sampler<LowPass3e<Double<45,100>, 16, REAL>>(DSP);
                } else if (ds == 32) {
                    return new dsp_down_sampler<LowPass3e<Double<45,100>, 32, REAL>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : ds factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            case 4:
                if (ds == 2) {
                    return new dsp_down_sampler<LowPass6e<Double<45,100>, 2, REAL>>(DSP);
                } else if (ds == 3) {
                    return new dsp_down_sampler<LowPass6e<Double<45,100>, 3, REAL>>(DSP);
                } else if (ds == 4) {
                    return new dsp_down_sampler<LowPass6e<Double<45,100>, 4, REAL>>(DSP);
                } else if (ds == 8) {
                    return new dsp_down_sampler<LowPass6e<Double<45,100>, 8, REAL>>(DSP);
                } else if (ds == 16) {
                    return new dsp_down_sampler<LowPass6e<Double<45,100>, 16, REAL>>(DSP);
                } else if (ds == 32) {
                    return new dsp_down_sampler<LowPass6e<Double<45,100>, 32, REAL>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : ds factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            default:
                fprintf(stderr, "ERROR : filter type must be in [0..4] range\n");
                assert(false);
                return nullptr;
        }
    } else if (us > 0) {
        
        switch (filter) {
            case 0:
                if (us == 2) {
                    return new dsp_up_sampler<Identity<Double<1,1>, 2>>(DSP);
                } else if (us == 3) {
                    return new dsp_up_sampler<Identity<Double<1,1>, 3>>(DSP);
                } else if (us == 4) {
                    return new dsp_up_sampler<Identity<Double<1,1>, 4>>(DSP);
                } else if (us == 8) {
                    return new dsp_up_sampler<Identity<Double<1,1>, 8>>(DSP);
                } else if (us == 16) {
                    return new dsp_up_sampler<Identity<Double<1,1>, 16>>(DSP);
                } else if (us == 32) {
                    return new dsp_up_sampler<Identity<Double<1,1>, 32>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : us factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            case 1:
                if (us == 2) {
                    return new dsp_up_sampler<LowPass3<Double<45,100>, 2, REAL>>(DSP);
                } else if (us == 3) {
                    return new dsp_up_sampler<LowPass3<Double<45,100>, 3, REAL>>(DSP);
                } else if (us == 4) {
                    return new dsp_up_sampler<LowPass3<Double<45,100>, 4, REAL>>(DSP);
                } else if (us == 8) {
                    return new dsp_up_sampler<LowPass3<Double<45,100>, 8, REAL>>(DSP);
                } else if (us == 16) {
                    return new dsp_up_sampler<LowPass3<Double<45,100>, 16, REAL>>(DSP);
                } else if (us == 32) {
                    return new dsp_up_sampler<LowPass3<Double<45,100>, 32, REAL>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : us factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            case 2:
                if (us == 2) {
                    return new dsp_up_sampler<LowPass4<Double<45,100>, 2, REAL>>(DSP);
                } else if (us == 3) {
                    return new dsp_up_sampler<LowPass4<Double<45,100>, 3, REAL>>(DSP);
                } else if (us == 4) {
                    return new dsp_up_sampler<LowPass4<Double<45,100>, 4, REAL>>(DSP);
                } else if (us == 8) {
                    return new dsp_up_sampler<LowPass4<Double<45,100>, 8, REAL>>(DSP);
                } else if (us == 16) {
                    return new dsp_up_sampler<LowPass4<Double<45,100>, 16, REAL>>(DSP);
                } else if (us == 32) {
                    return new dsp_up_sampler<LowPass4<Double<45,100>, 32, REAL>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : us factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            case 3:
                if (us == 2) {
                    return new dsp_up_sampler<LowPass3e<Double<45,100>, 2, REAL>>(DSP);
                } else if (us == 3) {
                    return new dsp_up_sampler<LowPass3e<Double<45,100>, 3, REAL>>(DSP);
                } else if (us == 4) {
                    return new dsp_up_sampler<LowPass3e<Double<45,100>, 4, REAL>>(DSP);
                } else if (us == 8) {
                    return new dsp_up_sampler<LowPass3e<Double<45,100>, 8, REAL>>(DSP);
                } else if (us == 16) {
                    return new dsp_up_sampler<LowPass3e<Double<45,100>, 16, REAL>>(DSP);
                } else if (us == 32) {
                    return new dsp_up_sampler<LowPass3e<Double<45,100>, 32, REAL>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : us factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            case 4:
                if (us == 2) {
                    return new dsp_up_sampler<LowPass6e<Double<45,100>, 2, REAL>>(DSP);
                } else if (us == 3) {
                    return new dsp_up_sampler<LowPass6e<Double<45,100>, 3, REAL>>(DSP);
                } else if (us == 4) {
                    return new dsp_up_sampler<LowPass6e<Double<45,100>, 4, REAL>>(DSP);
                } else if (us == 8) {
                    return new dsp_up_sampler<LowPass6e<Double<45,100>, 8, REAL>>(DSP);
                } else if (us == 16) {
                    return new dsp_up_sampler<LowPass6e<Double<45,100>, 16, REAL>>(DSP);
                } else if (us == 32) {
                    return new dsp_up_sampler<LowPass6e<Double<45,100>, 32, REAL>>(DSP);
                } else {
                    fprintf(stderr, "ERROR : us factor type must be in [2..32] range\n");
                    assert(false);
                    return nullptr;
                }
            default:
                fprintf(stderr, "ERROR : filter type must be in [0..4] range\n");
                assert(false);
                return nullptr;
        }
    } else {
        return DSP;
    }
}
    
#endif
/************************** END dsp-adapter.h **************************/
/************************** BEGIN FUI.h *****************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ***********************************************************************/

#ifndef FAUST_FUI_H
#define FAUST_FUI_H

#include <string>
#include <map>
#include <set>
#include <vector>
#include <stack>
#include <iostream>
#include <fstream>


/*******************************************************************************
 * FUI : used to save and recall the state of the user interface
 * This class provides essentially two new methods saveState() and recallState()
 * used to save on file and recall from file the state of the user interface.
 * The file is human readable and editable
 ******************************************************************************/

class FUI : public UI, public PathBuilder
{

    protected:

        std::map<std::string, FAUSTFLOAT*> fName2Zone;
        std::vector<FAUSTFLOAT*> fButtons;

        // add an element by relating its full name and memory zone
        virtual void addElement(const char* label, FAUSTFLOAT* zone, bool button = false)
        {
            std::string path = buildPath(label);
            fName2Zone[path] = zone;
            if (button) {
                fButtons.push_back(zone);
            }
        }

    
    public:

        FUI() {}
        virtual ~FUI() {}

        // -- Save and recall methods

        // save the zones values and full names
        virtual void saveState(const char* filename)
        {
            std::ofstream file(filename);
            if (file.is_open()) {
                for (const auto& it : fName2Zone) {
                    file << *it.second << ' ' << it.first << std::endl;
                }
                file.close();
            } else {
                std::cerr << "Error opening " << filename << " file\n";
            }
        }

        // recall the zones values and full names
        virtual void recallState(const char* filename)
        {
            std::ifstream file(filename);
            FAUSTFLOAT value;
            std::string path1, path2;
            while (file.good()) {
                file >> value >> path1;
                path2 = "/" + path1;
                if (fName2Zone.count(path1) > 0) {          // Old path system
                    *(fName2Zone[path1]) = value;
                } else if (fName2Zone.count(path2) > 0) {   // New path system with the starting '/'
                    *(fName2Zone[path2]) = value;
                } else if (path1.size() > 0) {
                    std::cerr << "recallState : parameter not found : " << path1 << " with value : " << value << std::endl;
                }
            }
            file.close();
        }

        void setButtons(bool state)
        {
            for (size_t i = 0; i < fButtons.size(); i++) {
                *fButtons[i] = state;
            }
        }

        // -- widget's layouts (just keep track of group labels)

        virtual void openTabBox(const char* label) { pushLabel(label); }
        virtual void openHorizontalBox(const char* label) { pushLabel(label);; }
        virtual void openVerticalBox(const char* label) { pushLabel(label); }
        virtual void closeBox() { popLabel(); };

        // -- active widgets (just add an element)

        virtual void addButton(const char* label, FAUSTFLOAT* zone) { addElement(label, zone, true); }
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone) { addElement(label, zone); }
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT, FAUSTFLOAT, FAUSTFLOAT, FAUSTFLOAT)
                                                                    { addElement(label, zone); }
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT, FAUSTFLOAT, FAUSTFLOAT, FAUSTFLOAT)
                                                                    { addElement(label, zone); }
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT, FAUSTFLOAT, FAUSTFLOAT, FAUSTFLOAT)
                                                                    { addElement(label, zone); }

        // -- passive widgets (are ignored)

        virtual void addHorizontalBargraph(const char*, FAUSTFLOAT*, FAUSTFLOAT, FAUSTFLOAT) {}
        virtual void addVerticalBargraph(const char*, FAUSTFLOAT*, FAUSTFLOAT, FAUSTFLOAT) {}
    
        // -- soundfiles
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}

        // -- metadata are not used

        virtual void declare(FAUSTFLOAT*, const char*, const char*) {}

};

#endif

/**************************  END  FUI.h **************************/
/************************** BEGIN PresetUI.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/
 
#ifndef __PresetUI_H__
#define __PresetUI_H__

#include <string>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <sys/stat.h>


/*
 Decorates an UI to add preset management:
 - a 'preset' num entry allows to select a given preset
 - a 'load' button restores the state of the currently selected preset
 - a 'save' button saves the state of the currently selected preset
 - a 'reset' button restores te UI default state
 Presets are saved in separated text files using the FUI model.
*/

class PresetUI : public DecoratorUI {
    
  private:
    
    struct LoaderUI : public GUI
    {
        LoaderUI(PresetUI* presetui)
        {
            // uiCallbackItem(s) are deleted in GUI
            new uiCallbackItem(this, &presetui->fLoad, PresetUI::load, presetui);
            new uiCallbackItem(this, &presetui->fSave, PresetUI::save, presetui);
            new uiCallbackItem(this, &presetui->fReset, PresetUI::reset, presetui);
        }
    };
    
    int fGroupCount;
    FAUSTFLOAT fPreset;
    FAUSTFLOAT fLoad;
    FAUSTFLOAT fSave;
    FAUSTFLOAT fReset;
    FUI fFileUI;
    LoaderUI fLoaderUI;
    const std::string fRootPath;

    static std::string appendSlashIfMissing(const std::string& path)
    {
        return (path[path.size() - 1] != '/') ? (path + "/") : path;
    }
  
    static bool tryCreateSubdirectory(const std::string& base_dir, const std::string& sub_dir, std::string& out_dir)
    {
        if ((base_dir.size() > 0) && (sub_dir.size() > 0)) {
            out_dir = base_dir + sub_dir;
            if (tryCreateDirectory(out_dir)) {
                std::cout << "Using " << base_dir << "/" << sub_dir << ": " << out_dir << std::endl;
                return true;
            } else {
                std::cout << "Cannot use " << base_dir << "/" << sub_dir << std::endl;
            }
        }
        return false;
    }
    
    static bool tryCreateDirFromEnv(const std::string& env_var_name, std::string& out_dir)
    {
        const char* dir = getenv(env_var_name.c_str());
        if (dir && tryCreateDirectory(dir)) {
            std::cout << "Using " << env_var_name << ": " << dir << "." << std::endl;
            out_dir = appendSlashIfMissing(dir);
            return true;
        } else {
            std::cout << "Cannot use " << env_var_name <<  "." << std::endl;
            return false;
        }
    }

    static void load(FAUSTFLOAT val, void* arg)
    {
        if (val == FAUSTFLOAT(1)) {
            static_cast<PresetUI*>(arg)->loadState();
        }
    }

    static void save(FAUSTFLOAT val, void* arg)
    {
        if (val == FAUSTFLOAT(1)) {
            static_cast<PresetUI*>(arg)->saveState();
        }
    }

    static void reset(FAUSTFLOAT val, void* arg)
    {
        if (val == FAUSTFLOAT(1)) {
            static_cast<PresetUI*>(arg)->loadDefault();
        }
    }

    void checkOpenFirstBox(const char* label)
    {
        if (fGroupCount++ == 0) {
            // Start of top-level group
            fUI->openHorizontalBox("Preset manager");
            fUI->addButton("Save", &fSave);
            fUI->addNumEntry("Preset", &fPreset, FAUSTFLOAT(0), FAUSTFLOAT(0), FAUSTFLOAT(100), FAUSTFLOAT(1));
            fUI->addButton("Load", &fLoad);
            fUI->addButton("Reset", &fReset);
            fUI->closeBox();
        }
    }
    
  public:

    PresetUI(UI* ui, const std::string& path):
        DecoratorUI(ui),
        fGroupCount(0),
        fPreset(FAUSTFLOAT(0)),
        fSave(FAUSTFLOAT(0)),
        fLoad(FAUSTFLOAT(0)),
        fReset(FAUSTFLOAT(0)),
        fLoaderUI(this),
        fRootPath(path)
        {}
    
    virtual ~PresetUI()
    {}

    void saveDefault()
    {
        fFileUI.saveState((fRootPath + "default").c_str());
    }
    
    void loadDefault()
    {
        fFileUI.recallState((fRootPath + "default").c_str());
    }

    void saveState()
    {
        fFileUI.saveState((fRootPath + "preset" + std::to_string(fPreset)).c_str());
    }

    void loadState()
    {
        fFileUI.recallState((fRootPath + "preset" + std::to_string(fPreset)).c_str());
    }

    // -- widget's layouts
    virtual void openTabBox(const char* label)
    {
        checkOpenFirstBox(label);
        fUI->openTabBox(label);
        fFileUI.openTabBox(label);
    }
    virtual void openHorizontalBox(const char* label)
    {
        checkOpenFirstBox(label);
        fUI->openHorizontalBox(label);
        fFileUI.openHorizontalBox(label);
    }
    virtual void openVerticalBox(const char* label)
    {
        checkOpenFirstBox(label);
        fUI->openVerticalBox(label);
        fFileUI.openVerticalBox(label);
    }
    virtual void closeBox()
    {
        fUI->closeBox();
        if (--fGroupCount == 0) {
            // End of top-level group
            saveDefault();
        }
    }

    // -- active widgets
    virtual void addButton(const char* label, FAUSTFLOAT* zone)
    {
        fUI->addButton(label, zone);
        fFileUI.addButton(label, zone);
    }
    virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)
    {
        fUI->addCheckButton(label, zone);
        fFileUI.addCheckButton(label, zone);
    }
    virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
    {
        fUI->addVerticalSlider(label, zone, init, min, max, step);
        fFileUI.addVerticalSlider(label, zone, init, min, max, step);
    }
    virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
    {
        fUI->addHorizontalSlider(label, zone, init, min, max, step);
        fFileUI.addHorizontalSlider(label, zone, init, min, max, step);
    }
    virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
    {
        fUI->addNumEntry(label, zone, init, min, max, step);
        fFileUI.addNumEntry(label, zone, init, min, max, step);
    }
    
    // -- passive widgets
    virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
    {
        fUI->addHorizontalBargraph(label, zone, min, max);
        fFileUI.addHorizontalBargraph(label, zone, min, max);
    }
    virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
    {
        fUI->addVerticalBargraph(label, zone, min, max);
        fFileUI.addVerticalBargraph(label, zone, min, max);
    }
    
    // -- soundfiles
    virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone)
    {
        fUI->addSoundfile(label, filename, sf_zone);
        fFileUI.addSoundfile(label, filename, sf_zone);
    }
    
    virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val)
    {
        fUI->declare(zone, key, val);
        fFileUI.declare(zone, key, val);
    }
      
    static bool tryCreateDirectory(const std::string& out_dir)
    {
        if (out_dir.size() > 0) {
            struct stat stat_buffer;
            if (stat(out_dir.c_str(), &stat_buffer) != 0) {
                if (mkdir(out_dir.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) == 0) {
                    std::cout << "Directory created: " << out_dir << std::endl;
                    return true;
                } else {
                    std::cerr << "Error creating directory: " << strerror(errno) << std::endl;
                }
            } else {
                return true;
            }
        }
        return false;
    }
    
    /*
     getPresetDir attempts to determine a suitable preset directory using the following logic:
     
     1) If PRESETDIR is "auto", it tries to create a directory using the XDG_DOCUMENTS_DIR environment variable.
     2) If PRESETDIR is a valid existing directory, it returns the path with a trailing slash.
     3) If PRESETDIR is an environment variable, it tries to create a directory using its value.
     4) If HOME is set, it tries to create a directory at HOME/Documents or HOME/PRESETDIR.
     5) If all else fails, it falls back to /var/tmp/.
     */
    
    static std::string getPresetDir()
    {
        std::string preset_dir;
        
        std::cout << "Attempting to find or create a suitable directory for preset files." << std::endl;
        // If the user passes -preset auto
        if (std::string(PRESETDIR) == "auto") {
            std::cout << "Attempting to create directory using XDG_DOCUMENTS_DIR environment variable." << std::endl;
            if (tryCreateDirFromEnv("XDG_DOCUMENTS_DIR", preset_dir)) {
                return preset_dir;
            }
        }
        
        // Interpret what the user gave us as a path
        struct stat stat_buffer;
        // See if that path exists and is a directory
        if (stat(PRESETDIR, &stat_buffer) == 0 && S_ISDIR(stat_buffer.st_mode)) {
            std::cout << "Directory " << PRESETDIR << " exists and is a valid directory." << std::endl;
            // We are done
            return appendSlashIfMissing(PRESETDIR);
        }
        
        // PRESETDIR doesn't exists or is not a directory
        std::cout << "Directory " << PRESETDIR << " doesn't exist or is not a valid directory." << std::endl;
        
        // Interpret PRESETDIR as an environment variable
        std::cout << "Attempting to create directory using PRESETDIR environment variable." << std::endl;
        if (tryCreateDirFromEnv(PRESETDIR, preset_dir)) {
            return preset_dir;
        }
        
        std::cout << "No usable XDG_DOCUMENTS_DIR, " << PRESETDIR << " is not a valid directory nor a usable environment variable.\n";
        preset_dir = appendSlashIfMissing(getenv("HOME"));
    
        // Try HOME/Documents
        std::string home_preset_dir1;
        if (tryCreateSubdirectory(preset_dir, "Documents", home_preset_dir1)) {
            return home_preset_dir1;
        }
        
        // Try HOME/PRESETDIR
        std::string home_preset_dir2;
        if (tryCreateSubdirectory(preset_dir, PRESETDIR, home_preset_dir2)) {
            return home_preset_dir2;
        }
        
        // Fallback to /var/tmp/
        std::cout << "No suitable directory found, falling back to /var/tmp/" << std::endl;
        preset_dir = "/var/tmp/";
        return preset_dir;
    }
    
};

#endif
/**************************  END  PresetUI.h **************************/
/************************** BEGIN GTKUI.h ****************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 *************************************************************************/

#ifndef FAUST_GTKUI_H
#define FAUST_GTKUI_H

/******************************************************************************
 *******************************************************************************

 GRAPHIC USER INTERFACE
 gtk interface

 *******************************************************************************
 *******************************************************************************/
#include <set>
#include <string>

#include <math.h>
#include <stdlib.h>
#include <string.h>

#include <algorithm>
#include <assert.h>
#include <gdk/gdkkeysyms.h>
#include <gtk/gtk.h>


#define kStackSize 256

// Insertion modes

#define kSingleMode 0
#define kBoxMode 1
#define kTabMode 2

//------------ calculate needed precision
static int precision(double n)
{
    if (n < 0.009999)
        return 3;
    else if (n < 0.099999)
        return 2;
    else if (n < 0.999999)
        return 1;
    else
        return 0;
}

namespace gtk_knob {

class GtkKnob {
   private:
   public:
    GtkRange parent;
    int      last_quadrant;
    GtkKnob();
    ~GtkKnob();
    GtkWidget* gtk_knob_new_with_adjustment(GtkAdjustment* _adjustment);
};

#define GTK_TYPE_KNOB (gtk_knob_get_type())
#define GTK_KNOB(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GTK_TYPE_KNOB, GtkKnob))
#define GTK_IS_KNOB(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), GTK_TYPE_KNOB))
#define GTK_KNOB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), GTK_TYPE_KNOB, GtkKnobClass))
#define GTK_IS_KNOB_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass), GTK_TYPE_KNOB))

GtkKnob::GtkKnob()
// GtkKnob constructor
{
}

GtkKnob::~GtkKnob()
{
    // Nothing specific to do...
}

struct GtkKnobClass {
    GtkRangeClass parent_class;
    int           knob_x;
    int           knob_y;
    int           knob_step;
    int           button_is;
};

//------forward declaration
GType gtk_knob_get_type();

/****************************************************************
 ** calculate the knop pointer with dead zone
 */

const double scale_zero = 20 * (M_PI / 180);  // defines "dead zone" for knobs

static void knob_expose(GtkWidget* widget, int knob_x, int knob_y, GdkEventExpose* event, int arc_offset)
{
    /** check resize **/
    int grow;
    if (widget->allocation.width > widget->allocation.height) {
        grow = widget->allocation.height;
    } else {
        grow = widget->allocation.width;
    }
    knob_x = grow - 4;
    knob_y = grow - 4;
    /** get values for the knob **/
    GtkAdjustment* adj         = gtk_range_get_adjustment(GTK_RANGE(widget));
    int            knobx       = (widget->allocation.x + 2 + (widget->allocation.width - 4 - knob_x) * 0.5);
    int            knoby       = (widget->allocation.y + 2 + (widget->allocation.height - 4 - knob_y) * 0.5);
    int            knobx1      = (widget->allocation.x + 2 + (widget->allocation.width - 4) * 0.5);
    int            knoby1      = (widget->allocation.y + 2 + (widget->allocation.height - 4) * 0.5);
    double         knobstate   = (adj->value - adj->lower) / (adj->upper - adj->lower);
    double         angle       = scale_zero + knobstate * 2 * (M_PI - scale_zero);
    double         knobstate1  = (0. - adj->lower) / (adj->upper - adj->lower);
    double         pointer_off = knob_x / 6;
    double         radius      = std::min<double>(knob_x - pointer_off, knob_y - pointer_off) / 2;
    double         lengh_x     = (knobx + radius + pointer_off / 2) - radius * sin(angle);
    double         lengh_y     = (knoby + radius + pointer_off / 2) + radius * cos(angle);
    double         radius1     = std::min<double>(knob_x, knob_y) / 2;

    /** get widget forground color convert to cairo **/
    GtkStyle* style = gtk_widget_get_style(widget);
    double    r     = std::min<double>(0.6, style->fg[gtk_widget_get_state(widget)].red / 65535.0),
           g        = std::min<double>(0.6, style->fg[gtk_widget_get_state(widget)].green / 65535.0),
           b        = std::min<double>(0.6, style->fg[gtk_widget_get_state(widget)].blue / 65535.0);

    /** paint focus **/
    if (GTK_WIDGET_HAS_FOCUS(widget)) {
        gtk_paint_focus(widget->style, widget->window, GTK_STATE_NORMAL, NULL, widget, NULL, knobx - 2, knoby - 2,
                        knob_x + 4, knob_y + 4);
    }
    /** create clowing knobs with cairo **/
    cairo_t*   cr = gdk_cairo_create(GDK_DRAWABLE(widget->window));
    GdkRegion* region;
    region = gdk_region_rectangle(&widget->allocation);
    gdk_region_intersect(region, event->region);
    gdk_cairo_region(cr, region);
    cairo_clip(cr);

    cairo_arc(cr, knobx1 + arc_offset, knoby1 + arc_offset, knob_x / 2.1, 0, 2 * M_PI);
    cairo_pattern_t* pat =
        cairo_pattern_create_radial(knobx1 + arc_offset - knob_x / 6, knoby1 + arc_offset - knob_x / 6, 1,
                                    knobx1 + arc_offset, knoby1 + arc_offset, knob_x / 2.1);
    if (adj->lower < 0 && adj->value > 0.) {
        cairo_pattern_add_color_stop_rgb(pat, 0, r + 0.4, g + 0.4 + knobstate - knobstate1, b + 0.4);
        cairo_pattern_add_color_stop_rgb(pat, 0.7, r + 0.15, g + 0.15 + (knobstate - knobstate1) * 0.5, b + 0.15);
        cairo_pattern_add_color_stop_rgb(pat, 1, r, g, b);
    } else if (adj->lower < 0 && adj->value <= 0.) {
        cairo_pattern_add_color_stop_rgb(pat, 0, r + 0.4 + knobstate1 - knobstate, g + 0.4, b + 0.4);
        cairo_pattern_add_color_stop_rgb(pat, 0.7, r + 0.15 + (knobstate1 - knobstate) * 0.5, g + 0.15, b + 0.15);
        cairo_pattern_add_color_stop_rgb(pat, 1, r, g, b);
    } else {
        cairo_pattern_add_color_stop_rgb(pat, 0, r + 0.4, g + 0.4 + knobstate, b + 0.4);
        cairo_pattern_add_color_stop_rgb(pat, 0.7, r + 0.15, g + 0.15 + knobstate * 0.5, b + 0.15);
        cairo_pattern_add_color_stop_rgb(pat, 1, r, g, b);
    }
    cairo_set_source(cr, pat);
    cairo_fill_preserve(cr);
    gdk_cairo_set_source_color(cr, gtk_widget_get_style(widget)->fg);
    cairo_set_line_width(cr, 2.0);
    cairo_stroke(cr);

    /** create a rotating pointer on the kob**/
    cairo_set_source_rgb(cr, 0.1, 0.1, 0.1);
    cairo_set_line_width(cr, std::max<double>(3, std::min<double>(7, knob_x / 15)));
    cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);
    cairo_set_line_join(cr, CAIRO_LINE_JOIN_BEVEL);
    cairo_move_to(cr, knobx + radius1, knoby + radius1);
    cairo_line_to(cr, lengh_x, lengh_y);
    cairo_stroke(cr);
    cairo_set_source_rgb(cr, 0.9, 0.9, 0.9);
    cairo_set_line_width(cr, std::min<double>(5, std::max<double>(1, knob_x / 30)));
    cairo_move_to(cr, knobx + radius1, knoby + radius1);
    cairo_line_to(cr, lengh_x, lengh_y);
    cairo_stroke(cr);
    cairo_pattern_destroy(pat);
    gdk_region_destroy(region);
    cairo_destroy(cr);
}

/****************************************************************
 ** general expose events for all "knob" controllers
 */

//----------- draw the Knob when moved
static gboolean gtk_knob_expose(GtkWidget* widget, GdkEventExpose* event)
{
    g_assert(GTK_IS_KNOB(widget));
    GtkKnobClass* klass = GTK_KNOB_CLASS(GTK_OBJECT_GET_CLASS(widget));
    knob_expose(widget, klass->knob_x, klass->knob_y, event, 0);
    return true;
}

/****************************************************************
 ** set initial size for GdkDrawable per type
 */

static void gtk_knob_size_request(GtkWidget* widget, GtkRequisition* requisition)
{
    g_assert(GTK_IS_KNOB(widget));
    GtkKnobClass* klass = GTK_KNOB_CLASS(GTK_OBJECT_GET_CLASS(widget));
    requisition->width  = klass->knob_x;
    requisition->height = klass->knob_y;
}

/****************************************************************
 ** set value from key bindings
 */

static void gtk_knob_set_value(GtkWidget* widget, int dir_down)
{
    g_assert(GTK_IS_KNOB(widget));

    GtkAdjustment* adj = gtk_range_get_adjustment(GTK_RANGE(widget));

    int oldstep = (int)(0.5f + (adj->value - adj->lower) / adj->step_increment);
    int step;
    int nsteps = (int)(0.5f + (adj->upper - adj->lower) / adj->step_increment);
    if (dir_down) {
        step = oldstep - 1;
    } else {
        step = oldstep + 1;
    }
    FAUSTFLOAT value = adj->lower + step * double(adj->upper - adj->lower) / nsteps;
    gtk_widget_grab_focus(widget);
    gtk_range_set_value(GTK_RANGE(widget), value);
}

/****************************************************************
 ** keyboard bindings
 */

static gboolean gtk_knob_key_press(GtkWidget* widget, GdkEventKey* event)
{
    g_assert(GTK_IS_KNOB(widget));

    GtkAdjustment* adj = gtk_range_get_adjustment(GTK_RANGE(widget));
    switch (event->keyval) {
        case GDK_Home:
            gtk_range_set_value(GTK_RANGE(widget), adj->lower);
            return true;
        case GDK_End:
            gtk_range_set_value(GTK_RANGE(widget), adj->upper);
            return true;
        case GDK_Up:
            gtk_knob_set_value(widget, 0);
            return true;
        case GDK_Right:
            gtk_knob_set_value(widget, 0);
            return true;
        case GDK_Down:
            gtk_knob_set_value(widget, 1);
            return true;
        case GDK_Left:
            gtk_knob_set_value(widget, 1);
            return true;
    }

    return false;
}

/****************************************************************
 ** alternative (radial) knob motion mode (ctrl + mouse pressed)
 */

static void knob_pointer_event(GtkWidget* widget, gdouble x, gdouble y, int knob_x, int knob_y, bool drag, int state)
{
    static double  last_y = 2e20;
    GtkKnob*       knob   = GTK_KNOB(widget);
    GtkAdjustment* adj    = gtk_range_get_adjustment(GTK_RANGE(widget));
    double         radius = std::min<double>(knob_x, knob_y) / 2;
    int            knobx  = (widget->allocation.width - knob_x) / 2;
    int            knoby  = (widget->allocation.height - knob_y) / 2;
    double         posx   = (knobx + radius) - x;  // x axis right -> left
    double         posy   = (knoby + radius) - y;  // y axis top -> bottom
    double         value;
    if (!drag) {
        if (state & GDK_CONTROL_MASK) {
            last_y = 2e20;
            return;
        } else {
            last_y = posy;
        }
    }
    if (last_y < 1e20) {  // in drag started with Control Key
        const double scaling = 0.005;
        double       scal    = (state & GDK_SHIFT_MASK ? scaling * 0.1 : scaling);
        value                = (last_y - posy) * scal;
        last_y               = posy;
        gtk_range_set_value(GTK_RANGE(widget), adj->value - value * (adj->upper - adj->lower));
        return;
    }

    double angle = atan2(-posx, posy) + M_PI;  // clockwise, zero at 6 o'clock, 0 .. 2*M_PI
    if (drag) {
        // block "forbidden zone" and direct moves between quadrant 1 and 4
        int quadrant = 1 + int(angle / M_PI_2);
        if (knob->last_quadrant == 1 && (quadrant == 3 || quadrant == 4)) {
            angle = scale_zero;
        } else if (knob->last_quadrant == 4 && (quadrant == 1 || quadrant == 2)) {
            angle = 2 * M_PI - scale_zero;
        } else {
            if (angle < scale_zero) {
                angle = scale_zero;
            } else if (angle > 2 * M_PI - scale_zero) {
                angle = 2 * M_PI - scale_zero;
            }
            knob->last_quadrant = quadrant;
        }
    } else {
        if (angle < scale_zero) {
            angle = scale_zero;
        } else if (angle > 2 * M_PI - scale_zero) {
            angle = 2 * M_PI - scale_zero;
        }
        knob->last_quadrant = 0;
    }
    angle = (angle - scale_zero) / (2 * (M_PI - scale_zero));  // normalize to 0..1
    gtk_range_set_value(GTK_RANGE(widget), adj->lower + angle * (adj->upper - adj->lower));
}

/****************************************************************
 ** mouse button pressed set value
 */

static gboolean gtk_knob_button_press(GtkWidget* widget, GdkEventButton* event)
{
    g_assert(GTK_IS_KNOB(widget));

    GtkKnobClass* klass = GTK_KNOB_CLASS(GTK_OBJECT_GET_CLASS(widget));

    switch (event->button) {
        case 1:  // left button
            gtk_widget_grab_focus(widget);
            gtk_widget_grab_default(widget);
            gtk_grab_add(widget);
            klass->button_is = 1;
            knob_pointer_event(widget, event->x, event->y, klass->knob_x, klass->knob_y, false, event->state);
            break;
        case 2:  // wheel
            klass->button_is = 2;
            break;
        case 3:  // right button
            klass->button_is = 3;
            break;
        default:  // do nothing
            break;
    }
    return true;
}

/****************************************************************
 ** mouse button release
 */

static gboolean gtk_knob_button_release(GtkWidget* widget, GdkEventButton* event)
{
    g_assert(GTK_IS_KNOB(widget));
    GTK_KNOB_CLASS(GTK_OBJECT_GET_CLASS(widget))->button_is = 0;
    if (GTK_WIDGET_HAS_GRAB(widget)) gtk_grab_remove(widget);
    return false;
}

/****************************************************************
 ** set the value from mouse movement
 */

static gboolean gtk_knob_pointer_motion(GtkWidget* widget, GdkEventMotion* event)
{
    g_assert(GTK_IS_KNOB(widget));
    GtkKnobClass* klass = GTK_KNOB_CLASS(GTK_OBJECT_GET_CLASS(widget));

    gdk_event_request_motions(event);

    if (GTK_WIDGET_HAS_GRAB(widget)) {
        knob_pointer_event(widget, event->x, event->y, klass->knob_x, klass->knob_y, true, event->state);
    }
    return false;
}

/****************************************************************
 ** set value from mouseweel
 */

static gboolean gtk_knob_scroll(GtkWidget* widget, GdkEventScroll* event)
{
    usleep(5000);
    gtk_knob_set_value(widget, event->direction);
    return false;
}

/****************************************************************
 ** init the GtkKnobClass
 */

static void gtk_knob_class_init(GtkKnobClass* klass)
{
    GtkWidgetClass* widget_class = GTK_WIDGET_CLASS(klass);

    /** set here the sizes and steps for the used knob **/
    //--------- small knob size and steps

    klass->knob_x    = 30;
    klass->knob_y    = 30;
    klass->knob_step = 86;

    //--------- event button
    klass->button_is = 0;

    //--------- connect the events with funktions
    widget_class->expose_event         = gtk_knob_expose;
    widget_class->size_request         = gtk_knob_size_request;
    widget_class->button_press_event   = gtk_knob_button_press;
    widget_class->button_release_event = gtk_knob_button_release;
    widget_class->motion_notify_event  = gtk_knob_pointer_motion;
    widget_class->key_press_event      = gtk_knob_key_press;
    widget_class->scroll_event         = gtk_knob_scroll;
}

/****************************************************************
 ** init the Knob type/size
 */

static void gtk_knob_init(GtkKnob* knob)
{
    GtkWidget*    widget = GTK_WIDGET(knob);
    GtkKnobClass* klass  = GTK_KNOB_CLASS(GTK_OBJECT_GET_CLASS(widget));

    GTK_WIDGET_SET_FLAGS(GTK_WIDGET(knob), GTK_CAN_FOCUS);
    GTK_WIDGET_SET_FLAGS(GTK_WIDGET(knob), GTK_CAN_DEFAULT);

    widget->requisition.width  = klass->knob_x;
    widget->requisition.height = klass->knob_y;
}

/****************************************************************
 ** redraw when value changed
 */

static gboolean gtk_knob_value_changed(gpointer obj)
{
    GtkWidget* widget = (GtkWidget*)obj;
    gtk_widget_queue_draw(widget);
    return false;
}

/****************************************************************
 ** create small knob
 */

GtkWidget* GtkKnob::gtk_knob_new_with_adjustment(GtkAdjustment* _adjustment)
{
    GtkWidget* widget   = GTK_WIDGET(g_object_new(GTK_TYPE_KNOB, NULL));
    GtkKnob*   knob     = GTK_KNOB(widget);
    knob->last_quadrant = 0;
    if (widget) {
        gtk_range_set_adjustment(GTK_RANGE(widget), _adjustment);
        g_signal_connect(GTK_OBJECT(widget), "value-changed", G_CALLBACK(gtk_knob_value_changed), widget);
    }
    return widget;
}

/****************************************************************
 ** get the Knob type
 */

GType gtk_knob_get_type(void)
{
    static GType kn_type = 0;
    if (!kn_type) {
        static const GTypeInfo kn_info = {sizeof(GtkKnobClass),
                                          NULL,
                                          NULL,
                                          (GClassInitFunc)gtk_knob_class_init,
                                          NULL,
                                          NULL,
                                          sizeof(GtkKnob),
                                          0,
                                          (GInstanceInitFunc)gtk_knob_init,
                                          NULL};
        kn_type                        = g_type_register_static(GTK_TYPE_RANGE, "GtkKnob", &kn_info, (GTypeFlags)0);
    }
    return kn_type;
}
}  // namespace gtk_knob

gtk_knob::GtkKnob myGtkKnob;

class GTKUI : public GUI, public MetaDataUI {
   protected:
    GtkWidget* fWindow;
    GtkWidget* fScrolledWindow;
    int        fTop;
    GtkWidget* fBox[kStackSize];
    int        fMode[kStackSize];

    GtkWidget*   addWidget(const char* label, GtkWidget* w);
    virtual void pushBox(int mode, GtkWidget* w);

   public:
    static const gboolean expand   = true;
    static const gboolean fill     = true;
    static const gboolean homogene = false;
    static gboolean       gInitialized;

    GTKUI(char* name, int* pargc, char*** pargv);

    // -- Labels and metadata

    virtual void declare(FAUSTFLOAT* zone, const char* key, const char* value);
    virtual int  checkLabelOptions(GtkWidget* widget, const std::string& fullLabel, std::string& simplifiedLabel);
    virtual void checkForTooltip(FAUSTFLOAT* zone, GtkWidget* widget);

    // -- layout groups

    virtual void openTabBox(const char* label = "");
    virtual void openHorizontalBox(const char* label = "");
    virtual void openVerticalBox(const char* label = "");
    virtual void closeBox();

    // -- active widgets

    virtual void addButton(const char* label, FAUSTFLOAT* zone);
    virtual void addCheckButton(const char* label, FAUSTFLOAT* zone);
    virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max,
                                   FAUSTFLOAT step);
    virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min,
                                     FAUSTFLOAT max, FAUSTFLOAT step);
    virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max,
                             FAUSTFLOAT step);

    // -- passive display widgets

    virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max);
    virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max);

    // -- layout groups - internal

    virtual void openFrameBox(const char* label);

    // -- extra widget's layouts

    virtual void openDialogBox(const char* label, FAUSTFLOAT* zone);
    virtual void openEventBox(const char* label = "");
    virtual void openHandleBox(const char* label = "");
    virtual void openExpanderBox(const char* label, FAUSTFLOAT* zone);

    virtual void adjustStack(int n);

    // -- active widgets - internal
    virtual void addToggleButton(const char* label, FAUSTFLOAT* zone);
    virtual void addKnob(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max,
                         FAUSTFLOAT step);

    // -- passive display widgets - internal

    virtual void addNumDisplay(const char* label, FAUSTFLOAT* zone, int precision);
    virtual void addTextDisplay(const char* label, FAUSTFLOAT* zone, const char* names[], FAUSTFLOAT min,
                                FAUSTFLOAT max);

    virtual bool run();
    virtual void stop();
};

/******************************************************************************
 *******************************************************************************

 GRAPHIC USER INTERFACE (v2)
 gtk implementation

 *******************************************************************************
 *******************************************************************************/

// global static fields
gboolean GTKUI::gInitialized = false;

static gboolean delete_event(GtkWidget* widget, GdkEvent* event, gpointer data)
{
    return false;
}

static void destroy_event(GtkWidget* widget, gpointer data)
{
    if (GTKUI::gInitialized) {
        gtk_main_quit();
        GTKUI::gInitialized = false;
    }
}

GTKUI::GTKUI(char* name, int* pargc, char*** pargv)
{
    if (!gInitialized) {
        gtk_init(pargc, pargv);
        gInitialized = true;
    }
    fWindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    // gtk_container_set_border_width (GTK_CONTAINER (fWindow), 10);
    gtk_window_set_title(GTK_WINDOW(fWindow), name);
    gtk_signal_connect(GTK_OBJECT(fWindow), "delete_event", GTK_SIGNAL_FUNC(delete_event), NULL);
    gtk_signal_connect(GTK_OBJECT(fWindow), "destroy", GTK_SIGNAL_FUNC(destroy_event), NULL);

    fTop        = 0;
    fBox[fTop]  = gtk_vbox_new(homogene, 4);
    fMode[fTop] = kBoxMode;
}

// Stack a box
void GTKUI::pushBox(int mode, GtkWidget* w)
{
    ++fTop;
    assert(fTop < kStackSize);
    fMode[fTop] = mode;
    fBox[fTop]  = w;
}

/**
 * Remove n levels from the stack S before the top level
 * adjustStack(n): S -> S' with S' = S(0),S(n+1),S(n+2),...
 */
void GTKUI::adjustStack(int n)
{
    if (n > 0) {
        assert(fTop >= n);
        fTop -= n;
        fMode[fTop] = fMode[fTop + n];
        fBox[fTop]  = fBox[fTop + n];
    }
}

void GTKUI::closeBox()
{
    --fTop;
    assert(fTop >= 0);
}

/**
 * Analyses the widget zone metadata declarations and takes
 * appropriate actions
 */
void GTKUI::declare(FAUSTFLOAT* zone, const char* key, const char* value)
{
    MetaDataUI::declare(zone, key, value);
}

/**
 * Analyses a full label and activates the relevant options. returns a simplified
 * label (without options) and an amount of stack adjustement (in case additional
 * containers were pushed on the stack).
 */

int GTKUI::checkLabelOptions(GtkWidget* widget, const std::string& fullLabel, std::string& simplifiedLabel)
{
    std::map<std::string, std::string> metadata;
    extractMetadata(fullLabel, simplifiedLabel, metadata);

    if (metadata.count("tooltip")) {
        gtk_tooltips_set_tip(gtk_tooltips_new(), widget, metadata["tooltip"].c_str(), NULL);
    }
    if (metadata["option"] == "detachable") {
        openHandleBox(simplifiedLabel.c_str());
        return 1;
    }

    //---------------------
    if (fGroupTooltip != "") {
        gtk_tooltips_set_tip(gtk_tooltips_new(), widget, fGroupTooltip.c_str(), NULL);
        fGroupTooltip = "";
    }

    //----------------------
    // no adjustement of the stack needed
    return 0;
}

/**
 * Check if a tooltip is associated to a zone and add it to the corresponding widget
 */
void GTKUI::checkForTooltip(FAUSTFLOAT* zone, GtkWidget* widget)
{
    if (fTooltip.count(zone)) {
        gtk_tooltips_set_tip(gtk_tooltips_new(), widget, fTooltip[zone].c_str(), NULL);
    }
}

// The different boxes
void GTKUI::openFrameBox(const char* label)
{
    GtkWidget* box = gtk_frame_new(label);
    // gtk_container_set_border_width (GTK_CONTAINER (box), 10);

    pushBox(kSingleMode, addWidget(label, box));
}

void GTKUI::openTabBox(const char* fullLabel)
{
    std::string label;
    GtkWidget*  widget = gtk_notebook_new();

    int adjust = checkLabelOptions(widget, fullLabel, label);

    pushBox(kTabMode, addWidget(label.c_str(), widget));

    // adjust stack because otherwise Handlebox will remain open
    adjustStack(adjust);
}

void GTKUI::openHorizontalBox(const char* fullLabel)
{
    std::string label;
    GtkWidget*  box    = gtk_hbox_new(homogene, 4);
    int         adjust = checkLabelOptions(box, fullLabel, label);

    gtk_container_set_border_width(GTK_CONTAINER(box), 10);
    label = startWith(label, "0x") ? "" : label;

    if (fMode[fTop] != kTabMode && label[0] != 0) {
        GtkWidget* frame = addWidget(label.c_str(), gtk_frame_new(label.c_str()));
        gtk_container_add(GTK_CONTAINER(frame), box);
        gtk_widget_show(box);
        pushBox(kBoxMode, box);
    } else {
        pushBox(kBoxMode, addWidget(label.c_str(), box));
    }

    // adjust stack because otherwise Handlebox will remain open
    adjustStack(adjust);
}

void GTKUI::openVerticalBox(const char* fullLabel)
{
    std::string label;
    GtkWidget*  box    = gtk_vbox_new(homogene, 4);
    int         adjust = checkLabelOptions(box, fullLabel, label);

    gtk_container_set_border_width(GTK_CONTAINER(box), 10);
    label = startWith(label, "0x") ? "" : label;

    if (fMode[fTop] != kTabMode && label[0] != 0) {
        GtkWidget* frame = addWidget(label.c_str(), gtk_frame_new(label.c_str()));
        gtk_container_add(GTK_CONTAINER(frame), box);
        gtk_widget_show(box);
        pushBox(kBoxMode, box);
    } else {
        pushBox(kBoxMode, addWidget(label.c_str(), box));
    }

    // adjust stack because otherwise Handlebox will remain open
    adjustStack(adjust);
}

void GTKUI::openHandleBox(const char* label)
{
    GtkWidget* box = gtk_hbox_new(homogene, 4);
    gtk_container_set_border_width(GTK_CONTAINER(box), 2);
    label = startWith(label, "0x") ? "" : label;
    if (fMode[fTop] != kTabMode && label[0] != 0) {
        GtkWidget* frame = addWidget(label, gtk_handle_box_new());
        gtk_container_add(GTK_CONTAINER(frame), box);
        gtk_widget_show(box);
        pushBox(kBoxMode, box);
    } else {
        pushBox(kBoxMode, addWidget(label, box));
    }
}

void GTKUI::openEventBox(const char* label)
{
    GtkWidget* box = gtk_hbox_new(homogene, 4);
    gtk_container_set_border_width(GTK_CONTAINER(box), 2);
    label = startWith(label, "0x") ? "" : label;
    if (fMode[fTop] != kTabMode && label[0] != 0) {
        GtkWidget* frame = addWidget(label, gtk_event_box_new());
        gtk_container_add(GTK_CONTAINER(frame), box);
        gtk_widget_show(box);
        pushBox(kBoxMode, box);
    } else {
        pushBox(kBoxMode, addWidget(label, box));
    }
}

struct uiExpanderBox : public uiItem {
    GtkExpander* fButton;
    uiExpanderBox(GUI* ui, FAUSTFLOAT* zone, GtkExpander* b) : uiItem(ui, zone), fButton(b) {}
    static void expanded(GtkWidget* widget, gpointer data)
    {
        FAUSTFLOAT v = gtk_expander_get_expanded(GTK_EXPANDER(widget));
        if (v == 1.000000) {
            v = 0;
        } else {
            v = 1;
        }
        ((uiItem*)data)->modifyZone(v);
    }

    virtual void reflectZone()
    {
        FAUSTFLOAT v = *fZone;
        fCache       = v;
        gtk_expander_set_expanded(GTK_EXPANDER(fButton), v);
    }
};

void GTKUI::openExpanderBox(const char* label, FAUSTFLOAT* zone)
{
    *zone          = 0.0;
    GtkWidget* box = gtk_hbox_new(homogene, 4);
    gtk_container_set_border_width(GTK_CONTAINER(box), 2);
    label = startWith(label, "0x") ? "" : label;
    if (fMode[fTop] != kTabMode && label[0] != 0) {
        GtkWidget* frame = addWidget(label, gtk_expander_new(label));
        gtk_container_add(GTK_CONTAINER(frame), box);
        uiExpanderBox* c = new uiExpanderBox(this, zone, GTK_EXPANDER(frame));
        gtk_signal_connect(GTK_OBJECT(frame), "activate", GTK_SIGNAL_FUNC(uiExpanderBox::expanded), (gpointer)c);
        gtk_widget_show(box);
        pushBox(kBoxMode, box);
    } else {
        pushBox(kBoxMode, addWidget(label, box));
    }
}

GtkWidget* GTKUI::addWidget(const char* label, GtkWidget* w)
{
    switch (fMode[fTop]) {
        case kSingleMode:
            gtk_container_add(GTK_CONTAINER(fBox[fTop]), w);
            break;
        case kBoxMode:
            gtk_box_pack_start(GTK_BOX(fBox[fTop]), w, expand, fill, 0);
            break;
        case kTabMode:
            gtk_notebook_append_page(GTK_NOTEBOOK(fBox[fTop]), w, gtk_label_new(label));
            break;
    }
    gtk_widget_show(w);
    return w;
}

// --------------------------- Press button ---------------------------

struct uiButton : public uiItem {
    GtkButton* fButton;

    uiButton(GUI* ui, FAUSTFLOAT* zone, GtkButton* b) : uiItem(ui, zone), fButton(b) {}

    static void pressed(GtkWidget* widget, gpointer data)
    {
        uiItem* c = (uiItem*)data;
        c->modifyZone(1.0);
    }

    static void released(GtkWidget* widget, gpointer data)
    {
        uiItem* c = (uiItem*)data;
        c->modifyZone(0.0);
    }

    virtual void reflectZone()
    {
        FAUSTFLOAT v = *fZone;
        fCache       = v;
        if (v > 0.0)
            gtk_button_pressed(fButton);
        else
            gtk_button_released(fButton);
    }
};

void GTKUI::addButton(const char* label, FAUSTFLOAT* zone)
{
    *zone             = 0.0;
    GtkWidget* button = gtk_button_new_with_label(label);
    addWidget(label, button);

    uiButton* c = new uiButton(this, zone, GTK_BUTTON(button));

    gtk_signal_connect(GTK_OBJECT(button), "pressed", GTK_SIGNAL_FUNC(uiButton::pressed), (gpointer)c);
    gtk_signal_connect(GTK_OBJECT(button), "released", GTK_SIGNAL_FUNC(uiButton::released), (gpointer)c);

    checkForTooltip(zone, button);
}

// ---------------------------  Toggle Buttons ---------------------------

struct uiToggleButton : public uiItem {
    GtkToggleButton* fButton;

    uiToggleButton(GUI* ui, FAUSTFLOAT* zone, GtkToggleButton* b) : uiItem(ui, zone), fButton(b) {}

    static void toggled(GtkWidget* widget, gpointer data)
    {
        FAUSTFLOAT v = (GTK_TOGGLE_BUTTON(widget)->active) ? 1.0 : 0.0;
        ((uiItem*)data)->modifyZone(v);
    }

    virtual void reflectZone()
    {
        FAUSTFLOAT v = *fZone;
        fCache       = v;
        gtk_toggle_button_set_active(fButton, v > 0.0);
    }
};

void GTKUI::addToggleButton(const char* label, FAUSTFLOAT* zone)
{
    *zone             = 0.0;
    GtkWidget* button = gtk_toggle_button_new_with_label(label);
    addWidget(label, button);

    uiToggleButton* c = new uiToggleButton(this, zone, GTK_TOGGLE_BUTTON(button));
    gtk_signal_connect(GTK_OBJECT(button), "toggled", GTK_SIGNAL_FUNC(uiToggleButton::toggled), (gpointer)c);

    checkForTooltip(zone, button);
}

void show_dialog(GtkWidget* widget, gpointer data)
{
    if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) {
        gtk_widget_show(GTK_WIDGET(data));
        gint root_x, root_y;
        gtk_window_get_position(GTK_WINDOW(data), &root_x, &root_y);
        root_y -= 120;
        gtk_window_move(GTK_WINDOW(data), root_x, root_y);
    } else
        gtk_widget_hide(GTK_WIDGET(data));
}

static gboolean deleteevent(GtkWidget* widget, gpointer data)
{
    return true;
}

void GTKUI::openDialogBox(const char* label, FAUSTFLOAT* zone)
{
    // create toplevel window and set properties
    GtkWidget* dialog = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_decorated(GTK_WINDOW(dialog), true);
    gtk_window_set_deletable(GTK_WINDOW(dialog), false);
    gtk_window_set_resizable(GTK_WINDOW(dialog), false);
    gtk_window_set_gravity(GTK_WINDOW(dialog), GDK_GRAVITY_SOUTH);
    gtk_window_set_transient_for(GTK_WINDOW(dialog), GTK_WINDOW(fWindow));
    gtk_window_set_position(GTK_WINDOW(dialog), GTK_WIN_POS_MOUSE);
    gtk_window_set_keep_below(GTK_WINDOW(dialog), false);
    gtk_window_set_title(GTK_WINDOW(dialog), label);
    g_signal_connect(G_OBJECT(dialog), "delete_event", G_CALLBACK(deleteevent), NULL);
    gtk_window_set_destroy_with_parent(GTK_WINDOW(dialog), true);

    GtkWidget* box = gtk_hbox_new(homogene, 4);

    *zone             = 0.0;
    GtkWidget* button = gtk_toggle_button_new();
    gtk_signal_connect(GTK_OBJECT(button), "toggled", GTK_SIGNAL_FUNC(show_dialog), (gpointer)dialog);

    gtk_container_add(GTK_CONTAINER(fBox[fTop]), button);
    gtk_container_add(GTK_CONTAINER(dialog), box);
    gtk_widget_show(button);
    gtk_widget_show(box);
    pushBox(kBoxMode, box);
}

// ---------------------------  Check Button ---------------------------

struct uiCheckButton : public uiItem {
    GtkToggleButton* fButton;

    uiCheckButton(GUI* ui, FAUSTFLOAT* zone, GtkToggleButton* b) : uiItem(ui, zone), fButton(b) {}

    static void toggled(GtkWidget* widget, gpointer data)
    {
        FAUSTFLOAT v = (GTK_TOGGLE_BUTTON(widget)->active) ? 1.0 : 0.0;
        ((uiItem*)data)->modifyZone(v);
    }

    virtual void reflectZone()
    {
        FAUSTFLOAT v = *fZone;
        fCache       = v;
        gtk_toggle_button_set_active(fButton, v > 0.0);
    }
};

void GTKUI::addCheckButton(const char* label, FAUSTFLOAT* zone)
{
    *zone             = 0.0;
    GtkWidget* button = gtk_check_button_new_with_label(label);
    addWidget(label, button);

    uiCheckButton* c = new uiCheckButton(this, zone, GTK_TOGGLE_BUTTON(button));
    gtk_signal_connect(GTK_OBJECT(button), "toggled", GTK_SIGNAL_FUNC(uiCheckButton::toggled), (gpointer)c);

    checkForTooltip(zone, button);
}

// ---------------------------  Adjustmenty based widgets ---------------------------

struct uiAdjustment : public uiItem {
    GtkAdjustment* fAdj;

    uiAdjustment(GUI* ui, FAUSTFLOAT* zone, GtkAdjustment* adj) : uiItem(ui, zone), fAdj(adj) {}

    static void changed(GtkWidget* widget, gpointer data)
    {
        FAUSTFLOAT v = GTK_ADJUSTMENT(widget)->value;
        ((uiItem*)data)->modifyZone(v);
    }

    virtual void reflectZone()
    {
        FAUSTFLOAT v = *fZone;
        fCache       = v;
        gtk_adjustment_set_value(fAdj, v);
    }
};

// --------------------------- format knob value display ---------------------------

struct uiValueDisplay : public uiItem {
    GtkLabel* fLabel;
    int       fPrecision;

    uiValueDisplay(GUI* ui, FAUSTFLOAT* zone, GtkLabel* label, int precision)
        : uiItem(ui, zone), fLabel(label), fPrecision(precision)
    {
    }

    virtual void reflectZone()
    {
        FAUSTFLOAT v = *fZone;
        fCache       = v;
        char s[64];
        if (fPrecision <= 0) {
            snprintf(s, 63, "%d", int(v));
        } else if (fPrecision > 3) {
            snprintf(s, 63, "%f", v);
        } else if (fPrecision == 1) {
            const char* format[] = {"%.1f", "%.2f", "%.3f"};
            snprintf(s, 63, format[1 - 1], v);
        } else if (fPrecision == 2) {
            const char* format[] = {"%.1f", "%.2f", "%.3f"};
            snprintf(s, 63, format[2 - 1], v);
        } else {
            const char* format[] = {"%.1f", "%.2f", "%.3f"};
            snprintf(s, 63, format[3 - 1], v);
        }
        gtk_label_set_text(fLabel, s);
    }
};

// ------------------------------- Knob -----------------------------------------

void GTKUI::addKnob(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max,
                    FAUSTFLOAT step)
{
    *zone          = init;
    GtkObject* adj = gtk_adjustment_new(init, min, max, step, 10 * step, 0);

    uiAdjustment* c = new uiAdjustment(this, zone, GTK_ADJUSTMENT(adj));

    gtk_signal_connect(GTK_OBJECT(adj), "value-changed", GTK_SIGNAL_FUNC(uiAdjustment::changed), (gpointer)c);

    GtkWidget* slider = gtk_vbox_new(false, 0);
    GtkWidget* fil    = gtk_vbox_new(false, 0);
    GtkWidget* rei    = gtk_vbox_new(false, 0);
    GtkWidget* re     = myGtkKnob.gtk_knob_new_with_adjustment(GTK_ADJUSTMENT(adj));
    GtkWidget* lw     = gtk_label_new("");
    new uiValueDisplay(this, zone, GTK_LABEL(lw), precision(step));
    gtk_container_add(GTK_CONTAINER(rei), re);
    if (fGuiSize[zone]) {
        FAUSTFLOAT size = 30 * fGuiSize[zone];
        gtk_widget_set_size_request(rei, size, size);
        gtk_box_pack_start(GTK_BOX(slider), fil, true, true, 0);
        gtk_box_pack_start(GTK_BOX(slider), rei, false, false, 0);
    } else {
        gtk_container_add(GTK_CONTAINER(slider), fil);
        gtk_container_add(GTK_CONTAINER(slider), rei);
    }
    gtk_container_add(GTK_CONTAINER(slider), lw);
    gtk_widget_show_all(slider);

    label = startWith(label, "0x") ? "" : label;
    if (label && label[0] != 0) {
        openFrameBox(label);
        addWidget(label, slider);
        closeBox();
    } else {
        addWidget(label, slider);
    }

    checkForTooltip(zone, slider);
}

// -------------------------- Vertical Slider -----------------------------------

void GTKUI::addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max,
                              FAUSTFLOAT step)
{
    if (isKnob(zone)) {
        addKnob(label, zone, init, min, max, step);
        return;
    }
    *zone          = init;
    GtkObject* adj = gtk_adjustment_new(init, min, max, step, 10 * step, 0);

    uiAdjustment* c = new uiAdjustment(this, zone, GTK_ADJUSTMENT(adj));
    gtk_signal_connect(GTK_OBJECT(adj), "value-changed", GTK_SIGNAL_FUNC(uiAdjustment::changed), (gpointer)c);

    GtkWidget* slider = gtk_vscale_new(GTK_ADJUSTMENT(adj));
    gtk_scale_set_digits(GTK_SCALE(slider), precision(step));
    FAUSTFLOAT size = 160;
    if (fGuiSize[zone]) {
        size = 160 * fGuiSize[zone];
    }
    gtk_widget_set_size_request(slider, -1, size);
    gtk_range_set_inverted(GTK_RANGE(slider), true);

    label = startWith(label, "0x") ? "" : label;
    if (label && label[0] != 0) {
        openFrameBox(label);
        addWidget(label, slider);
        closeBox();
    } else {
        addWidget(label, slider);
    }

    checkForTooltip(zone, slider);
}

// -------------------------- Horizontal Slider -----------------------------------

void GTKUI::addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max,
                                FAUSTFLOAT step)
{
    if (isKnob(zone)) {
        addKnob(label, zone, init, min, max, step);
        return;
    }
    *zone          = init;
    GtkObject* adj = gtk_adjustment_new(init, min, max, step, 10 * step, 0);

    uiAdjustment* c = new uiAdjustment(this, zone, GTK_ADJUSTMENT(adj));

    gtk_signal_connect(GTK_OBJECT(adj), "value-changed", GTK_SIGNAL_FUNC(uiAdjustment::changed), (gpointer)c);

    GtkWidget* slider = gtk_hscale_new(GTK_ADJUSTMENT(adj));
    gtk_scale_set_digits(GTK_SCALE(slider), precision(step));
    FAUSTFLOAT size = 160;
    if (fGuiSize[zone]) {
        size = 160 * fGuiSize[zone];
    }
    gtk_widget_set_size_request(slider, size, -1);

    label = startWith(label, "0x") ? "" : label;
    if (label && label[0] != 0) {
        openFrameBox(label);
        addWidget(label, slider);
        closeBox();
    } else {
        addWidget(label, slider);
    }

    checkForTooltip(zone, slider);
}

// ------------------------------ Num Entry -----------------------------------

void GTKUI::addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max,
                        FAUSTFLOAT step)
{
    if (isKnob(zone)) {
        addKnob(label, zone, init, min, max, step);
        return;
    }
    *zone          = init;
    GtkObject* adj = gtk_adjustment_new(init, min, max, step, 10 * step, step);

    uiAdjustment* c = new uiAdjustment(this, zone, GTK_ADJUSTMENT(adj));
    gtk_signal_connect(GTK_OBJECT(adj), "value-changed", GTK_SIGNAL_FUNC(uiAdjustment::changed), (gpointer)c);
    GtkWidget* spinner = gtk_spin_button_new(GTK_ADJUSTMENT(adj), 0.005, precision(step));

    label = startWith(label, "0x") ? "" : label;
    if (label && label[0] != 0) {
        openFrameBox(label);
        addWidget(label, spinner);
        closeBox();
    } else {
        addWidget(label, spinner);
    }

    checkForTooltip(zone, spinner);
}

// ==========================   passive widgets ===============================

// ------------------------------ Progress Bar -----------------------------------

struct uiBargraph : public uiItem {
    GtkProgressBar* fProgressBar;
    FAUSTFLOAT      fMin;
    FAUSTFLOAT      fMax;

    uiBargraph(GUI* ui, FAUSTFLOAT* zone, GtkProgressBar* pbar, FAUSTFLOAT lo, FAUSTFLOAT hi)
        : uiItem(ui, zone), fProgressBar(pbar), fMin(lo), fMax(hi)
    {
    }

    FAUSTFLOAT scale(FAUSTFLOAT v) { return (v - fMin) / (fMax - fMin); }
    FAUSTFLOAT clip(FAUSTFLOAT v) { return std::max<double>(0.0, std::min<double>(1.0, v)); }

    virtual void reflectZone()
    {
        FAUSTFLOAT v = *fZone;
        fCache       = v;
        gtk_progress_bar_set_fraction(fProgressBar, clip(scale(v)));
    }
};

void GTKUI::addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT lo, FAUSTFLOAT hi)
{
    GtkWidget* pb = gtk_progress_bar_new();
    gtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(pb), GTK_PROGRESS_BOTTOM_TO_TOP);
    gtk_widget_set_size_request(pb, 8, -1);
    new uiBargraph(this, zone, GTK_PROGRESS_BAR(pb), lo, hi);

    label = startWith(label, "0x") ? "" : label;
    if (label && label[0] != 0) {
        openFrameBox(label);
        addWidget(label, pb);
        closeBox();
    } else {
        addWidget(label, pb);
    }

    checkForTooltip(zone, pb);
}

void GTKUI::addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT lo, FAUSTFLOAT hi)
{
    GtkWidget* pb = gtk_progress_bar_new();
    gtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(pb), GTK_PROGRESS_LEFT_TO_RIGHT);
    gtk_widget_set_size_request(pb, -1, 8);
    new uiBargraph(this, zone, GTK_PROGRESS_BAR(pb), lo, hi);

    label = startWith(label, "0x") ? "" : label;
    if (label && label[0] != 0) {
        openFrameBox(label);
        addWidget(label, pb);
        closeBox();
    } else {
        addWidget(label, pb);
    }

    checkForTooltip(zone, pb);
}

// ------------------------------ Num Display -----------------------------------

struct uiNumDisplay : public uiItem {
    GtkLabel* fLabel;
    int       fPrecision;

    uiNumDisplay(GUI* ui, FAUSTFLOAT* zone, GtkLabel* label, int precision)
        : uiItem(ui, zone), fLabel(label), fPrecision(precision)
    {
    }

    virtual void reflectZone()
    {
        FAUSTFLOAT v = *fZone;
        fCache       = v;
        char s[64];
        if (fPrecision <= 0) {
            snprintf(s, 63, "%d", int(v));
        } else if (fPrecision > 3) {
            snprintf(s, 63, "%f", v);
        } else {
            const char* format[] = {"%.1f", "%.2f", "%.3f"};
            snprintf(s, 63, format[fPrecision - 1], v);
        }
        gtk_label_set_text(fLabel, s);
    }
};

void GTKUI::addNumDisplay(const char* label, FAUSTFLOAT* zone, int precision)
{
    GtkWidget* lw = gtk_label_new("");
    new uiNumDisplay(this, zone, GTK_LABEL(lw), precision);
    openFrameBox(label);
    addWidget(label, lw);
    closeBox();

    checkForTooltip(zone, lw);
}

// ------------------------------ Text Display -----------------------------------

struct uiTextDisplay : public uiItem {
    GtkLabel*    fLabel;
    const char** fNames;
    FAUSTFLOAT   fMin;
    FAUSTFLOAT   fMax;
    int          fNum;

    uiTextDisplay(GUI* ui, FAUSTFLOAT* zone, GtkLabel* label, const char* names[], FAUSTFLOAT lo, FAUSTFLOAT hi)
        : uiItem(ui, zone), fLabel(label), fNames(names), fMin(lo), fMax(hi)
    {
        fNum = 0;
        while (fNames[fNum] != 0) fNum++;
    }

    virtual void reflectZone()
    {
        FAUSTFLOAT v = *fZone;
        fCache       = v;

        int idx = int(fNum * (v - fMin) / (fMax - fMin));

        if (idx < 0)
            idx = 0;
        else if (idx >= fNum)
            idx = fNum - 1;

        gtk_label_set_text(fLabel, fNames[idx]);
    }
};

void GTKUI::addTextDisplay(const char* label, FAUSTFLOAT* zone, const char* names[], FAUSTFLOAT lo, FAUSTFLOAT hi)
{
    GtkWidget* lw = gtk_label_new("");
    new uiTextDisplay(this, zone, GTK_LABEL(lw), names, lo, hi);
    openFrameBox(label);
    addWidget(label, lw);
    closeBox();
    checkForTooltip(zone, lw);
}

/**
 * Update all user items reflecting zone z
 */

static gboolean callUpdateAllGuis(gpointer)
{
    GUI::updateAllGuis();
    return true;
}

bool GTKUI::run()
{
    assert(fTop == 0);
    gtk_container_add(GTK_CONTAINER(fWindow), fBox[fTop]);

    gtk_widget_show_all(fWindow);
    gtk_widget_show(fBox[0]);
    gtk_widget_show(fWindow);

    // Discover main screen
    GdkScreen*   screen = gdk_screen_get_default();
    GdkRectangle rect;
    gdk_screen_get_monitor_geometry(screen, gdk_screen_get_primary_monitor(screen), &rect);

    // Possibly setup scroll window
    if (fWindow->allocation.width > rect.width || fWindow->allocation.height > rect.height) {
        g_object_ref(fBox[fTop]);  // To avoid desallocation with 'gtk_container_remove'
        gtk_container_remove(GTK_CONTAINER(fWindow), fBox[fTop]);
        fScrolledWindow = gtk_scrolled_window_new(NULL, NULL);
        gtk_widget_set_size_request(fScrolledWindow, rect.width / 2, rect.height / 2);
        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(fScrolledWindow), GTK_POLICY_AUTOMATIC,
                                       GTK_POLICY_AUTOMATIC);
        gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(fScrolledWindow), fBox[fTop]);
        gtk_container_add(GTK_CONTAINER(fWindow), fScrolledWindow);
    }

    gtk_widget_show_all(fWindow);
    gtk_widget_show(fBox[0]);
    gtk_widget_show(fWindow);

    gtk_timeout_add(40, callUpdateAllGuis, 0);
    gtk_main();
    return true;
}

void GTKUI::stop()
{
    GUI::stop();
    if (gInitialized) {
        gInitialized = false;
        gtk_main_quit();
        gtk_signal_emit_by_name((GtkObject*)fWindow, "destroy");
    }
}

#endif

/**************************  END  GTKUI.h **************************/
/************************** BEGIN misc.h *******************************
FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
***************************************************************************/

#ifndef __misc__
#define __misc__

#include <algorithm>
#include <map>
#include <cstdlib>
#include <string.h>
#include <fstream>
#include <string>


struct MY_Meta : Meta, std::map<const char*, const char*>
{
    void declare(const char* key, const char* value) { (*this)[key] = value; }
};

static int lsr(int x, int n) { return int(((unsigned int)x) >> n); }

static int int2pow2(int x) { int r = 0; while ((1<<r) < x) r++; return r; }

static long lopt(char* argv[], const char* name, long def)
{
    for (int i = 0; argv[i]; i++) if (!strcmp(argv[i], name)) return std::atoi(argv[i+1]);
    return def;
}

static long lopt1(int argc, char* argv[], const char* longname, const char* shortname, long def)
{
    for (int i = 2; i < argc; i++) {
        if (strcmp(argv[i-1], shortname) == 0 || strcmp(argv[i-1], longname) == 0) {
            return atoi(argv[i]);
        }
    }
    return def;
}

static const char* lopts(char* argv[], const char* name, const char* def)
{
    for (int i = 0; argv[i]; i++) if (!strcmp(argv[i], name)) return argv[i+1];
    return def;
}

static const char* lopts1(int argc, char* argv[], const char* longname, const char* shortname, const char* def)
{
    for (int i = 2; i < argc; i++) {
        if (strcmp(argv[i-1], shortname) == 0 || strcmp(argv[i-1], longname) == 0) {
            return argv[i];
        }
    }
    return def;
}

static bool isopt(char* argv[], const char* name)
{
    for (int i = 0; argv[i]; i++) if (!strcmp(argv[i], name)) return true;
    return false;
}

static std::string pathToContent(const std::string& path)
{
    std::ifstream file(path.c_str(), std::ifstream::binary);
    
    file.seekg(0, file.end);
    int size = int(file.tellg());
    file.seekg(0, file.beg);
    
    // And allocate buffer to that a single line can be read...
    char* buffer = new char[size + 1];
    file.read(buffer, size);
    
    // Terminate the string
    buffer[size] = 0;
    std::string result = buffer;
    file.close();
    delete [] buffer;
    return result;
}

#endif

/**************************  END  misc.h **************************/
/************************** BEGIN coreaudio-dsp.h *************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __coreaudio_dsp__
#define __coreaudio_dsp__

#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <vector>
#include <iostream>
#include <sys/time.h>

#include <AudioToolbox/AudioConverter.h>
#include <CoreAudio/CoreAudio.h>
#include <AudioUnit/AudioUnit.h>
#include <CoreServices/CoreServices.h>

/************************** BEGIN audio.h *****************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ***********************************************************************/

#ifndef __audio__
#define __audio__

#include <set>
#include <utility>

class dsp;

typedef void (* shutdown_callback)(const char* message, void* arg);

typedef void (* compute_callback)(void* arg);

class audio {
    
    protected:
    
        shutdown_callback fShutdown;    // Shutdown callback
        void* fShutdownArg;             // Shutdown callback data
    
        std::set<std::pair<compute_callback, void*> > fComputeCallbackList;
    
    public:
    
        audio():fShutdown(nullptr), fShutdownArg(nullptr) {}
        virtual ~audio() {}

        /**
         * Init the DSP.
         * @param name - the DSP name to be given to the audio driven
         * (could appear as a JACK client for instance)
         * @param dsp - the dsp that will be initialized with the driver sample rate
         *
         * @return true is sucessful, false in case of driver failure.
         **/
        virtual bool init(const char* name, dsp* dsp) = 0;
    
        /**
         * Start audio processing.
         * @return true is sucessful, false if case of driver failure.
         **/
        virtual bool start() = 0;
    
        /**
         * Stop audio processing.
         **/
        virtual void stop() = 0;
    
        void setShutdownCallback(shutdown_callback cb, void* arg)
        {
            fShutdown = cb;
            fShutdownArg = arg;
        }
    
        void addControlCallback(compute_callback cb, void* arg)
        {
            fComputeCallbackList.insert(std::make_pair(cb, arg));
        }
    
        bool removeControlCallback(compute_callback cb, void* arg)
        {
            return (fComputeCallbackList.erase(std::make_pair(cb, arg)) == 1);
        }
    
        void runControlCallbacks()
        {
            for (const auto& it : fComputeCallbackList) {
                it.first(it.second);
            }
        }
    
        // Return buffer size in frames.
        virtual int getBufferSize() = 0;
    
        // Return the driver sample rate in Hz.
        virtual int getSampleRate() = 0;

        // Return the driver hardware inputs number.
        virtual int getNumInputs() = 0;
    
        // Return the driver hardware outputs number.
        virtual int getNumOutputs() = 0;
    
        /**
         * @return Returns the average proportion of available CPU
         * being spent inside the audio callbacks (between 0.0 and 1.0).
         **/
        virtual float getCPULoad() { return 0.f; }
};
					
#endif
/**************************  END  audio.h **************************/
#ifdef HAS_MATH_EXCEPTION
/************************** BEGIN fpe.h *****************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ********************************************************************/

#ifndef __fpe__
#define __fpe__

#include <cfenv>
#include <iostream>
#include <signal.h>

#ifndef HAVE_FEENABLEEXCEPT
#if defined(__APPLE__) && defined(__MACH__)

// Public domain polyfill for feenableexcept on OS X
// http://www-personal.umich.edu/~williams/archive/computation/fe-handling-example.c

inline int feenableexcept(unsigned int excepts)
{
    static fenv_t fenv;
    unsigned int new_excepts = excepts & FE_ALL_EXCEPT;
    // previous masks
    unsigned int old_excepts;
    
    if (fegetenv(&fenv)) {
        return -1;
    }
    old_excepts = fenv.__control & FE_ALL_EXCEPT;
    
    // unmask
    fenv.__control &= ~new_excepts;
    fenv.__mxcsr   &= ~(new_excepts << 7);
    
    return fesetenv(&fenv) ? -1 : old_excepts;
}

inline int fedisableexcept(unsigned int excepts)
{
    static fenv_t fenv;
    unsigned int new_excepts = excepts & FE_ALL_EXCEPT;
    // all previous masks
    unsigned int old_excepts;
    
    if (fegetenv(&fenv)) {
        return -1;
    }
    old_excepts = fenv.__control & FE_ALL_EXCEPT;
    
    // mask
    fenv.__control |= new_excepts;
    fenv.__mxcsr   |= new_excepts << 7;
    
    return fesetenv(&fenv) ? -1 : old_excepts;
}

#else
inline int feenableexcept(unsigned int excepts)
{
#pragma STDC FENV_ACCESS ON
    fexcept_t flags;
    /* Save current exception flags. */
    fegetexceptflag(&flags, FE_ALL_EXCEPT);
    
    feclearexcept(FE_ALL_EXCEPT);   /* clear all fp exception conditions */
    return fesetexceptflag(&flags, excepts) != 0 ? -1 : flags; /* set new flags */
    
}

inline int fedisableexcept(unsigned int excepts)
{
#pragma STDC FENV_ACCESS ON
    fexcept_t flags;
    /* Save current exception flags. */
    fegetexceptflag(&flags, FE_ALL_EXCEPT);
    
    feclearexcept(FE_ALL_EXCEPT);   /* clear all fp exception conditions */
    return fesetexceptflag(&flags, ~excepts) != 0 ? -1 : flags; /* set new flags */
}

#endif
#endif

// https://en.cppreference.com/w/c/numeric/fenv/FE_exceptions

static void fPEHandler(int sig, siginfo_t* sip, ucontext_t* scp)
{
    int fe_code = sip->si_code;
    
    switch (fe_code) {
    #ifdef FPE_NOOP  // occurs in OS X
        case FPE_NOOP: throw std::runtime_error("FE_NOOP"); break;
    #endif
        case FPE_FLTDIV: throw std::runtime_error("FE_DIVBYZERO"); break;   // divideByZero
        case FPE_FLTINV: throw std::runtime_error("FE_INVALID"); break;     // invalid
        case FPE_FLTOVF: throw std::runtime_error("FE_OVERFLOW"); break;    // overflow
        case FPE_FLTUND: throw std::runtime_error("FE_UNDERFLOW"); break;   // underflow
        case FPE_FLTRES: throw std::runtime_error("FE_INEXACT"); break;     // inexact
        case FPE_FLTSUB: throw std::runtime_error("FE_INVALID"); break;     // invalid
        case FPE_INTDIV: throw std::runtime_error("INT_DIVBYZERO"); break;  // divideByZero
        case FPE_INTOVF: throw std::runtime_error("INT_OVERFLOW"); break;   // overflow
        default: throw std::runtime_error("FE_NOOP"); break;
    }
}

static bool gSetFPEHandler = false;
static void setFPEHandler()
{
    feclearexcept(FE_ALL_EXCEPT);
    feenableexcept(FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW);
    
    if (!gSetFPEHandler) {
        gSetFPEHandler = true;
        
        struct sigaction act;
        act.sa_sigaction = (void(*)(int, siginfo_t*, void*))fPEHandler;
        sigemptyset(&act.sa_mask);
        act.sa_flags = SA_SIGINFO;
        int res = sigaction(SIGFPE, &act, (struct sigaction*)0);
    }
}

/* 
 
TRY_FPE/CATCH_FPE to be used by wrapping code that needs for be protected
 
TRY_FPE
compute(...);
CATCH_FPE
 
*/

#define TRY_FPE     \
setFPEHandler();    \
try {               \

#define CATCH_FPE                   \
} catch (std::runtime_error e) {    \
    std::cerr << "Math exception : " << e.what() << std::endl;  \
    exit(-1);                       \
}                                   \

#endif

/**************************  END  fpe.h **************************/
#endif

/******************************************************************************
*******************************************************************************

							COREAUDIO INTERNAL INTERFACE

*******************************************************************************
*******************************************************************************/

#define OPEN_ERR -1
#define CLOSE_ERR -1
#define NO_ERR 0

#define WAIT_NOTIFICATION_COUNTER 60

typedef	UInt8	CAAudioHardwareDeviceSectionID;
#define	kAudioDeviceSectionInput	((CAAudioHardwareDeviceSectionID)0x01)
#define	kAudioDeviceSectionOutput	((CAAudioHardwareDeviceSectionID)0x00)
#define	kAudioDeviceSectionGlobal	((CAAudioHardwareDeviceSectionID)0x00)
#define	kAudioDeviceSectionWildcard	((CAAudioHardwareDeviceSectionID)0xFF)

class TCoreAudioRenderer;
typedef TCoreAudioRenderer* TCoreAudioRendererPtr;

static void PrintStreamDesc(AudioStreamBasicDescription *inDesc)
{
    printf("- - - - - - - - - - - - - - - - - - - -\n");
    printf("  Sample Rate:%f\n", inDesc->mSampleRate);
    printf("  Format ID:%.*s\n", (int)sizeof(inDesc->mFormatID), (char*)&inDesc->mFormatID);
    printf("  Format Flags:%lX\n", (unsigned long)inDesc->mFormatFlags);
    printf("  Bytes per Packet:%ld\n", (long)inDesc->mBytesPerPacket);
    printf("  Frames per Packet:%ld\n", (long)inDesc->mFramesPerPacket);
    printf("  Bytes per Frame:%ld\n", (long)inDesc->mBytesPerFrame);
    printf("  Channels per Frame:%ld\n", (long)inDesc->mChannelsPerFrame);
    printf("  Bits per Channel:%ld\n", (long)inDesc->mBitsPerChannel);
    printf("- - - - - - - - - - - - - - - - - - - -\n");
}

static void printError(OSStatus err)
{
    switch (err) {
        case kAudioHardwareNoError:
            printf("error code : kAudioHardwareNoError\n");
            break;
		case kAudioConverterErr_FormatNotSupported:
            printf("error code : kAudioConverterErr_FormatNotSupported\n");
            break;
        case kAudioConverterErr_OperationNotSupported:
            printf("error code : kAudioConverterErr_OperationNotSupported\n");
            break;
        case kAudioConverterErr_PropertyNotSupported:
            printf("error code : kAudioConverterErr_PropertyNotSupported\n");
            break;
        case kAudioConverterErr_InvalidInputSize:
            printf("error code : kAudioConverterErr_InvalidInputSize\n");
            break;
        case kAudioConverterErr_InvalidOutputSize:
            printf("error code : kAudioConverterErr_InvalidOutputSize\n");
            break;
        case kAudioConverterErr_UnspecifiedError:
            printf("error code : kAudioConverterErr_UnspecifiedError\n");
            break;
        case kAudioConverterErr_BadPropertySizeError:
            printf("error code : kAudioConverterErr_BadPropertySizeError\n");
            break;
        case kAudioConverterErr_RequiresPacketDescriptionsError:
            printf("error code : kAudioConverterErr_RequiresPacketDescriptionsError\n");
            break;
        case kAudioConverterErr_InputSampleRateOutOfRange:
            printf("error code : kAudioConverterErr_InputSampleRateOutOfRange\n");
            break;
        case kAudioConverterErr_OutputSampleRateOutOfRange:
            printf("error code : kAudioConverterErr_OutputSampleRateOutOfRange\n");
            break;
		case kAudioHardwareNotRunningError:
            printf("error code : kAudioHardwareNotRunningError\n");
            break;
        case kAudioHardwareUnknownPropertyError:
            printf("error code : kAudioHardwareUnknownPropertyError\n");
            break;
        case kAudioHardwareIllegalOperationError:
            printf("error code : kAudioHardwareIllegalOperationError\n");
            break;
        case kAudioHardwareBadDeviceError:
            printf("error code : kAudioHardwareBadDeviceError\n");
            break;
        case kAudioHardwareBadStreamError:
            printf("error code : kAudioHardwareBadStreamError\n");
            break;
        case kAudioDeviceUnsupportedFormatError:
            printf("error code : kAudioDeviceUnsupportedFormatError\n");
            break;
        case kAudioDevicePermissionsError:
            printf("error code : kAudioDevicePermissionsError\n");
            break;
        default:
            printf("error code : err = %d\n", err);
            break;
    }
}

static Float64 GetNominalSampleRate(AudioDeviceID inDevice) 
{
    Float64 sampleRate = 0;
    UInt32 outSize =  sizeof(Float64);
    OSStatus err = AudioDeviceGetProperty(inDevice, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyNominalSampleRate, &outSize, &sampleRate);
    if (err != noErr) {
        printf("Cannot get current sample rate\n");
        printError(err);
        return -1;
    } else {
        return sampleRate;
    }
}

static CFStringRef GetDeviceName(AudioDeviceID id)
{
    UInt32 size = sizeof(CFStringRef);
    CFStringRef UIname;
    OSStatus err = AudioDeviceGetProperty(id, 0, false, kAudioDevicePropertyDeviceUID, &size, &UIname);
    return (err == noErr) ? UIname : NULL;
}

static bool CheckAvailableDeviceName(const char* device_name, AudioDeviceID* device_id, int len = -1)
{
    UInt32 size;
    Boolean isWritable;
    int i, deviceNum;
    OSStatus err;

    err = AudioHardwareGetPropertyInfo(kAudioHardwarePropertyDevices, &size, &isWritable);
    if (err != noErr) {
        return false;
    }

    deviceNum = size / sizeof(AudioDeviceID);
    AudioDeviceID devices[deviceNum];
 
    err = AudioHardwareGetProperty(kAudioHardwarePropertyDevices, &size, devices);
    if (err != noErr) {
        return false;
    }

    for (i = 0; i < deviceNum; i++) {
        char device_name_aux[256];
    
        size = 256;
        err = AudioDeviceGetProperty(devices[i], 0, false, kAudioDevicePropertyDeviceName, &size, device_name_aux);
        if (err != noErr) {
            return false;
        }
 
        if (strncmp(device_name_aux, device_name, (len == -1) ? strlen(device_name) : len) == 0) {
            *device_id = devices[i];
            return true;
        }
    }

    return false;
}

class TCoreAudioRenderer
{
    
    protected:
    
        AudioDeviceID fAggregateDeviceID;
        AudioObjectID fAggregatePluginID;    // Used for aggregate device
     
        int fDevNumInChans;
        int fDevNumOutChans;
        
        int fPhysicalInputs;
        int fPhysicalOutputs;
        
        float** fInChannel;
        float** fOutChannel;

        int fBufferSize;
        int fSampleRate;
    
        bool fIsInJackDevice;
        bool fIsOutJackDevice;
        
        dsp* fDSP;
    
        audio* fAudio;

        AudioBufferList* fInputData;
        AudioDeviceID fDeviceID;
        AudioUnit fAUHAL;
        bool fState;

        OSStatus GetDefaultDeviceAndSampleRate(int inChan, int outChan, int& sample_rate, int& outChannelOffset, AudioDeviceID* device)
        {
            
            UInt32 theSize = sizeof(UInt32);
            AudioDeviceID inDefault;
            AudioDeviceID outDefault;
            OSStatus res;
            
            if ((res = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultInputDevice,
                                                &theSize, &inDefault)) != noErr) {
                return res;
            }
            
            if ((res = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice,
                                                &theSize, &outDefault)) != noErr) {
                return res;
            }
            
            /*
            // TODO
            if (inDefault == 0) {
                printf("Error default input device is 0, will take 'Built-in'...\n");
                if (CheckAvailableDeviceName("Built-in Microphone", &inDefault) 
                    || CheckAvailableDeviceName("Built-in Line", &inDefault)) {
                    printf("GetDefaultInputDevice : output = %ld\n", inDefault);
                } else {
                    printf("Cannot find any input device to use...");
                    return -1;
                }
            }
            
            if (outDefault == 0) {
                printf("Error default ouput device is 0, will take 'Built-in'...\n");
                if (CheckAvailableDeviceName("Built-in Output", &outDefault)) {
                    printf("GetDefaultOutputDevice : output = %ld\n", outDefault);
                } else {
                    printf("Cannot find any output device to use...\n");
                    return -1;
                }
            }  
            */          
            
            //printf("GetDefaultDevice : input = %d output = %d\n", inDefault, outDefault);
            
            // Duplex mode
            if (inChan > 0 && outChan > 0) {
                // Get the device only if default input and output are the same
                if (inDefault == outDefault) {
                    *device = inDefault;
                    goto end;
                } else {
                    if (CreateAggregateDevice(inDefault, outDefault, sample_rate, outChannelOffset) != noErr) {
                        return kAudioHardwareBadDeviceError;
                    }
                    //printf("fAggregateDeviceID %d\n", fAggregateDeviceID);
                    *device = fAggregateDeviceID;
                    goto end;
                }
            } else if (inChan > 0) {
                *device = inDefault;
                goto end;
            } else if (outChan > 0) {
                *device = outDefault;
                goto end;
            } else {
                return kAudioHardwareBadDeviceError;
            }
            
        end:   
            
            if (sample_rate == -1) {
                // Possible take the current sample rate
                sample_rate = int(GetNominalSampleRate(*device));
            } else {
                // Otherwise force the one we want...
                SetupSampleRateAux(*device, sample_rate);
            }
            //printf("samplerate %d\n", sample_rate);
            fSampleRate = sample_rate;
            return noErr;
        }

        OSStatus CreateAggregateDevice(AudioDeviceID captureDeviceID, AudioDeviceID playbackDeviceID, int& sample_rate, int& outChannelOffset)
        {
            OSStatus err = noErr;
            AudioObjectID sub_device[32];
            UInt32 outSize = sizeof(sub_device);
            
            //printf("CreateAggregateDevice : input device %d\n", captureDeviceID);
            
            err = AudioDeviceGetProperty(captureDeviceID, 0, kAudioDeviceSectionGlobal, kAudioAggregateDevicePropertyActiveSubDeviceList, &outSize, sub_device);
            std::vector<AudioDeviceID> captureDeviceIDArray;
            
            if (err != noErr) {
                //printf("Input device does not have subdevices\n");
                captureDeviceIDArray.push_back(captureDeviceID);
            } else {
                int num_devices = outSize / sizeof(AudioObjectID);
                //printf("Input device has %d subdevices\n", num_devices);
                for (int i = 0; i < num_devices; i++) {
                    //printf("Input sub_device %d\n", sub_device[i]);
                    captureDeviceIDArray.push_back(sub_device[i]);
                }
            }
            
            outSize = sizeof(sub_device);
            err = AudioDeviceGetProperty(playbackDeviceID, 0, kAudioDeviceSectionGlobal, kAudioAggregateDevicePropertyActiveSubDeviceList, &outSize, sub_device);
            std::vector<AudioDeviceID> playbackDeviceIDArray;
            
            if (err != noErr) {
                //printf("Output device does not have subdevices\n");
                playbackDeviceIDArray.push_back(playbackDeviceID);
            } else {
                int num_devices = outSize / sizeof(AudioObjectID);
                //printf("Output device has %d subdevices\n", num_devices);
                for (int i = 0; i < num_devices; i++) {
                    //printf("Output sub_device %d\n", sub_device[i]);
                    playbackDeviceIDArray.push_back(sub_device[i]);
                }
            }
            
            return CreateAggregateDeviceAux(captureDeviceIDArray, playbackDeviceIDArray, sample_rate, outChannelOffset);
        }
        
        OSStatus CreateAggregateDeviceAux(std::vector<AudioDeviceID> captureDeviceID, std::vector<AudioDeviceID> playbackDeviceID, int& sample_rate, int& outChannelOffset)
        {
            OSStatus osErr = noErr;
            UInt32 outSize;
            Boolean outWritable;
            bool fClockDriftCompensate = true;
            
            // Prepare sub-devices for clock drift compensation
            // Workaround for bug in the HAL : until 10.6.2
            AudioObjectPropertyAddress theAddressOwned = { kAudioObjectPropertyOwnedObjects, kAudioObjectPropertyScopeGlobal, kAudioObjectPropertyElementMaster };
            AudioObjectPropertyAddress theAddressDrift = { kAudioSubDevicePropertyDriftCompensation, kAudioObjectPropertyScopeGlobal, kAudioObjectPropertyElementMaster };
            UInt32 theQualifierDataSize = sizeof(AudioObjectID);
            AudioClassID inClass = kAudioSubDeviceClassID;
            void* theQualifierData = &inClass;
            UInt32 subDevicesNum = 0;
            
            //---------------------------------------------------------------------------
            // Setup SR of both devices otherwise creating AD may fail...
            //---------------------------------------------------------------------------
            UInt32 keptclockdomain = 0;
            UInt32 clockdomain = 0;
            outSize = sizeof(UInt32);
            bool need_clock_drift_compensation = false;
            
            for (UInt32 i = 0; i < captureDeviceID.size(); i++) {
                if (SetupSampleRateAux(captureDeviceID[i], sample_rate) < 0) {
                    printf("TCoreAudioRenderer::CreateAggregateDeviceAux : cannot set SR of input device\n");
                } else  {
                    // Check clock domain
                    osErr = AudioDeviceGetProperty(captureDeviceID[i], 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyClockDomain, &outSize, &clockdomain);
                    if (osErr != 0) {
                        printf("TCoreAudioRenderer::CreateAggregateDeviceAux : kAudioDevicePropertyClockDomain error\n");
                        printError(osErr);
                    } else {
                        keptclockdomain = (keptclockdomain == 0) ? clockdomain : keptclockdomain;
                        //printf("TCoreAudioRenderer::CreateAggregateDevice : input clockdomain = %d\n", clockdomain);
                        if (clockdomain != 0 && clockdomain != keptclockdomain) {
                            //printf("TCoreAudioRenderer::CreateAggregateDevice : devices do not share the same clock!! clock drift compensation would be needed...\n");
                            need_clock_drift_compensation = true;
                        }
                    }
                }
            }
            
            for (UInt32 i = 0; i < playbackDeviceID.size(); i++) {
                if (SetupSampleRateAux(playbackDeviceID[i], sample_rate) < 0) {
                    printf("TCoreAudioRenderer::CreateAggregateDeviceAux : cannot set SR of output device\n");
                } else {
                    // Check clock domain
                    osErr = AudioDeviceGetProperty(playbackDeviceID[i], 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyClockDomain, &outSize, &clockdomain);
                    if (osErr != 0) {
                        printf("TCoreAudioRenderer::CreateAggregateDeviceAux : kAudioDevicePropertyClockDomain error\n");
                        printError(osErr);
                    } else {
                        keptclockdomain = (keptclockdomain == 0) ? clockdomain : keptclockdomain;
                        //printf("TCoreAudioRenderer::CreateAggregateDevice : output clockdomain = %d", clockdomain);
                        if (clockdomain != 0 && clockdomain != keptclockdomain) {
                            //printf("TCoreAudioRenderer::CreateAggregateDevice : devices do not share the same clock!! clock drift compensation would be needed...\n");
                            need_clock_drift_compensation = true;
                        }
                    }
                }
            }
            
            // If no valid clock domain was found, then assume we have to compensate...
            if (keptclockdomain == 0) {
                need_clock_drift_compensation = true;
            }
            
            //---------------------------------------------------------------------------
            // Start to create a new aggregate by getting the base audio hardware plugin
            //---------------------------------------------------------------------------
            
            char device_name[256];
            for (UInt32 i = 0; i < captureDeviceID.size(); i++) {
                GetDeviceNameFromID(captureDeviceID[i], device_name);
                //printf("Separated input = '%s'\n", device_name);

                // Compute the total number of output channels that the input devices have:
                // we'll need to skip past these in our aggregate device and jump to the
                // output channels that belong to the actual output device.
                AudioBufferList bufferList;
                outSize = sizeof(bufferList);
                osErr = AudioDeviceGetProperty(captureDeviceID[i], 0, kAudioDeviceSectionGlobal,
                                       kAudioDevicePropertyStreamConfiguration,
                                       &outSize, &bufferList);
                if (osErr != noErr) {
                    printf("TCoreAudioRenderer::CreateAggregateDeviceAux : kAudioDevicePropertyStreamConfiguration error\n");
                    printError(osErr);
                    return osErr;
                }
                int captureDeviceOutChannels =
                    bufferList.mNumberBuffers > 0
                    ? bufferList.mBuffers[0].mNumberChannels
                    : 0;
                //printf("output channels to skip: %d\n", captureDeviceOutChannels);
                outChannelOffset += captureDeviceOutChannels;
            }
            
            for (UInt32 i = 0; i < playbackDeviceID.size(); i++) {
                GetDeviceNameFromID(playbackDeviceID[i], device_name);
                //printf("Separated output = '%s' \n", device_name);
            }
            
            osErr = AudioHardwareGetPropertyInfo(kAudioHardwarePropertyPlugInForBundleID, &outSize, &outWritable);
            if (osErr != noErr) {
                printf("TCoreAudioRenderer::CreateAggregateDeviceAux : AudioHardwareGetPropertyInfo kAudioHardwarePropertyPlugInForBundleID error\n");
                printError(osErr);
                return osErr;
            }
            
            AudioValueTranslation pluginAVT;
            CFStringRef inBundleRef = CFSTR("com.apple.audio.CoreAudio");
            
            pluginAVT.mInputData = &inBundleRef;
            pluginAVT.mInputDataSize = sizeof(inBundleRef);
            pluginAVT.mOutputData = &fAggregatePluginID;
            pluginAVT.mOutputDataSize = sizeof(fAggregatePluginID);
            
            osErr = AudioHardwareGetProperty(kAudioHardwarePropertyPlugInForBundleID, &outSize, &pluginAVT);
            if (osErr != noErr) {
                printf("TCoreAudioRenderer::CreateAggregateDeviceAux : AudioHardwareGetProperty kAudioHardwarePropertyPlugInForBundleID error\n");
                printError(osErr);
                return osErr;
            }
            
            //-------------------------------------------------
            // Create a CFDictionary for our aggregate device
            //-------------------------------------------------
            
            CFMutableDictionaryRef aggDeviceDict = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            
            char buffer1[64];
            char buffer2[64];
            
            // generate "random" name
            struct timeval fTv1;
            struct timezone tz;
            gettimeofday(&fTv1, &tz);
            
            snprintf(buffer1, 64, "com.grame.%ld", fTv1.tv_sec + fTv1.tv_usec);
            snprintf(buffer2, 64, "%ld", fTv1.tv_sec + fTv1.tv_usec);
            
            CFStringRef AggregateDeviceNameRef = CFStringCreateWithCString(kCFAllocatorDefault, buffer1, CFStringGetSystemEncoding());
            CFStringRef AggregateDeviceUIDRef = CFStringCreateWithCString(kCFAllocatorDefault, buffer2, CFStringGetSystemEncoding());
            
            // add the name of the device to the dictionary
            CFDictionaryAddValue(aggDeviceDict, CFSTR(kAudioAggregateDeviceNameKey), AggregateDeviceNameRef);
            
            // add our choice of UID for the aggregate device to the dictionary
            CFDictionaryAddValue(aggDeviceDict, CFSTR(kAudioAggregateDeviceUIDKey), AggregateDeviceUIDRef);
            
            // add a "private aggregate key" to the dictionary
            int value = 1;
            CFNumberRef AggregateDeviceNumberRef = CFNumberCreate(NULL, kCFNumberIntType, &value);
            
            SInt32 system;
            Gestalt(gestaltSystemVersion, &system);
            
            //printf("TCoreAudioRenderer::CreateAggregateDevice : system version = %x limit = %x\n", system, 0x00001054);
            
            // Starting with 10.5.4 systems, the AD can be internal... (better)
            if (system < 0x00001054) {
                //printf("TCoreAudioRenderer::CreateAggregateDevice : public aggregate device....\n");
            } else {
                //printf("TCoreAudioRenderer::CreateAggregateDevice : private aggregate device....\n");
                CFDictionaryAddValue(aggDeviceDict, CFSTR(kAudioAggregateDeviceIsPrivateKey), AggregateDeviceNumberRef);
            }
            
            // Prepare sub-devices for clock drift compensation
            CFMutableArrayRef subDevicesArrayClock = NULL;
            
            /*
             if (fClockDriftCompensate) {
                 if (need_clock_drift_compensation) {
                     jack_info("Clock drift compensation activated...");
                     subDevicesArrayClock = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);
                     
                     for (UInt32 i = 0; i < captureDeviceID.size(); i++) {
                         CFStringRef UID = GetDeviceName(captureDeviceID[i]);
                         if (UID) {
                         CFMutableDictionaryRef subdeviceAggDeviceDict = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                         CFDictionaryAddValue(subdeviceAggDeviceDict, CFSTR(kAudioSubDeviceUIDKey), UID);
                         CFDictionaryAddValue(subdeviceAggDeviceDict, CFSTR(kAudioSubDeviceDriftCompensationKey), AggregateDeviceNumberRef);
                         //CFRelease(UID);
                         CFArrayAppendValue(subDevicesArrayClock, subdeviceAggDeviceDict);
                     }
                 }
                 
                 for (UInt32 i = 0; i < playbackDeviceID.size(); i++) {
                     CFStringRef UID = GetDeviceName(playbackDeviceID[i]);
                     if (UID) {
                         CFMutableDictionaryRef subdeviceAggDeviceDict = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                         CFDictionaryAddValue(subdeviceAggDeviceDict, CFSTR(kAudioSubDeviceUIDKey), UID);
                         CFDictionaryAddValue(subdeviceAggDeviceDict, CFSTR(kAudioSubDeviceDriftCompensationKey), AggregateDeviceNumberRef);
                         //CFRelease(UID);
                         CFArrayAppendValue(subDevicesArrayClock, subdeviceAggDeviceDict);
                     }
                 }
                     
                     // add sub-device clock array for the aggregate device to the dictionary
                     CFDictionaryAddValue(aggDeviceDict, CFSTR(kAudioAggregateDeviceSubDeviceListKey), subDevicesArrayClock);
                     } else {
                     jack_info("Clock drift compensation was asked but is not needed (devices use the same clock domain)");
                 }
            }
            */
            
            //-------------------------------------------------
            // Create a CFMutableArray for our sub-device list
            //-------------------------------------------------
            
            // we need to append the UID for each device to a CFMutableArray, so create one here
            CFMutableArrayRef subDevicesArray = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);
            
            std::vector<CFStringRef> captureDeviceUID;
            for (UInt32 i = 0; i < captureDeviceID.size(); i++) {
                CFStringRef ref = GetDeviceName(captureDeviceID[i]);
                if (ref == NULL) {
                    return -1;
                }
                captureDeviceUID.push_back(ref);
                // input sub-devices in this example, so append the sub-device's UID to the CFArray
                CFArrayAppendValue(subDevicesArray, ref);
            }
            
            std::vector<CFStringRef> playbackDeviceUID;
            for (UInt32 i = 0; i < playbackDeviceID.size(); i++) {
                CFStringRef ref = GetDeviceName(playbackDeviceID[i]);
                if (ref == NULL) {
                    return -1;
                }
                playbackDeviceUID.push_back(ref);
                // output sub-devices in this example, so append the sub-device's UID to the CFArray
                CFArrayAppendValue(subDevicesArray, ref);
            }
            
            //-----------------------------------------------------------------------
            // Feed the dictionary to the plugin, to create a blank aggregate device
            //-----------------------------------------------------------------------
            
            AudioObjectPropertyAddress pluginAOPA;
            pluginAOPA.mSelector = kAudioPlugInCreateAggregateDevice;
            pluginAOPA.mScope = kAudioObjectPropertyScopeGlobal;
            pluginAOPA.mElement = kAudioObjectPropertyElementMaster;
            UInt32 outDataSize;
            
            osErr = AudioObjectGetPropertyDataSize(fAggregatePluginID, &pluginAOPA, 0, NULL, &outDataSize);
            if (osErr != noErr) {
                printf("TCoreAudioRenderer::CreateAggregateDeviceAux : AudioObjectGetPropertyDataSize error\n");
                printError(osErr);
                goto error;
            }
            
            osErr = AudioObjectGetPropertyData(fAggregatePluginID, &pluginAOPA, sizeof(aggDeviceDict), &aggDeviceDict, &outDataSize, &fAggregateDeviceID);
            if (osErr != noErr) {
                printf("TCoreAudioRenderer::CreateAggregateDeviceAux : AudioObjectGetPropertyData error\n");
                printError(osErr);
                goto error;
            }
            
            // pause for a bit to make sure that everything completed correctly
            // this is to work around a bug in the HAL where a new aggregate device seems to disappear briefly after it is created
            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.1, false);
            
            //-------------------------
            // Set the sub-device list
            //-------------------------
            
            pluginAOPA.mSelector = kAudioAggregateDevicePropertyFullSubDeviceList;
            pluginAOPA.mScope = kAudioObjectPropertyScopeGlobal;
            pluginAOPA.mElement = kAudioObjectPropertyElementMaster;
            outDataSize = sizeof(CFMutableArrayRef);
            osErr = AudioObjectSetPropertyData(fAggregateDeviceID, &pluginAOPA, 0, NULL, outDataSize, &subDevicesArray);
            if (osErr != noErr) {
                printf("TCoreAudioRenderer::CreateAggregateDeviceAux : AudioObjectSetPropertyData for sub-device list error\n");
                printError(osErr);
                goto error;
            }
            
            // pause again to give the changes time to take effect
            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.1, false);
            
            //-----------------------
            // Set the master device
            //-----------------------
            
            // set the master device manually (this is the device which will act as the master clock for the aggregate device)
            // pass in the UID of the device you want to use
            pluginAOPA.mSelector = kAudioAggregateDevicePropertyMasterSubDevice;
            pluginAOPA.mScope = kAudioObjectPropertyScopeGlobal;
            pluginAOPA.mElement = kAudioObjectPropertyElementMaster;
            outDataSize = sizeof(CFStringRef);
            osErr = AudioObjectSetPropertyData(fAggregateDeviceID, &pluginAOPA, 0, NULL, outDataSize, &playbackDeviceUID[0]);  // First playback is master...
            if (osErr != noErr) {
                printf("TCoreAudioRenderer::CreateAggregateDeviceAux : AudioObjectSetPropertyData for master device error\n");
                printError(osErr);
                goto error;
            }
            
            // pause again to give the changes time to take effect
            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.1, false);
            
            // Prepare sub-devices for clock drift compensation
            // Workaround for bug in the HAL : until 10.6.2
            
            if (fClockDriftCompensate) {
                if (need_clock_drift_compensation) {
                    //printf("Clock drift compensation activated...\n");
                    
                    // Get the property data size
                    osErr = AudioObjectGetPropertyDataSize(fAggregateDeviceID, &theAddressOwned, theQualifierDataSize, theQualifierData, &outSize);
                    if (osErr != noErr) {
                        printf("TCoreAudioRenderer::CreateAggregateDeviceAux kAudioObjectPropertyOwnedObjects error\n");
                        printError(osErr);
                    }
                    
                    //	Calculate the number of object IDs
                    subDevicesNum = outSize / sizeof(AudioObjectID);
                    //printf("TCoreAudioRenderer::CreateAggregateDevice clock drift compensation, number of sub-devices = %d\n", subDevicesNum);
                    AudioObjectID subDevices[subDevicesNum];
                    outSize = sizeof(subDevices);
                    
                    osErr = AudioObjectGetPropertyData(fAggregateDeviceID, &theAddressOwned, theQualifierDataSize, theQualifierData, &outSize, subDevices);
                    if (osErr != noErr) {
                        printf("TCoreAudioRenderer::CreateAggregateDeviceAux kAudioObjectPropertyOwnedObjects error\n");
                        printError(osErr);
                    }
                    
                    // Set kAudioSubDevicePropertyDriftCompensation property...
                    for (UInt32 index = 0; index < subDevicesNum; ++index) {
                        UInt32 theDriftCompensationValue = 1;
                        osErr = AudioObjectSetPropertyData(subDevices[index], &theAddressDrift, 0, NULL, sizeof(UInt32), &theDriftCompensationValue);
                        if (osErr != noErr) {
                            printf("TCoreAudioRenderer::CreateAggregateDeviceAux kAudioSubDevicePropertyDriftCompensation error\n");
                            printError(osErr);
                        }
                    }
                } else {
                    //printf("Clock drift compensation was asked but is not needed (devices use the same clock domain)\n");
                }
            }
            
            // pause again to give the changes time to take effect
            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.1, false);
            
            //----------
            // Clean up
            //----------
            
            // release the private AD key
            CFRelease(AggregateDeviceNumberRef);
            
            // release the CF objects we have created - we don't need them any more
            CFRelease(aggDeviceDict);
            CFRelease(subDevicesArray);
            
            if (subDevicesArrayClock)
                CFRelease(subDevicesArrayClock);
            
            // release the device UID
            for (UInt32 i = 0; i < captureDeviceUID.size(); i++) {
                CFRelease(captureDeviceUID[i]);
            }
            
            for (UInt32 i = 0; i < playbackDeviceUID.size(); i++) {
                CFRelease(playbackDeviceUID[i]);
            }
            
            //printf("New aggregate device %d\n", fAggregateDeviceID);
            return noErr;
            
        error:
            DestroyAggregateDevice();
            return -1;
        }

        void DestroyAggregateDevice()
        {   
            if (fAggregateDeviceID > 0) {
                OSStatus osErr = noErr;
                AudioObjectPropertyAddress pluginAOPA;
                pluginAOPA.mSelector = kAudioPlugInDestroyAggregateDevice;
                pluginAOPA.mScope = kAudioObjectPropertyScopeGlobal;
                pluginAOPA.mElement = kAudioObjectPropertyElementMaster;
                UInt32 outDataSize;
                if (fAggregatePluginID > 0)   {
                    osErr = AudioObjectGetPropertyDataSize(fAggregatePluginID, &pluginAOPA, 0, NULL, &outDataSize);
                    if (osErr != noErr) {
                        //printf("TCoreAudioRenderer::DestroyAggregateDevice : AudioObjectGetPropertyDataSize error\n");
                        //printError(osErr);
                    }
                    osErr = AudioObjectGetPropertyData(fAggregatePluginID, &pluginAOPA, 0, NULL, &outDataSize, &fAggregateDeviceID);
                    if (osErr != noErr) {
                        //printf("TCoreAudioRenderer::DestroyAggregateDevice : AudioObjectGetPropertyData error\n");
                        //printError(osErr);
                    }
                }
            }
        }

        OSStatus GetDeviceNameFromID(AudioDeviceID id, char* name)
        {
            UInt32 size = 256;
            return AudioDeviceGetProperty(id, 0, false, kAudioDevicePropertyDeviceName, &size, name);
        }
        
        int SetupBufferSize(int buffer_size)
        {
            // Setting buffer size
            OSStatus err = noErr;
            UInt32 current_buffer_size = buffer_size;
            UInt32 outSize; 
            AudioValueRange buffer_size_range;
            
            outSize = sizeof(AudioValueRange);
            err = AudioDeviceGetProperty(fDeviceID, 0, true, kAudioDevicePropertyBufferFrameSizeRange, &outSize, &buffer_size_range);
            if (err != noErr) {
                printf("Cannot get buffer size range\n");
                printError(err);
                return -1;
            } else {
                //printf("SetupBufferSize : buffer size range min = %ld max = %ld\n", (int)buffer_size_range.mMinimum, (int)buffer_size_range.mMaximum);
            }
            
            outSize = sizeof(UInt32);
            err = AudioDeviceGetProperty(fDeviceID, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyBufferFrameSize, &outSize, &current_buffer_size);
            if (err != noErr) {
                printf("Cannot get buffer size\n");
                printError(err);
                return -1;
            } else {
                //printf("SetupBufferSize : current buffer size %ld\n", current_buffer_size);
            }

            // If needed, set new buffer size
            if (buffer_size != current_buffer_size && buffer_size >= (int)buffer_size_range.mMinimum && buffer_size <= (int)buffer_size_range.mMaximum) {
                current_buffer_size = buffer_size;

                // To get BS change notification
                err = AudioDeviceAddPropertyListener(fDeviceID, 0, true, kAudioDevicePropertyBufferFrameSize, BSNotificationCallback, this);
                if (err != noErr) {
                    printf("Error calling AudioDeviceAddPropertyListener with kAudioDevicePropertyBufferFrameSize\n");
                    printError(err);
                    return -1;
                }

                // Waiting for BS change notification
                int count = 0;
                fState = false;

                err = AudioDeviceSetProperty(fDeviceID, NULL, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyBufferFrameSize, outSize, &current_buffer_size);
                if (err != noErr) {
                    printf("SetupBufferSize : cannot set buffer size = %ld\n", current_buffer_size);
                    printError(err);
                    goto error;
                }

                while (!fState && count++ < WAIT_NOTIFICATION_COUNTER) {
                    usleep(100000);
                    //printf("SetupBufferSize : wait count = %d\n", count);
                }

                if (count >= WAIT_NOTIFICATION_COUNTER) {
                    printf("Did not get buffer size notification...\n");
                    goto error;
                }

                // Check new buffer size
                outSize = sizeof(UInt32);
                err = AudioDeviceGetProperty(fDeviceID, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyBufferFrameSize, &outSize, &current_buffer_size);
                if (err != noErr) {
                    printf("Cannot get current buffer size\n");
                    printError(err);
                } else {
                    //printf("SetupBufferSize : checked buffer size = %ld\n", current_buffer_size);
                }

                // Remove BS change notification
                AudioDeviceRemovePropertyListener(fDeviceID, 0, true, kAudioDevicePropertyBufferFrameSize, BSNotificationCallback);
            } else {
                //printf("Keep current buffer size = %ld\n", current_buffer_size);
            }
            
            fBufferSize = current_buffer_size;
            return 0;

        error:

            // Remove BS change notification
            AudioDeviceRemovePropertyListener(fDeviceID, 0, true, kAudioDevicePropertyBufferFrameSize, BSNotificationCallback);
            return -1;
        }
        
        static OSStatus BSNotificationCallback(AudioDeviceID inDevice,
                                                         UInt32 inChannel,
                                                         Boolean isInput,
                                                         AudioDevicePropertyID inPropertyID,
                                                         void* inClientData)
        {
            TCoreAudioRenderer* driver = (TCoreAudioRenderer*)inClientData;
        
            switch (inPropertyID) {

                case kAudioDevicePropertyBufferFrameSize: {
                    //printf("BSNotificationCallback kAudioDevicePropertyBufferFrameSize\n");
                    // Check new buffer size
                    UInt32 current_buffer_size;
                    UInt32 outSize = sizeof(UInt32);
                    OSStatus err = AudioDeviceGetProperty(inDevice, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyBufferFrameSize, &outSize, &current_buffer_size);
                    if (err != noErr) {
                        printf("Cannot get current buffer size\n");
                        printError(err);
                    } else {
                        //printf("BSNotificationCallback : checked current buffer size = %d\n", current_buffer_size);
                    }
                    driver->fState = true;
                    break;
                }
            }

            return noErr;
        }

        int SetupSampleRateAux(AudioDeviceID inDevice, int& sample_rate)
        {
            OSStatus err = noErr;
            UInt32 outSize = sizeof(Float64);
            Float64 sampleRate = GetNominalSampleRate(inDevice);
            
            if (sample_rate != -1 && sample_rate != (int)sampleRate) {
                sampleRate = (Float64)sample_rate;
                
                // To get SR change notification
                err = AudioDeviceAddPropertyListener(inDevice, 0, true, kAudioDevicePropertyNominalSampleRate, SRNotificationCallback, this);
                if (err != noErr) {
                    printf("Error calling AudioDeviceAddPropertyListener with kAudioDevicePropertyNominalSampleRate\n");
                    printError(err);
                    return -1;
                }
                err = AudioDeviceSetProperty(inDevice, NULL, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyNominalSampleRate, outSize, &sampleRate);
                if (err != noErr) {
                    printf("Cannot set sample rate = %d\n", sample_rate);
                    printError(err);
                    return -1;
                }
                
                // Waiting for SR change notification
                int count = 0;
                while (!fState && count++ < WAIT_NOTIFICATION_COUNTER) {
                    usleep(100000);
                    //printf("Wait count = %d\n", count);
                }
                
                // Check new sample rate
                outSize = sizeof(Float64);
                err = AudioDeviceGetProperty(inDevice, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyNominalSampleRate, &outSize, &sampleRate);
                if (err != noErr) {
                    printf("Cannot get current sample rate\n");
                    printError(err);
                } else {
                    //printf("Checked sample rate = %f\n", sampleRate);
                }
                
                // Remove SR change notification
                AudioDeviceRemovePropertyListener(inDevice, 0, true, kAudioDevicePropertyNominalSampleRate, SRNotificationCallback);
            }
            
            sample_rate = int(sampleRate);
            return 0;
        }   

        static OSStatus Render(void *inRefCon,
                           AudioUnitRenderActionFlags *ioActionFlags,
                           const AudioTimeStamp *inTimeStamp,
                           UInt32 inBusNumber,
                           UInt32 inNumberFrames,
                           AudioBufferList *ioData)
        {
            return static_cast<TCoreAudioRendererPtr>(inRefCon)->Render(ioActionFlags, inTimeStamp, inNumberFrames, ioData);
        }

        static OSStatus SRNotificationCallback(AudioDeviceID inDevice,
                                            UInt32 inChannel,
                                            Boolean	isInput,
                                            AudioDevicePropertyID inPropertyID,
                                               void* inClientData)
        {
            TCoreAudioRenderer* driver = (TCoreAudioRenderer*)inClientData;
            
            switch (inPropertyID) {
                    
                case kAudioDevicePropertyNominalSampleRate: {
                    //printf("SRNotificationCallback kAudioDevicePropertyNominalSampleRate\n");
                    driver->fState = true;
                    // Check new sample rate
                    Float64 sampleRate;
                    UInt32 outSize = sizeof(Float64);
                    OSStatus err = AudioDeviceGetProperty(inDevice, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyNominalSampleRate, &outSize, &sampleRate);
                    if (err != noErr) {
                        printf("Cannot get current sample rate\n");
                        printError(err);
                    } else {
                        //printf("SRNotificationCallback : checked sample rate = %f\n", sampleRate);
                    }
                    break;
                }
            }
            
            return noErr;
        }

        virtual OSStatus Render(AudioUnitRenderActionFlags *ioActionFlags,
                            const AudioTimeStamp *inTimeStamp,
                            UInt32 inNumberFrames,
                            AudioBufferList *ioData)
        {
            OSStatus err = noErr;
            if (fDevNumInChans > 0) {
                err = AudioUnitRender(fAUHAL, ioActionFlags, inTimeStamp, 1, inNumberFrames, fInputData);
            }
            if (err == noErr) {
                for (int i = 0; i < fDevNumInChans; i++) {
                    fInChannel[i] = (float*)fInputData->mBuffers[i].mData;
                }
                for (int i = 0; i < fDevNumOutChans; i++) {
                    fOutChannel[i] = (float*)ioData->mBuffers[i].mData;
                }
            #ifdef HAS_MATH_EXCEPTION
                TRY_FPE
            #endif
                fDSP->compute(double(AudioConvertHostTimeToNanos(inTimeStamp->mHostTime))/1000., inNumberFrames, fInChannel, fOutChannel);
            #ifdef HAS_MATH_EXCEPTION
                CATCH_FPE
            #endif
                fAudio->runControlCallbacks();
            } else {
                printf("AudioUnitRender error... %x\n", fInputData);
                printError(err);
            }
            return err;
        }
        
    public:
    
        TCoreAudioRenderer(audio* audio)
            :fAggregateDeviceID(-1),fAggregatePluginID(-1),
            fDevNumInChans(0),fDevNumOutChans(0),
            fPhysicalInputs(0), fPhysicalOutputs(0),
            fInChannel(0),fOutChannel(0),
            fBufferSize(0),fSampleRate(0),
            fIsInJackDevice(false),
            fIsOutJackDevice(false),
            fDSP(0),
            fAudio(audio),
            fInputData(0),
            fDeviceID(0),fAUHAL(0),
            fState(false)
        {}

        virtual ~TCoreAudioRenderer()
        {}
        
        int GetBufferSize() {return fBufferSize;}
        int GetSampleRate() {return fSampleRate;}
        
        static OSStatus RestartProc(AudioObjectID objectID, UInt32 numberAddresses,
                                   const AudioObjectPropertyAddress inAddresses[],
                                   void *clientData) 
        {
            /*
            TCoreAudioRenderer* renderer = (TCoreAudioRenderer*)clientData;
            AudioDeviceID defaultDevice;
            UInt32 theSize = sizeof(UInt32);
            OSStatus res;
            char device_name[256];
            
            // Test if new device is "JackRouter"
            if (inAddresses[0].mSelector == kAudioHardwarePropertyDefaultInputDevice) {
                
                if ((res = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultInputDevice,
                                                    &theSize, &defaultDevice)) == noErr) {
                    renderer->GetDeviceNameFromID(defaultDevice, device_name);
                    renderer->fIsInJackDevice = strcmp(device_name, "JackRouter") == 0;
                }
                
            } else  if (inAddresses[0].mSelector == kAudioHardwarePropertyDefaultOutputDevice) {
                
                if ((res = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice,
                                                    &theSize, &defaultDevice)) == noErr) {
                    renderer->GetDeviceNameFromID(defaultDevice, device_name);
                    renderer->fIsOutJackDevice = strcmp(device_name, "JackRouter") == 0;
                }
                
            }
            
            // Switch only of input and output are "JackRouter"
            if (renderer->fIsInJackDevice && renderer->fIsOutJackDevice || !renderer->fIsInJackDevice && !renderer->fIsOutJackDevice) {
                renderer->Stop();
                renderer->Close();
                int sampleRate = -1; // Use the current sample rate
                int bufferSize = (renderer->fBufferSize > 0) ? renderer->fBufferSize : 512; // Use default if needed
                renderer->OpenDefault(renderer->fDSP, renderer->fDevNumInChans, renderer->fDevNumOutChans, bufferSize, sampleRate);
                renderer->Start();
            }
            */
            return 0;
        }
    
        int OpenDefault(dsp* DSP, int inChan, int outChan, int bufferSize, int& sampleRate)
        {
            fDevNumInChans = 0;
            fDevNumOutChans = 0;
            fInChannel = 0;
            fOutChannel = 0;
            fBufferSize = 0;
            fSampleRate = 0;
            fDSP = 0;
            fInputData = 0;
            fDeviceID = 0; 
            fAUHAL = 0;
            fState = false;
            return OpenDefault(inChan, outChan, bufferSize, sampleRate);
        }
    
        int OpenDefault(int inChan, int outChan, int buffer_size, int& sample_rate)
        {
            OSStatus err;
            UInt32 outSize;
            UInt32 enableIO;
            Boolean isWritable;
            AudioStreamBasicDescription srcFormat, dstFormat, sampleRate;
            
            fDevNumInChans = inChan;
            fDevNumOutChans = outChan;
            
            fInChannel = new float*[fDevNumInChans];
            fOutChannel = new float*[fDevNumOutChans];
            
            //printf("OpenDefault inChan = %ld outChan = %ld bufferSize = %ld sample_rate = %ld\n", inChan, outChan, bufferSize, sample_rate);
            
            SInt32 major;
            SInt32 minor;
            Gestalt(gestaltSystemVersionMajor, &major);
            Gestalt(gestaltSystemVersionMinor, &minor);
            
            // Starting with 10.6 systems, the HAL notification thread is created internally
            if (major == 10 && minor >= 6) {
                CFRunLoopRef theRunLoop = NULL;
                AudioObjectPropertyAddress theAddress = { kAudioHardwarePropertyRunLoop, kAudioObjectPropertyScopeGlobal, kAudioObjectPropertyElementMaster };
                OSStatus osErr = AudioObjectSetPropertyData (kAudioObjectSystemObject, &theAddress, 0, NULL, sizeof(CFRunLoopRef), &theRunLoop);
                if (osErr != noErr) {
                    printf("TCoreAudioRenderer::Open kAudioHardwarePropertyRunLoop error\n");
                    printError(osErr);
                }
            }
             
            int outChannelOffset = 0;
            if (GetDefaultDeviceAndSampleRate(inChan, outChan, sample_rate, outChannelOffset, &fDeviceID) != noErr) {
                printf("Cannot open default device\n");
                return OPEN_ERR;
            }
             
            // Setting buffer size
            if (SetupBufferSize(buffer_size) < 0) {
                return OPEN_ERR;
            }
            
            // fBufferSize now has the real value, either 'bufferSize' (if could be changed) or driver current one
            
            // AUHAL
        #if (defined(MAC_OS_X_VERSION_10_5) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_5))
            AudioComponentDescription cd = {kAudioUnitType_Output, kAudioUnitSubType_HALOutput, kAudioUnitManufacturer_Apple, 0, 0};
            AudioComponent HALOutput = AudioComponentFindNext(NULL, &cd);
            err = AudioComponentInstanceNew(HALOutput, &fAUHAL);
            if (err != noErr) {
                printf("Error calling AudioComponentInstanceNew\n");
                printError(err);
                goto error;
            }
        #else
            ComponentDescription cd = {kAudioUnitType_Output, kAudioUnitSubType_HALOutput, kAudioUnitManufacturer_Apple, 0, 0};
            Component HALOutput = FindNextComponent(NULL, &cd);
            err = OpenAComponent(HALOutput, &fAUHAL);
            if (err != noErr) {
                printf("Error calling OpenAComponent\n");
                printError(err);
                goto error;
            }
        #endif
              
            err = AudioUnitInitialize(fAUHAL);
            if (err != noErr) {
                printf("Cannot initialize AUHAL unit\n");
                printError(err);
                goto error;
            }
            
            if (inChan > 0) {
                enableIO = 1;
                //printf("OpenAUHAL : setup AUHAL input on\n");
            } else {
                enableIO = 0;
                //printf("OpenAUHAL : setup AUHAL input off\n");
            }
            
            err = AudioUnitSetProperty(fAUHAL, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Input, 1, &enableIO, sizeof(enableIO));
            if (err != noErr) {
                printf("Error calling AudioUnitSetProperty - kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Input\n");
                printError(err);
                goto error;
            }
                
            if (outChan > 0) {
                enableIO = 1;
                //printf("OpenAUHAL : setup AUHAL output on\n");
            } else {
                enableIO = 0;
                //printf("OpenAUHAL : setup AUHAL output off\n");
            }
            
            err = AudioUnitSetProperty(fAUHAL, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output, 0, &enableIO, sizeof(enableIO));
            if (err != noErr) {
                printf("Error calling AudioUnitSetProperty - kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output\n");
                printError(err);
                goto error;
            }
            
            AudioDeviceID currAudioDeviceID;
            outSize = sizeof(AudioDeviceID);
            err = AudioUnitGetProperty(fAUHAL, kAudioOutputUnitProperty_CurrentDevice, kAudioUnitScope_Global, 0, &currAudioDeviceID, &outSize);
            if (err != noErr) {
                printf("Error calling AudioUnitGetProperty - kAudioOutputUnitProperty_CurrentDevice\n");
                printError(err);
                goto error;
            } else {
                //printf("AudioUnitGetPropertyCurrentDevice = %d\n", currAudioDeviceID);
            }
        
            // Setup up choosen device, in both input and output cases
            err = AudioUnitSetProperty(fAUHAL, kAudioOutputUnitProperty_CurrentDevice, kAudioUnitScope_Global, 0, &fDeviceID, sizeof(AudioDeviceID));
            if (err != noErr) {
                printf("Error calling AudioUnitSetProperty - kAudioOutputUnitProperty_CurrentDevice\n");
                printError(err);
                goto error;
            }
            
            if (inChan > 0) {
                err = AudioUnitSetProperty(fAUHAL, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 1, (UInt32*)&fBufferSize, sizeof(UInt32));
                if (err != noErr) {
                    printf("Error calling AudioUnitSetProperty - kAudioUnitProperty_MaximumFramesPerSlice\n");
                    printError(err);
                    goto error;
                }
            }
            
            if (outChan > 0) {
                err = AudioUnitSetProperty(fAUHAL, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, (UInt32*)&fBufferSize, sizeof(UInt32));
                if (err != noErr) {
                    printf("Error calling AudioUnitSetProperty - kAudioUnitProperty_MaximumFramesPerSlice\n");
                    printError(err);
                    goto error;
                }
            }
            
            err = AudioUnitGetPropertyInfo(fAUHAL, kAudioOutputUnitProperty_ChannelMap, kAudioUnitScope_Input, 1, &outSize, &isWritable);
            if (err != noErr) {
                //printf("Error calling AudioUnitGetPropertyInfo - kAudioOutputUnitProperty_ChannelMap 1\n");
                //printError(err);
            } else {
                fPhysicalInputs = outSize / sizeof(SInt32);
                //printf("fPhysicalInputs = %ld\n", fPhysicalInputs);
            }
                    
            err = AudioUnitGetPropertyInfo(fAUHAL, kAudioOutputUnitProperty_ChannelMap, kAudioUnitScope_Output, 0, &outSize, &isWritable);
            if (err != noErr) {
                //printf("Error calling AudioUnitGetPropertyInfo - kAudioOutputUnitProperty_ChannelMap 0\n");
                //printError(err);
            } else {
                fPhysicalOutputs = outSize / sizeof(SInt32);
                //printf("fPhysicalOutputs = %ld\n", fPhysicalOutputs);
            }
            
            /*
             Just ignore this case : seems to work without any further change...
             
             if (outChannelOffset + outChan > fPhysicalOutputs) {
                printf("This device hasn't required output channels\n");
                goto error;
             }
             if (inChan > fPhysicalInputs) {
                printf("This device hasn't required input channels\n");
                goto error;
             }
             */
            
            if (inChan < fPhysicalInputs) {
                SInt32 chanArr[fPhysicalInputs];
                for (int i = 0; i < fPhysicalInputs; i++) {
                    chanArr[i] = -1;
                }
                for (int i = 0; i < inChan; i++) {
                    chanArr[i] = i;
                }
                AudioUnitSetProperty(fAUHAL, kAudioOutputUnitProperty_ChannelMap , kAudioUnitScope_Input, 1, chanArr, sizeof(SInt32) * fPhysicalInputs);
                if (err != noErr) {
                    printf("Error calling AudioUnitSetProperty - kAudioOutputUnitProperty_ChannelMap 1\n");
                    printError(err);
                }
            }
            
            if (outChan < fPhysicalOutputs) {
                SInt32 chanArr[fPhysicalOutputs];
                for (int i = 0;	i < fPhysicalOutputs; i++) {
                    chanArr[i] = -1;
                }
                for (int i = 0; i < outChan; i++) {
                    // Skip past the output channels belonging to the *input* device, skip to the output channels belonging to the *output* device
                    chanArr[outChannelOffset + i] = i;
                }
                err = AudioUnitSetProperty(fAUHAL, kAudioOutputUnitProperty_ChannelMap, kAudioUnitScope_Output, 0, chanArr, sizeof(SInt32) * fPhysicalOutputs);
                if (err != noErr) {
                    printf("Error calling AudioUnitSetProperty - kAudioOutputUnitProperty_ChannelMap 0\n");
                    printError(err);
                }
            }
            
            if (inChan > 0) {
                outSize = sizeof(AudioStreamBasicDescription);
                err = AudioUnitGetProperty(fAUHAL, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 1, &srcFormat, &outSize);
                if (err != noErr) {
                    printf("Error calling AudioUnitGetProperty - kAudioUnitProperty_StreamFormat kAudioUnitScope_Output\n");
                    printError(err);
                }
                //PrintStreamDesc(&srcFormat);
                
                srcFormat.mSampleRate = sample_rate;
                srcFormat.mFormatID = kAudioFormatLinearPCM;
                srcFormat.mFormatFlags = kAudioFormatFlagsNativeFloatPacked | kLinearPCMFormatFlagIsNonInterleaved;
                srcFormat.mBytesPerPacket = sizeof(float);
                srcFormat.mFramesPerPacket = 1;
                srcFormat.mBytesPerFrame = sizeof(float);
                srcFormat.mChannelsPerFrame = inChan;
                srcFormat.mBitsPerChannel = 32;
                
                //PrintStreamDesc(&srcFormat);
                
                err = AudioUnitSetProperty(fAUHAL, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 1, &srcFormat, sizeof(AudioStreamBasicDescription));
                if (err != noErr) {
                    printf("Error calling AudioUnitSetProperty - kAudioUnitProperty_StreamFormat kAudioUnitScope_Output\n");
                    printError(err);
                }
            }
            
            if (outChan > 0) {
                outSize = sizeof(AudioStreamBasicDescription);
                err = AudioUnitGetProperty(fAUHAL, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &dstFormat, &outSize);
                if (err != noErr) {
                    printf("Error calling AudioUnitGetProperty - kAudioUnitProperty_StreamFormat kAudioUnitScope_Output\n");
                    printError(err);
                }
                //PrintStreamDesc(&dstFormat);
                
                dstFormat.mSampleRate = sample_rate;
                dstFormat.mFormatID = kAudioFormatLinearPCM;
                dstFormat.mFormatFlags = kAudioFormatFlagsNativeFloatPacked | kLinearPCMFormatFlagIsNonInterleaved;
                dstFormat.mBytesPerPacket = sizeof(float);
                dstFormat.mFramesPerPacket = 1;
                dstFormat.mBytesPerFrame = sizeof(float);
                dstFormat.mChannelsPerFrame = outChan;
                dstFormat.mBitsPerChannel = 32;
                
                //PrintStreamDesc(&dstFormat);
                
                err = AudioUnitSetProperty(fAUHAL, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &dstFormat, sizeof(AudioStreamBasicDescription));
                if (err != noErr) {
                    printf("Error calling AudioUnitSetProperty - kAudioUnitProperty_StreamFormat kAudioUnitScope_Output\n");
                    printError(err);
                }
            }
            
            if (inChan > 0 && outChan == 0) {
                AURenderCallbackStruct output;
                output.inputProc = Render;
                output.inputProcRefCon = this;
                err = AudioUnitSetProperty(fAUHAL, kAudioOutputUnitProperty_SetInputCallback, kAudioUnitScope_Global, 0, &output, sizeof(output));
                if (err != noErr) {
                    printf("Error calling AudioUnitSetProperty - kAudioUnitProperty_SetRenderCallback 1\n");
                    printError(err);
                    goto error;
                }
            } else {
                AURenderCallbackStruct output;
                output.inputProc = Render;
                output.inputProcRefCon = this;
                err = AudioUnitSetProperty(fAUHAL, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Input, 0, &output, sizeof(output));
                if (err != noErr) {
                    printf("Error calling AudioUnitSetProperty - kAudioUnitProperty_SetRenderCallback 0\n");
                    printError(err);
                    goto error;
                }
            }
            
            if (inChan > 0) {
                fInputData = (AudioBufferList*)malloc(sizeof(UInt32) + inChan * sizeof(AudioBuffer));
                assert(fInputData);
                fInputData->mNumberBuffers = inChan;
                
                // Prepare buffers
                for (int i = 0; i < inChan; i++) {
                    fInputData->mBuffers[i].mNumberChannels = 1;
                    fInputData->mBuffers[i].mData = malloc(fBufferSize * sizeof(float));
                    assert(fInputData->mBuffers[i].mData),
                    fInputData->mBuffers[i].mDataByteSize = fBufferSize * sizeof(float);
                }
            }
            
            AudioObjectPropertyAddress property_address;
            property_address.mScope = kAudioObjectPropertyScopeGlobal;
            property_address.mElement = kAudioObjectPropertyElementMaster;
            
            property_address.mSelector = kAudioHardwarePropertyDefaultInputDevice;
            if (AudioObjectAddPropertyListener(kAudioObjectSystemObject, &property_address, RestartProc, this)) {
                printf("AudioObjectAddPropertyListener() failed\n");
                return OPEN_ERR;
            } else {
                //printf("AudioObjectAddPropertyListener() OK\n");
            }
            
            property_address.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
            if (AudioObjectAddPropertyListener(kAudioObjectSystemObject, &property_address, RestartProc, this)) {
                printf("AudioObjectAddPropertyListener() failed\n");
                return OPEN_ERR;
            } else {
                //printf("AudioObjectAddPropertyListener() OK\n");
            }
             
            return NO_ERR;
            
        error:
            AudioUnitUninitialize(fAUHAL);
            CloseComponent(fAUHAL);
            fAUHAL = 0;
            return OPEN_ERR;
        }
        
        int Close()
        {
            if (!fAUHAL) {
                return CLOSE_ERR;
            }
            
            for (int i = 0; i < fDevNumInChans; i++) {
                free(fInputData->mBuffers[i].mData);
            }
            if (fInputData) {
                free(fInputData);
            }
            AudioUnitUninitialize(fAUHAL);
            CloseComponent(fAUHAL);
            fAUHAL = NULL;
            
            DestroyAggregateDevice();
            
            delete[] fInChannel;
            delete[] fOutChannel;
            
            AudioObjectPropertyAddress property_address;
            property_address.mScope = kAudioObjectPropertyScopeGlobal;
            property_address.mElement = kAudioObjectPropertyElementMaster;
            
            property_address.mSelector = kAudioHardwarePropertyDefaultInputDevice;
            AudioObjectRemovePropertyListener(kAudioObjectSystemObject, &property_address, RestartProc, this);
            
            property_address.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
            AudioObjectRemovePropertyListener(kAudioObjectSystemObject, &property_address, RestartProc, this);
            
            return NO_ERR;
        }

        int Start()
        {
            if (!fAUHAL) {
                return OPEN_ERR;
            }
            
            OSStatus err = AudioOutputUnitStart(fAUHAL);
            
            if (err != noErr) {
                printf("Error while opening device : device open error \n");
                return OPEN_ERR;
            } else {
                return NO_ERR;
            }
        }
        
        int Stop()
        {
            if (!fAUHAL) {
                return OPEN_ERR;
            }
            
            OSStatus err = AudioOutputUnitStop(fAUHAL);
            
            if (err != noErr) {
                printf("Error while closing device : device close error \n");
                return OPEN_ERR;
            } else {
                return NO_ERR;
            }
        }
    
        void setDsp(dsp* DSP)
        {
            fDSP = DSP;
        }
        
        int GetNumInputs() { return fPhysicalInputs; }
        int GetNumOutputs() { return fPhysicalOutputs; }

};

/******************************************************************************
*******************************************************************************

							CORE AUDIO INTERFACE

*******************************************************************************
*******************************************************************************/
class coreaudio : public audio {

    protected:
        
        TCoreAudioRenderer fAudioDevice;
        int fSampleRate, fBufferSize;

    public:
      
        coreaudio(int srate, int bsize) : fAudioDevice(this), fSampleRate(srate), fBufferSize(bsize) {}
        coreaudio(int bsize) : fAudioDevice(this), fSampleRate(-1), fBufferSize(bsize) {}
        virtual ~coreaudio() { fAudioDevice.Close(); }

        virtual bool init(const char* /*name*/, dsp* DSP) 
        {
            if (fAudioDevice.OpenDefault(DSP, DSP->getNumInputs(), DSP->getNumOutputs(), fBufferSize, fSampleRate) < 0) {
                printf("Cannot open CoreAudio device\n");
                return false;
            }
            fAudioDevice.setDsp(DSP);
            // If -1 was given, fSampleRate will be changed by OpenDefault
            DSP->init(fSampleRate);
            return true;
        }

        virtual bool start() 
        {
            if (fAudioDevice.Start() < 0) {
                printf("Cannot start CoreAudio device\n");
                return false;
            }
            return true;
        }

        virtual void stop() 
        {
            fAudioDevice.Stop();
        }
        
        virtual int getBufferSize() { return fAudioDevice.GetBufferSize(); }
        virtual int getSampleRate() { return fAudioDevice.GetSampleRate(); }
        
        virtual int getNumInputs() { return fAudioDevice.GetNumInputs(); }
        virtual int getNumOutputs() { return fAudioDevice.GetNumOutputs(); }

};

#endif

/********************END ARCHITECTURE SECTION (part 2/2)****************/


/**************************  END  coreaudio-dsp.h **************************/

#ifdef OSCCTRL
/************************** BEGIN OSCUI.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 *********************************************************************/

#ifndef __OSCUI__
#define __OSCUI__

#include <vector>
#include <string>

/*

  Faust Project

  Copyright (C) 2011 Grame

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

  Grame Research Laboratory, 9 rue du Garet, 69001 Lyon - France
  research@grame.fr

*/

#ifndef __OSCControler__
#define __OSCControler__

#include <string>
/*

  Copyright (C) 2011 Grame

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

  Grame Research Laboratory, 9 rue du Garet, 69001 Lyon - France
  research@grame.fr

*/

#ifndef __FaustFactory__
#define __FaustFactory__

#include <stack>
#include <string>
#include <sstream>

/*

  Copyright (C) 2011 Grame

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

  Grame Research Laboratory, 9 rue du Garet, 69001 Lyon - France
  research@grame.fr

*/

#ifndef __FaustNode__
#define __FaustNode__

#include <string>
#include <vector>

/*

  Copyright (C) 2011 Grame

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

  Grame Research Laboratory, 9 rue du Garet, 69001 Lyon - France
  research@grame.fr

*/

#ifndef __MessageDriven__
#define __MessageDriven__

#include <string>
#include <vector>

/*

  Copyright (C) 2010  Grame

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

  Grame Research Laboratory, 9 rue du Garet, 69001 Lyon - France
  research@grame.fr

*/

#ifndef __MessageProcessor__
#define __MessageProcessor__

namespace oscfaust
{

class Message;
//--------------------------------------------------------------------------
/*!
	\brief an abstract class for objects able to process OSC messages	
*/
class MessageProcessor
{
	public:
		virtual		~MessageProcessor() {}
		virtual void processMessage( const Message* msg ) = 0;
};

} // end namespoace

#endif
/*

  Copyright (C) 2011 Grame

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

  Grame Research Laboratory, 9 rue du Garet, 69001 Lyon - France
  research@grame.fr

*/

#ifndef __smartpointer__
#define __smartpointer__

#include <cassert>

namespace oscfaust
{

/*!
\brief the base class for smart pointers implementation

	Any object that want to support smart pointers should
	inherit from the smartable class which provides reference counting
	and automatic delete when the reference count drops to zero.
*/
class smartable {
	private:
		unsigned 	refCount;		
	public:
		//! gives the reference count of the object
		unsigned refs() const         { return refCount; }
		//! addReference increments the ref count and checks for refCount overflow
		void addReference()           { refCount++; assert(refCount != 0); }
		//! removeReference delete the object when refCount is zero		
		void removeReference()		  { if (--refCount == 0) delete this; }
		
	protected:
		smartable() : refCount(0) {}
		smartable(const smartable&): refCount(0) {}
		//! destructor checks for non-zero refCount
		virtual ~smartable()    
        { 
            /* 
                See "Static SFaustNode create (const char* name, C* zone, C init, C min, C max, const char* prefix, GUI* ui)" comment.
                assert (refCount == 0); 
            */
        }
		smartable& operator=(const smartable&) { return *this; }
};

/*!
\brief the smart pointer implementation

	A smart pointer is in charge of maintaining the objects reference count 
	by the way of pointers operators overloading. It supports class 
	inheritance and conversion whenever possible.
\n	Instances of the SMARTP class are supposed to use \e smartable types (or at least
	objects that implements the \e addReference and \e removeReference
	methods in a consistent way).
*/
template<class T> class SMARTP {
	private:
		//! the actual pointer to the class
		T* fSmartPtr;

	public:
		//! an empty constructor - points to null
		SMARTP()	: fSmartPtr(0) {}
		//! build a smart pointer from a class pointer
		SMARTP(T* rawptr) : fSmartPtr(rawptr)              { if (fSmartPtr) fSmartPtr->addReference(); }
		//! build a smart pointer from an convertible class reference
		template<class T2> 
		SMARTP(const SMARTP<T2>& ptr) : fSmartPtr((T*)ptr) { if (fSmartPtr) fSmartPtr->addReference(); }
		//! build a smart pointer from another smart pointer reference
		SMARTP(const SMARTP& ptr) : fSmartPtr((T*)ptr)     { if (fSmartPtr) fSmartPtr->addReference(); }

		//! the smart pointer destructor: simply removes one reference count
		~SMARTP()  { if (fSmartPtr) fSmartPtr->removeReference(); }
		
		//! cast operator to retrieve the actual class pointer
		operator T*() const  { return fSmartPtr;	}

		//! '*' operator to access the actual class pointer
		T& operator*() const {
			// checks for null dereference
			assert (fSmartPtr != 0);
			return *fSmartPtr;
		}

		//! operator -> overloading to access the actual class pointer
		T* operator->() const	{ 
			// checks for null dereference
			assert (fSmartPtr != 0);
			return fSmartPtr;
		}

		//! operator = that moves the actual class pointer
		template <class T2>
		SMARTP& operator=(T2 p1_)	{ *this=(T*)p1_; return *this; }

		//! operator = that moves the actual class pointer
		SMARTP& operator=(T* p_)	{
			// check first that pointers differ
			if (fSmartPtr != p_) {
				// increments the ref count of the new pointer if not null
				if (p_ != 0) p_->addReference();
				// decrements the ref count of the old pointer if not null
				if (fSmartPtr != 0) fSmartPtr->removeReference();
				// and finally stores the new actual pointer
				fSmartPtr = p_;
			}
			return *this;
		}
		//! operator < to support SMARTP map with Visual C++
		bool operator<(const SMARTP<T>& p_)	const			  { return fSmartPtr < ((T *) p_); }
		//! operator = to support inherited class reference
		SMARTP& operator=(const SMARTP<T>& p_)                { return operator=((T *) p_); }
		//! dynamic cast support
		template<class T2> SMARTP& cast(T2* p_)               { return operator=(dynamic_cast<T*>(p_)); }
		//! dynamic cast support
		template<class T2> SMARTP& cast(const SMARTP<T2>& p_) { return operator=(dynamic_cast<T*>(p_)); }
};

}

#endif

namespace oscfaust
{

class Message;
class OSCRegexp;
class MessageDriven;
typedef class SMARTP<MessageDriven>	SMessageDriven;

//--------------------------------------------------------------------------
/*!
	\brief a base class for objects accepting OSC messages
	
	Message driven objects are hierarchically organized in a tree.
	They provides the necessary to dispatch an OSC message to its destination
	node, according to the message OSC address. 
	
	The principle of the dispatch is the following:
	- first the processMessage() method should be called on the top level node
	- next processMessage call propose 
*/
class MessageDriven : public MessageProcessor, public smartable
{
	std::string						fName;			///< the node name
	std::string						fOSCPrefix;		///< the node OSC address prefix (OSCAddress = fOSCPrefix + '/' + fName)
	std::vector<SMessageDriven>		fSubNodes;		///< the subnodes of the current node

	protected:
				 MessageDriven(const char *name, const char *oscprefix) : fName (name), fOSCPrefix(oscprefix) {}
		virtual ~MessageDriven() {}

	public:
		static SMessageDriven create(const char* name, const char *oscprefix)	{ return new MessageDriven(name, oscprefix); }

		/*!
			\brief OSC message processing method.
			\param msg the osc message to be processed
			The method should be called on the top level node.
		*/
		virtual void	processMessage(const Message* msg);

		/*!
			\brief propose an OSc message at a given hierarchy level.
			\param msg the osc message currently processed
			\param regexp a regular expression based on the osc address head
			\param addrTail the osc address tail
			
			The method first tries to match the regular expression with the object name. 
			When it matches:
			- it calls \c accept when \c addrTail is empty 
			- or it \c propose the message to its subnodes when \c addrTail is not empty. 
			  In this case a new \c regexp is computed with the head of \c addrTail and a new \c addrTail as well.
		*/
		virtual void	propose(const Message* msg, const OSCRegexp* regexp, const std::string& addrTail);

		/*!
			\brief accept an OSC message. 
			\param msg the osc message currently processed
			\return true when the message is processed by the node
			
			The method is called only for the destination nodes. The real message acceptance is the node 
			responsability and may depend on the message content.
		*/
		virtual bool	accept(const Message* msg);

		/*!
			\brief handler for the \c 'get' message
			\param ipdest the output message destination IP
			
			The \c 'get' message is supported by every node:
			- it is propagated to the subnodes until it reaches terminal nodes
			- a terminal node send its state on \c 'get' request to the IP address given as parameter.
			The \c get method is basically called by the accept method.
		*/
		virtual void	get(unsigned long ipdest) const;

		/*!
			\brief handler for the \c 'get' 'attribute' message
			\param ipdest the output message destination IP
			\param what the requested attribute
			
			The \c 'get' message is supported by every node:
			- it is propagated to the subnodes until it reaches terminal nodes
			- a terminal node send its state on \c 'get' request to the IP address given as parameter.
			The \c get method is basically called by the accept method.
		*/
		virtual void	get(unsigned long ipdest, const std::string& what) const {}

		void			add(SMessageDriven node)	{ fSubNodes.push_back (node); }
		const char*		getName() const				{ return fName.c_str(); }
		std::string		getOSCAddress() const;
		int				size() const				{ return (int)fSubNodes.size (); }
		
		const std::string&	name() const			{ return fName; }
		SMessageDriven	subnode(int i)              { return fSubNodes[i]; }
};

} // end namespoace

#endif
/*

  Copyright (C) 2011  Grame

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

  Grame Research Laboratory, 9 rue du Garet, 69001 Lyon - France
  research@grame.fr

*/


#ifndef __Message__
#define __Message__

#include <string>
#include <vector>

namespace oscfaust
{

class OSCStream;
template <typename T> class MsgParam;
class baseparam;
typedef SMARTP<baseparam>	Sbaseparam;

//--------------------------------------------------------------------------
/*!
	\brief base class of a message parameters
*/
class baseparam : public smartable
{
	public:
		virtual ~baseparam() {}

		/*!
		 \brief utility for parameter type checking
		*/
		template<typename X> bool isType() const { return dynamic_cast<const MsgParam<X>*> (this) != 0; }
		/*!
		 \brief utility for parameter convertion
		 \param errvalue the returned value when no conversion applies
		 \return the parameter value when the type matches
		*/
		template<typename X> X	value(X errvalue) const 
			{ const MsgParam<X>* o = dynamic_cast<const MsgParam<X>*> (this); return o ? o->getValue() : errvalue; }
		/*!
		 \brief utility for parameter comparison
		*/
		template<typename X> bool	equal(const baseparam& p) const 
			{ 
				const MsgParam<X>* a = dynamic_cast<const MsgParam<X>*> (this); 
				const MsgParam<X>* b = dynamic_cast<const MsgParam<X>*> (&p);
				return a && b && (a->getValue() == b->getValue());
			}
		/*!
		 \brief utility for parameter comparison
		*/
		bool operator==(const baseparam& p) const 
			{ 
				return equal<float>(p) || equal<int>(p) || equal<std::string>(p);
			}
		bool operator!=(const baseparam& p) const
			{ 
				return !equal<float>(p) && !equal<int>(p) && !equal<std::string>(p);
			}
			
		virtual SMARTP<baseparam> copy() const = 0;
};

//--------------------------------------------------------------------------
/*!
	\brief template for a message parameter
*/
template <typename T> class MsgParam : public baseparam
{
	T fParam;
	public:
				 MsgParam(T val) : fParam(val)	{}
		virtual ~MsgParam() {}
		
		T getValue() const { return fParam; }
		
		virtual Sbaseparam copy() const { return new MsgParam<T>(fParam); }
};

//--------------------------------------------------------------------------
/*!
	\brief a message description
	
	A message is composed of an address (actually an OSC address),
	a message string that may be viewed as a method name
	and a list of message parameters.
*/
class Message
{
    public:
        typedef SMARTP<baseparam>		argPtr;		///< a message argument ptr type
        typedef std::vector<argPtr>		argslist;	///< args list type

    private:
        unsigned long	fSrcIP;			///< the message source IP number
        std::string	fAddress;			///< the message osc destination address
        std::string	fAlias;             ///< the message alias osc destination address
        argslist	fArguments;			///< the message arguments

    public:
            /*!
                \brief an empty message constructor
            */
             Message() {}
            /*!
                \brief a message constructor
                \param address the message destination address
            */
            Message(const std::string& address) : fAddress(address), fAlias("") {}
             
            Message(const std::string& address, const std::string& alias) : fAddress(address), fAlias(alias) {}
            /*!
                \brief a message constructor
                \param address the message destination address
                \param args the message parameters
            */
            Message(const std::string& address, const argslist& args) 
                : fAddress(address), fArguments(args) {}
            /*!
                \brief a message constructor
                \param msg a message
            */
             Message(const Message& msg);
    virtual ~Message() {} //{ freed++; std::cout << "running messages: " << (allocated - freed) << std::endl; }

    /*!
        \brief adds a parameter to the message
        \param val the parameter
    */
    template <typename T> void add(T val)	{ fArguments.push_back(new MsgParam<T>(val)); }
    /*!
        \brief adds a float parameter to the message
        \param val the parameter value
    */
    void	add(float val)					{ add<float>(val); }
    
    /*!
     \brief adds a double parameter to the message
     \param val the parameter value
     */
    void	add(double val)					{ add<double>(val); }
    
    /*!
        \brief adds an int parameter to the message
        \param val the parameter value
    */
    void	add(int val)					{ add<int>(val); }
    
    /*!
        \brief adds a string parameter to the message
        \param val the parameter value
    */
    void	add(const std::string& val)		{ add<std::string>(val); }

    /*!
        \brief adds a parameter to the message
        \param val the parameter
    */
    void	add(argPtr val)                 { fArguments.push_back( val ); }

    /*!
        \brief sets the message address
        \param addr the address
    */
    void				setSrcIP(unsigned long addr)		{ fSrcIP = addr; }

    /*!
        \brief sets the message address
        \param addr the address
    */
    void				setAddress(const std::string& addr)		{ fAddress = addr; }
    /*!
        \brief print the message
        \param out the output stream
    */
    void				print(std::ostream& out) const;
    /*!
        \brief send the message to OSC
        \param out the OSC output stream
    */
    void				print(OSCStream& out) const;
    /*!
        \brief print message arguments
        \param out the OSC output stream
    */
    void				printArgs(OSCStream& out) const;

    /// \brief gives the message address
    const std::string&	address() const		{ return fAddress; }
    /// \brief gives the message alias
    const std::string&	alias() const		{ return fAlias; }
    /// \brief gives the message parameters list
    const argslist&		params() const		{ return fArguments; }
    /// \brief gives the message parameters list
    argslist&			params()			{ return fArguments; }
    /// \brief gives the message source IP 
    unsigned long		src() const			{ return fSrcIP; }
    /// \brief gives the message parameters count
    int					size() const		{ return (int)fArguments.size(); }

    bool operator == (const Message& other) const;	

    /*!
        \brief gives a message float parameter
        \param i the parameter index (0 <= i < size())
        \param val on output: the parameter value when the parameter type matches
        \return false when types don't match
    */
    bool	param(int i, float& val) const		{ val = params()[i]->value<float>(val); return params()[i]->isType<float>(); }
    
    /*!
     \brief gives a message double parameter
     \param i the parameter index (0 <= i < size())
     \param val on output: the parameter value when the parameter type matches
     \return false when types don't match
     */
    bool	param(int i, double& val) const		{ val = params()[i]->value<double>(val); return params()[i]->isType<double>(); }
    
    /*!
        \brief gives a message int parameter
        \param i the parameter index (0 <= i < size())
        \param val on output: the parameter value when the parameter type matches
        \return false when types don't match
    */
    bool	param(int i, int& val) const		{ val = params()[i]->value<int>(val); return params()[i]->isType<int>(); }
    /*!
        \brief gives a message int parameter
        \param i the parameter index (0 <= i < size())
        \param val on output: the parameter value when the parameter type matches
        \return false when types don't match
    */
    bool	param(int i, unsigned int& val) const		{ val = params()[i]->value<int>(val); return params()[i]->isType<int>(); }
    /*!
        \brief gives a message int parameter
        \param i the parameter index (0 <= i < size())
        \param val on output: the parameter value when the parameter type matches
        \return false when types don't match
        \note a boolean value is handled as integer
    */
    bool	param(int i, bool& val) const		{ int ival = 0; ival = params()[i]->value<int>(ival); val = ival!=0; return params()[i]->isType<int>(); }
    /*!
        \brief gives a message int parameter
        \param i the parameter index (0 <= i < size())
        \param val on output: the parameter value when the parameter type matches
        \return false when types don't match
    */
    bool	param(int i, long int& val) const	{ val = long(params()[i]->value<int>(val)); return params()[i]->isType<int>(); }
    /*!
        \brief gives a message string parameter
        \param i the parameter index (0 <= i < size())
        \param val on output: the parameter value when the parameter type matches
        \return false when types don't match
    */
    bool	param(int i, std::string& val) const { val = params()[i]->value<std::string>(val); return params()[i]->isType<std::string>(); }
};


} // end namespoace

#endif
/*

  Copyright (C) 2011 Grame

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

  Grame Research Laboratory, 9 rue du Garet, 69001 Lyon - France
  research@grame.fr

*/

#ifndef __RootNode__
#define __RootNode__

#include <map>
#include <string>
#include <vector>


namespace oscfaust
{

class OSCIO;
class RootNode;
typedef class SMARTP<RootNode> SRootNode;

/**
 * an alias target includes a map to rescale input values to output values
 * and a target osc address. The input values can be given in reversed order
 * to reverse the control
 */
struct aliastarget
{
	double      fMinIn;
	double      fMaxIn;
	double      fMinOut;
	double      fMaxOut;
	std::string fTarget;	// the real osc address

	aliastarget(const char* address, double imin, double imax, double omin, double omax)
		: fMinIn(imin), fMaxIn(imax), fMinOut(omin), fMaxOut(omax), fTarget(address) {}

    aliastarget(const aliastarget& t)
        : fMinIn(t.fMinIn), fMaxIn(t.fMaxIn), fMinOut(t.fMinOut), fMaxOut(t.fMaxOut), fTarget(t.fTarget) {}
    
    // explicit copy assignment operator
    aliastarget& operator=(const aliastarget& other) { return *this; }
    
	double scale(double x) const 
    {
        if (fMinIn < fMaxIn) {
            // increasing control
            double z = (x < fMinIn) ? fMinIn : (x > fMaxIn) ? fMaxIn : x;
            return fMinOut + (z-fMinIn)*(fMaxOut-fMinOut)/(fMaxIn-fMinIn);
            
        } else if (fMinIn > fMaxIn) {
            // reversed control
            double z = (x < fMaxIn) ? fMaxIn : (x > fMinIn) ? fMinIn : x;
            return fMinOut + (fMinIn-z)*(fMaxOut-fMinOut)/(fMinIn-fMaxIn);
            
        } else {
            // no control !
            return (fMinOut+fMaxOut)/2.0f;
        }
    }
    
    double invscale(double x) const
    {
        if (fMinOut < fMaxOut) {
            // increasing control
            double z = (x < fMinOut) ? fMinOut : (x > fMaxOut) ? fMaxOut : x;
            return fMinIn + (z-fMinOut)*(fMaxIn-fMinIn)/(fMaxOut-fMinOut);
            
        } else if (fMinOut > fMaxOut) {
            // reversed control
            double z = (x < fMaxOut) ? fMaxOut : (x > fMinOut) ? fMinOut : x;
            return fMinIn + (fMinOut-z)*(fMaxIn-fMinIn)/(fMinOut-fMaxOut);
            
        } else {
            // no control !
            return (fMinIn+fMaxIn)/2.0f;
        }
    }
};

//--------------------------------------------------------------------------
/*!
	\brief a faust root node

	A Faust root node handles the \c 'hello' message and provides support
	for incoming osc signal data. 
*/
class RootNode : public MessageDriven
{

    private:
        int *fUPDIn, *fUDPOut, *fUDPErr;    // the osc port numbers (required by the hello method)
        OSCIO* fIO;                         // an OSC IO controler
        JSONUI* fJSON;

        typedef std::map<std::string, std::vector<aliastarget> > TAliasMap;
        TAliasMap fAliases;

        template <typename T>
        void processAliasAux(const std::string& address, T val);
        void processAlias(const std::string& address, float val);
        void processAlias(const std::string& address, double val);
    
        void eraseAliases(const std::string& target);
        void eraseAlias(const std::string& target, const std::string& alias);
        bool aliasError(const Message* msg);

    protected:
        RootNode(const char *name, JSONUI* json, OSCIO* io = NULL) : MessageDriven(name, ""), fUPDIn(0), fUDPOut(0), fUDPErr(0), fIO(io), fJSON(json) {}
        virtual ~RootNode() {}

    public:
        static SRootNode create(const char* name, JSONUI* json, OSCIO* io = NULL) { return new RootNode(name, json, io); }

        virtual void processMessage(const Message* msg);
        virtual bool accept(const Message* msg);
        virtual void get(unsigned long ipdest) const;
        virtual void get(unsigned long ipdest, const std::string& what) const;

        template <typename T>
        bool aliasMsgAux(const Message* msg, T omin, T omax);
        bool aliasMsg(const Message* msg, double omin, double omax);
        bool aliasMsg(const Message* msg, float omin, float omax);
    
        template <typename T>
        void addAliasAux(const char* alias, const char* address, T imin, T imax, T omin, T omax);
        void addAlias(const char* alias, const char* address, float imin, float imax, float omin, float omax);
        void addAlias(const char* alias, const char* address, double imin, double imax, double omin, double omax);
    
        bool acceptSignal(const Message* msg);      ///< handler for signal data
        void hello(unsigned long ipdest) const;     ///< handler for the 'hello' message
        void setPorts(int* in, int* out, int* err);

        std::vector<std::pair<std::string, double> > getAliases(const std::string& address, double value);
};

} // end namespoace

#endif

namespace oscfaust
{

/**
 * map (rescale) input values to output values
 */
template <typename C> struct mapping
{
	const C fMinOut;
	const C fMaxOut;
	mapping(C omin, C omax) : fMinOut(omin), fMaxOut(omax) {}
	C clip (C x) { return (x < fMinOut) ? fMinOut : (x > fMaxOut) ? fMaxOut : x; }
};

//--------------------------------------------------------------------------
/*!
	\brief a faust node is a terminal node and represents a faust parameter controler
*/
template <typename C> class FaustNode : public MessageDriven, public uiTypedItemReal<C>
{
	mapping<C>	fMapping;
    RootNode*   fRoot;
    bool        fInput;  // true for input nodes (slider, button...)
	
	//---------------------------------------------------------------------
	// Warning !!!
	// The cast (C*)fZone is necessary because the real size allocated is
	// only known at execution time. When the library is compiled, fZone is
	// uniquely defined by FAUSTFLOAT.
	//---------------------------------------------------------------------
	bool store(C val) { *(C*)this->fZone = fMapping.clip(val); return true; }
	void sendOSC() const;

	protected:
		FaustNode(RootNode* root, const char *name, C* zone, C init, C min, C max, const char* prefix, GUI* ui, bool initZone, bool input) 
			: MessageDriven(name, prefix), uiTypedItemReal<C>(ui, zone), fMapping(min, max), fRoot(root), fInput(input)
			{
                if (initZone) {
                    *zone = init; 
                }
            }
			
		virtual ~FaustNode() {}

	public:
		typedef SMARTP<FaustNode<C> > SFaustNode;
		static SFaustNode create(RootNode* root, const char* name, C* zone, C init, C min, C max, const char* prefix, GUI* ui, bool initZone, bool input)	
        { 
            SFaustNode node = new FaustNode(root, name, zone, init, min, max, prefix, ui, initZone, input); 
            /*
                Since FaustNode is a subclass of uiItem, the pointer will also be kept in the GUI class, and it's desallocation will be done there.
                So we don't want to have smartpointer logic desallocate it and we increment the refcount.
            */
            node->addReference();
            return node; 
        }
    
		bool accept(const Message* msg);
		void get(unsigned long ipdest) const;		///< handler for the 'get' message
		virtual void reflectZone() { sendOSC(); this->fCache = *this->fZone; }
};

} // end namespace

#endif

class GUI;
namespace oscfaust
{

class OSCIO;
class RootNode;
typedef class SMARTP<RootNode> SRootNode;
class MessageDriven;
typedef class SMARTP<MessageDriven>	SMessageDriven;

//--------------------------------------------------------------------------
/*!
	\brief a factory to build a OSC UI hierarchy
	
	Actually, makes use of a stack to build the UI hierarchy.
	It includes a pointer to a OSCIO controler, but just to give it to the root node.
*/
class FaustFactory
{
    std::stack<SMessageDriven>  fNodes;		///< maintains the current hierarchy level
    SRootNode  fRoot;   ///< keep track of the root node
    OSCIO*     fIO;     ///< hack to support audio IO via OSC, actually the field is given to the root node
    GUI*       fGUI;    ///< a GUI pointer to support updateAllGuis(), required for bi-directionnal OSC
    JSONUI*    fJSON;
    
    private:
        std::string addressFirst(const std::string& address) const;
        std::string addressTail(const std::string& address) const;
        
    public:
        FaustFactory(GUI* ui, JSONUI* json, OSCIO * io = NULL);
        virtual ~FaustFactory();
        
        template <typename C> void addnode(const char* label, C* zone, C init, C min, C max, bool initZone, bool input);
        template <typename C> void addAlias(const std::string& fullpath, C* zone, C imin, C imax, C init, C min, C max, const char* label);
        
        void addAlias(const char* alias, const char* address, float imin, float imax, float omin, float omax);
        void addAlias(const char* alias, const char* address, double imin, double imax, double omin, double omax);
        void opengroup(const char* label);
        void closegroup();
        
        SRootNode root() const; 
};

/**
 * Add a node to the OSC UI tree in the current group at the top of the stack 
 */
template <typename C> void FaustFactory::addnode(const char* label, C* zone, C init, C min, C max, bool initZone, bool input) 
{
	SMessageDriven top;
	if (fNodes.size()) top = fNodes.top();
	if (top) {
		std::string prefix = top->getOSCAddress();
		top->add(FaustNode<C>::create(root(), label, zone, init, min, max, prefix.c_str(), fGUI, initZone, input));
	}
}

/**
 * Add an alias (actually stored and handled at root node level
 */
template <typename C> void FaustFactory::addAlias(const std::string& fullpath, C* zone, C imin, C imax, C init, C min, C max, const char* label)
{
	std::istringstream 	ss(fullpath);
	std::string 		realpath; 
 
	ss >> realpath >> imin >> imax;
	SMessageDriven top = fNodes.top();
	if (top) {
		std::string target = top->getOSCAddress() + "/" + label;
		addAlias(realpath.c_str(), target.c_str(), C(imin), C(imax), C(min), C(max));
	}
}

} // end namespoace

#endif

class GUI;

typedef void (*ErrorCallback)(void*);  

namespace oscfaust
{

class OSCIO;
class OSCSetup;
class OSCRegexp;
    
//--------------------------------------------------------------------------
/*!
	\brief the main Faust OSC Lib API
	
	The OSCControler is essentially a glue between the memory representation (in charge of the FaustFactory),
	and the network services (in charge of OSCSetup).
*/
class OSCControler
{
	int fUDPPort,   fUDPOut, fUPDErr;	// the udp ports numbers
	std::string     fDestAddress;		// the osc messages destination address, used at initialization only
										// to collect the address from the command line
	std::string     fBindAddress;		// when non empty, the address used to bind the socket for listening
	OSCSetup*		fOsc;				// the network manager (handles the udp sockets)
	OSCIO*			fIO;				// hack for OSC IO support (actually only relayed to the factory)
	FaustFactory*	fFactory;			// a factory to build the memory representation

    bool            fInit;
    
	public:
		/*
			base udp port is chosen in an unassigned range from IANA PORT NUMBERS (last updated 2011-01-24)
			see at http://www.iana.org/assignments/port-numbers
			5507-5552  Unassigned
		*/
		enum { kUDPBasePort = 5510 };
            
        OSCControler(int argc, char* argv[], GUI* ui, JSONUI* json, OSCIO* io = NULL, ErrorCallback errCallback = NULL, void* arg = NULL, bool init = true);

        virtual ~OSCControler();
	
		//--------------------------------------------------------------------------
		// addnode, opengroup and closegroup are simply relayed to the factory
		//--------------------------------------------------------------------------
		// Add a node in the current group (top of the group stack)
		template <typename T> void addnode(const char* label, T* zone, T init, T min, T max, bool input = true)
							{ fFactory->addnode(label, zone, init, min, max, fInit, input); }
		
		//--------------------------------------------------------------------------
		// This method is used for alias messages. The arguments imin and imax allow
		// to map incomming values from the alias input range to the actual range 
		template <typename T> void addAlias(const std::string& fullpath, T* zone, T imin, T imax, T init, T min, T max, const char* label)
							{ fFactory->addAlias(fullpath, zone, imin, imax, init, min, max, label); }

		void opengroup(const char* label)		{ fFactory->opengroup(label); }
		void closegroup()						{ fFactory->closegroup(); }
	   
		//--------------------------------------------------------------------------
		void run();				// starts the network services
		void endBundle();		// when bundle mode is on, close and send the current bundle (if any)
		void stop();			// stop the network services
		std::string getInfos() const; // gives information about the current environment (version, port numbers,...)

		int	getUDPPort() const			{ return fUDPPort; }
		int	getUDPOut()	const			{ return fUDPOut; }
		int	getUDPErr()	const			{ return fUPDErr; }
		const char*	getDestAddress() const { return fDestAddress.c_str(); }
		const char*	getRootName() const;	// probably useless, introduced for UI extension experiments
    
        void setUDPPort(int port) { fUDPPort = port; }
        void setUDPOut(int port) { fUDPOut = port; }
        void setUDPErr(int port) { fUPDErr = port; }
        void setDestAddress(const char* address) { fDestAddress = address; }

        // By default, an osc interface emits all parameters. You can filter specific params dynamically.
        static std::vector<OSCRegexp*>     fFilteredPaths; // filtered paths will not be emitted
        static void addFilteredPath(std::string path);
        static bool isPathFiltered(std::string path);
        static void resetFilteredPaths();
    
		static float version();				// the Faust OSC library version number
		static const char* versionstr();	// the Faust OSC library version number as a string
		static int gXmit;                   // a static variable to control the transmission of values
                                            // i.e. the use of the interface as a controler
		static int gBundle;                 // a static variable to control the osc bundle mode
};

#define kNoXmit     0
#define kAll        1
#define kAlias      2

}

#endif

#ifdef _WIN32
#define strcasecmp _stricmp
#endif

/******************************************************************************
 *******************************************************************************
 
 OSC (Open Sound Control) USER INTERFACE
 
 *******************************************************************************
 *******************************************************************************/
/*
 
 Note about the OSC addresses and the Faust UI names:
 ----------------------------------------------------
 There are potential conflicts between the Faust UI objects naming scheme and
 the OSC address space. An OSC symbolic names is an ASCII string consisting of
 printable characters other than the following:
	space
 #	number sign
 *	asterisk
 ,	comma
 /	forward
 ?	question mark
 [	open bracket
 ]	close bracket
 {	open curly brace
 }	close curly brace
 
 a simple solution to address the problem consists in replacing
 space or tabulation with '_' (underscore)
 all the other osc excluded characters with '-' (hyphen)
 
 This solution is implemented in the proposed OSC UI;
 */

class OSCUI : public GUI
{
    
    private:
        
        oscfaust::OSCControler*	fCtrl;
        std::vector<const char*> fAlias;
        JSONUI fJSON;
        
        const char* tr(const char* label) const
        {
            static char buffer[1024];
            char* ptr = buffer; int n = 1;
            while (*label && (n++ < 1024)) {
                switch (*label) {
                    case ' ': case '	':
                        *ptr++ = '_';
                        break;
                    case '#': case '*': case ',': case '/': case '?':
                    case '[': case ']': case '{': case '}': case '(': case ')':
                        *ptr++ = '_';
                        break;
                    default:
                        *ptr++ = *label;
                }
                label++;
            }
            *ptr = 0;
            return buffer;
        }
        
        // add all accumulated alias
        void addalias(FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, const char* label)
        {
            for (unsigned int i = 0; i < fAlias.size(); i++) {
                fCtrl->addAlias(fAlias[i], zone, FAUSTFLOAT(0), FAUSTFLOAT(1), init, min, max, label);
            }
            fAlias.clear();
        }
        
    public:
        
        OSCUI(const char* /*applicationname*/, int argc, char* argv[],
              oscfaust::OSCIO* io = NULL,
              ErrorCallback errCallback = NULL,
              void* arg = NULL,
              bool init = true) : GUI()
        {
            fCtrl = new oscfaust::OSCControler(argc, argv, this, &fJSON, io, errCallback, arg, init);
            // fCtrl->opengroup(applicationname);
        }
        
        virtual ~OSCUI() { delete fCtrl; }
        
        // -- widget's layouts
        
        virtual void openTabBox(const char* label)          { fCtrl->opengroup(tr(label)); fJSON.openTabBox(label); }
        virtual void openHorizontalBox(const char* label)   { fCtrl->opengroup(tr(label)); fJSON.openHorizontalBox(label); }
        virtual void openVerticalBox(const char* label)     { fCtrl->opengroup(tr(label)); fJSON.openVerticalBox(label); }
        virtual void closeBox()                             { fCtrl->closegroup(); fJSON.closeBox(); }
        
        // -- active widgets
        virtual void addButton(const char* label, FAUSTFLOAT* zone)
        {
            const char* l = tr(label);
            addalias(zone, 0, 0, 1, l);
            fCtrl->addnode(l, zone, FAUSTFLOAT(0), FAUSTFLOAT(0), FAUSTFLOAT(1));
            fJSON.addButton(label, zone);
        }
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            const char* l = tr(label);
            addalias(zone, 0, 0, 1, l);
            fCtrl->addnode(l, zone, FAUSTFLOAT(0), FAUSTFLOAT(0), FAUSTFLOAT(1));
            fJSON.addCheckButton(label, zone);
        }
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            const char* l = tr(label);
            addalias(zone, init, min, max, l);
            fCtrl->addnode(l, zone, init, min, max);
            fJSON.addVerticalSlider(label, zone, init, min, max, step);
        }
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            const char* l = tr(label);
            addalias(zone, init, min, max, l);
            fCtrl->addnode(l, zone, init, min, max);
            fJSON.addHorizontalSlider(label, zone, init, min, max, step);
        }
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            const char* l = tr(label);
            addalias(zone, init, min, max, l);
            fCtrl->addnode(l, zone, init, min, max);
            fJSON.addNumEntry(label, zone, init, min, max, step);
        }
        
        // -- passive widgets
        
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            const char* l = tr(label);
            addalias(zone, 0, min, max, l);
            fCtrl->addnode(l, zone, FAUSTFLOAT(0), min, max, false);
            fJSON.addHorizontalBargraph(label, zone, min, max);
        }
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            const char* l = tr(label);
            addalias(zone, 0, min, max, l);
            fCtrl->addnode(l, zone, FAUSTFLOAT(0), min, max, false);
            fJSON.addVerticalBargraph(label, zone, min, max);
        }
            
        // -- metadata declarations
        
        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* alias)
        {
            if (strcasecmp(key, "OSC") == 0) fAlias.push_back(alias);
            fJSON.declare(zone, key, alias);
        }
        
        bool run()
        {
            fCtrl->run();
            return true;
        }
        
        void stop()			{ fCtrl->stop(); }
        void endBundle() 	{ fCtrl->endBundle(); }
        
        std::string getInfos()          { return fCtrl->getInfos(); }
        
        const char* getRootName()		{ return fCtrl->getRootName(); }
        int getUDPPort()                { return fCtrl->getUDPPort(); }
        int getUDPOut()                 { return fCtrl->getUDPOut(); }
        int getUDPErr()                 { return fCtrl->getUDPErr(); }
        const char* getDestAddress()    { return fCtrl->getDestAddress(); }
        
        void setUDPPort(int port)       { fCtrl->setUDPPort(port); }
        void setUDPOut(int port)        { fCtrl->setUDPOut(port); }
        void setUDPErr(int port)        { fCtrl->setUDPErr(port); }
        void setDestAddress(const char* address)    { return fCtrl->setDestAddress(address); }
    
};

#endif // __OSCUI__
/**************************  END  OSCUI.h **************************/
static void osc_compute_callback(void* arg)
{
    static_cast<OSCUI*>(arg)->endBundle();
}
#endif

#ifdef HTTPCTRL
/************************** BEGIN httpdUI.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ***********************************************************************/

#ifndef __httpdUI__
#define __httpdUI__

#include <iostream>
#include <sstream>
#include <cstdlib>

/*

  Faust Project

  Copyright (C) 2012 Grame

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

  Grame Research Laboratory, 9 rue du Garet, 69001 Lyon - France
  research@grame.fr

*/

#ifndef __HTTPDControler__
#define __HTTPDControler__

#include <string>
#include <map>


namespace httpdfaust
{

class HTTPDSetup;
class JSONDesc;
class FaustFactory;
class jsonfactory;
class htmlfactory;

//--------------------------------------------------------------------------
/*!
	\brief the main Faust HTTPD Lib API
	
	The HTTPDControler is essentially a glue between the memory representation (in charge of the FaustFactory), 
	and the network services (in charge of HTTPDSetup).
*/
class LIBFAUST_API HTTPDControler
{
	int fTCPPort;				// the tcp port number
	FaustFactory*	fFactory;	// a factory to build the memory representation
	jsonfactory*	fJson;
	htmlfactory*	fHtml;
	HTTPDSetup*		fHttpd;		// the network manager
	std::string		fHTML;		// the corresponding HTML page
	std::map<std::string, std::string>	fCurrentMeta;	// the current meta declarations 

    bool            fInit;
    
	public:
		/*
			base udp port is chosen in an unassigned range from IANA PORT NUMBERS (last updated 2011-01-24)
			see at http://www.iana.org/assignments/port-numbers
			5507-5552  Unassigned
		*/
		enum { kTCPBasePort = 5510};

				 HTTPDControler(int argc, char *argv[], const char* applicationname, bool init = true);
		virtual ~HTTPDControler();
	
		//--------------------------------------------------------------------------
		// addnode, opengroup and closegroup are simply relayed to the factory
		//--------------------------------------------------------------------------
		template <typename C> void addnode(const char* type, const char* label, C* zone);
		template <typename C> void addnode(const char* type, const char* label, C* zone, C min, C max);
		template <typename C> void addnode(const char* type, const char* label, C* zone, C init, C min, C max, C step);
							  void declare(const char* key, const char* val) { fCurrentMeta[key] = val; }

		void opengroup(const char* type, const char* label);
		void closegroup();

		//--------------------------------------------------------------------------
		void run();				// start the httpd server
		void stop();			// stop the httpd server
		
		int	getTCPPort()			{ return fTCPPort; }
        std::string getJSON();
        void        setInputs(int numInputs);
        void        setOutputs(int numOutputs);

		static float version();				// the Faust httpd library version number
		static const char* versionstr();	// the Faust httpd library version number as a string
};

}

#endif


#ifndef _WIN32
#include <unistd.h>
#include <pthread.h>
#endif

/******************************************************************************
*******************************************************************************

					HTTPD USER INTERFACE

*******************************************************************************
*******************************************************************************/

class FAUST_API httpdUIAux
{
    public:
    
        virtual ~httpdUIAux() {}

        virtual bool run()              = 0;
        virtual void stop()             = 0;
        virtual int getTCPPort()        = 0;
        virtual std::string getJSON()   = 0;
};

/*

Note about URLs and the Faust UI names:
----------------------------------------------------
Characters in a url could be:
1. Reserved: ; / ? : @ & = + $ ,
   These characters delimit URL parts.
2. Unreserved: alphanum - _ . ! ~ * ' ( )
   These characters have no special meaning and can be used as is.
3. Excluded: control characters, space, < > # % ", { } | \ ^ [ ] `

To solve potential conflicts between the Faust UI objects naming scheme and
the URL allowed characters, the reserved and excluded characters are replaced
with '-' (hyphen).
Space or tabulation are replaced with '_' (underscore)
*/

class FAUST_API httpdServerUI : public UI, public httpdUIAux
{
    private:

        httpdfaust::HTTPDControler*	fCtrl;

        const char* tr(const char* label) const
        {
            static char buffer[1024];
            char * ptr = buffer; int n = 1;
            while (*label && (n++ < 1024)) {
                switch (*label) {
                    case ' ': case '	':
                        *ptr++ = '_';
                        break;
                    case ';': case '/': case '?': case ':': case '@':
                    case '&': case '=': case '+': case '$': case ',':
                    case '<': case '>': case '#': case '%': case '"':
                    case '{': case '}': case '|': case '\\': case '^':
                    case '[': case ']': case '`':
                        *ptr++ = '_';
                        break;
                    default:
                        *ptr++ = *label;
                }
                label++;
            }
            *ptr = 0;
            return buffer;
        }

    public:

        httpdServerUI(const char* applicationname, int inputs, int outputs, int argc, char* argv[], bool init = true)
        {
            fCtrl = new httpdfaust::HTTPDControler(argc, argv, applicationname, init);
            fCtrl->setInputs(inputs);
            fCtrl->setOutputs(outputs);
        }

        virtual ~httpdServerUI() { delete fCtrl; }

        // -- widget's layouts
        virtual void openTabBox(const char* label) 			{ fCtrl->opengroup("tgroup", tr(label)); }
        virtual void openHorizontalBox(const char* label) 	{ fCtrl->opengroup("hgroup", tr(label)); }
        virtual void openVerticalBox(const char* label) 	{ fCtrl->opengroup("vgroup", tr(label)); }
        virtual void closeBox() 							{ fCtrl->closegroup(); }

        // -- active widgets
        virtual void addButton(const char* label, FAUSTFLOAT* zone)			{ fCtrl->addnode("button", tr(label), zone); }
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)	{ fCtrl->addnode("checkbox", tr(label), zone); }
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
                                        { fCtrl->addnode("vslider", tr(label), zone, init, min, max, step); }
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
                                        { fCtrl->addnode("hslider", tr(label), zone, init, min, max, step); }
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
                                        { fCtrl->addnode("nentry", tr(label), zone, init, min, max, step); }

        // -- passive widgets
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
                                        { fCtrl->addnode("hbargraph", tr(label), zone, min, max); }
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
                                        { fCtrl->addnode("vbargraph", tr(label), zone, min, max); }
    
        // -- soundfiles
    
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}

        virtual void declare(FAUSTFLOAT*, const char* key, const char* val) { fCtrl->declare(key, val); }

        bool run()						{ fCtrl->run(); return true; }
        void stop()						{ fCtrl->stop(); }
        int getTCPPort()                { return fCtrl->getTCPPort(); }

        std::string getJSON() { return fCtrl->getJSON(); }

};

// API from sourcefetcher.hh and compiled in libHTTPDFaust library.
FAUST_API int http_fetch(const char* url, char** fileBuf);

/*
Use to control a running Faust DSP wrapped with "httpdServerUI".
*/

#ifndef _WIN32
class FAUST_API httpdClientUI : public GUI, public PathBuilder, public httpdUIAux
{

    private:

        class uiUrlValue : public uiItem
        {

            private:

                std::string fPathURL;

            public:

                uiUrlValue(const std::string& path_url, GUI* ui, FAUSTFLOAT* zone)
                    :uiItem(ui, zone),fPathURL(path_url)
                {}
                virtual ~uiUrlValue()
                {}

                virtual void reflectZone()
                {
                    FAUSTFLOAT v = *fZone;
                    fCache = v;
                    std::stringstream str;
                    str << fPathURL << "?value=" << v;
                    std::string path = str.str();
                    http_fetch(path.c_str(), NULL);
                }

        };

        std::string fServerURL;
        std::string fJSON;
        std::map<std::string, FAUSTFLOAT*> fZoneMap;
        pthread_t fThread;
        int fTCPPort;
        bool fRunning;

        void insertMap(std::string label, FAUSTFLOAT* zone)
        {
            fZoneMap[label] = zone;
        }

        static void* UpdateUI(void* arg)
        {
            httpdClientUI* ui = static_cast<httpdClientUI*>(arg);
            while (ui->fRunning) {
                for (const auto& it : ui->fZoneMap) {
                    char* answer;
                    std::string path = it.first;
                    http_fetch(path.c_str(), &answer);
                    std::string answer_str = answer;
                    (*it.second) = (FAUSTFLOAT)std::strtod(answer_str.substr(answer_str.find(' ')).c_str(), NULL);
                    // 'http_fetch' result must be deallocated
                    free(answer);
                }
                usleep(100000);
            }
			return 0;
        }

        virtual void addGeneric(const char* label, FAUSTFLOAT* zone)
        {
            std::string url = fServerURL + buildPath(label);
            insertMap(url, zone);
            new uiUrlValue(url, this, zone);
        }

    public:

        httpdClientUI(const std::string& server_url):fServerURL(server_url), fRunning(false)
        {
            char* json_buffer = 0;
            std::string json_url = std::string(server_url) + "/JSON";
            http_fetch(json_url.c_str(), &json_buffer);
            if (json_buffer) {
                fJSON = json_buffer;
                fTCPPort = std::atoi(server_url.substr(server_url.find_last_of(':') + 1).c_str());
                // 'http_fetch' result must be deallocated
                free(json_buffer);
                std::cout << "Faust httpd client controling server '" << server_url << "'" << std::endl;
            } else {
                fJSON = "";
                fTCPPort = -1;
            }
        }

        virtual ~httpdClientUI()
        {
            stop();
        }

        // -- widget's layouts
        void openTabBox(const char* label)
        {
            pushLabel(label);
        }
        void openHorizontalBox(const char* label)
        {
            pushLabel(label);
        }
        void openVerticalBox(const char* label)
        {
            pushLabel(label);
        }
        void closeBox()
        {
            popLabel();
        }

        // -- active widgets
        virtual void addButton(const char* label, FAUSTFLOAT* zone)
        {
            // addGeneric(label, zone);
            // Do not update button state with received messages (otherwise on/off messages may be lost...)
            std::string url = fServerURL + buildPath(label);
            new uiUrlValue(url, this, zone);
        }
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            addGeneric(label, zone);
        }
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addGeneric(label, zone);
        }
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addGeneric(label, zone);
        }
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addGeneric(label, zone);
        }

        // -- passive widgets
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            addGeneric(label, zone);
        }
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            addGeneric(label, zone);
        }

        virtual void declare(FAUSTFLOAT*, const char* key, const char* val) {}

        bool run()
        {
            if (fTCPPort > 0) {
                fRunning = true;
                return (pthread_create(&fThread, NULL, UpdateUI, this) == 0);
            } else {
                return false;
            }
        }

        void stop()
        {
            if (fRunning) {
                fRunning = false;
                pthread_join(fThread, NULL);
            }
        }

        int getTCPPort()
        {
            return fTCPPort;
        }

        std::string getJSON() { return fJSON; }

};
#endif

/*
Creates a httpdServerUI or httpdClientUI depending of the presence of '-server URL' parameter.
*/

class FAUST_API httpdUI : public DecoratorUI
{

    public:

        httpdUI(const char* applicationname, int inputs, int outputs, int argc, char* argv[], bool init = true)
        {
            if (argv && isopt(argv, "-server")) {
            #ifndef _WIN32
                fUI = new httpdClientUI(lopts(argv, "-server", "http://localhost:5510"));
            #endif
            } else {
                fUI = new httpdServerUI(applicationname, inputs, outputs, argc, argv, init);
            }
        }

        bool run() { return dynamic_cast<httpdUIAux*>(fUI)->run(); }
        void stop() { dynamic_cast<httpdUIAux*>(fUI)->stop(); }
        int getTCPPort() { return dynamic_cast<httpdUIAux*>(fUI)->getTCPPort(); }

        std::string getJSON() { return dynamic_cast<httpdUIAux*>(fUI)->getJSON(); }

};

#endif
/**************************  END  httpdUI.h **************************/
#endif

#ifdef SOUNDFILE
/************************** BEGIN SoundUI.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ********************************************************************/
 
#ifndef __SoundUI_H__
#define __SoundUI_H__

#include <map>
#include <vector>
#include <string>
#include <iostream>
#include <memory>


#if defined(__APPLE__) && !defined(__VCVRACK__) && !defined(JUCE_32BIT) && !defined(JUCE_64BIT)
#include <CoreFoundation/CFBundle.h>
#endif

// Always included otherwise -i mode later on will not always include it (with the conditional includes)
/************************** BEGIN Soundfile.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ********************************************************************/

#ifndef __Soundfile__
#define __Soundfile__

#include <string.h>
#include <string>
#include <vector>

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

#define BUFFER_SIZE 1024
#define SAMPLE_RATE 44100
#define MAX_CHAN 64
#define MAX_SOUNDFILE_PARTS 256

#ifdef _MSC_VER
#define PRE_PACKED_STRUCTURE __pragma(pack(push, 1))
#define POST_PACKED_STRUCTURE \
    ;                         \
    __pragma(pack(pop))
#else
#define PRE_PACKED_STRUCTURE
#define POST_PACKED_STRUCTURE __attribute__((__packed__))
#endif

/*
 The soundfile structure to be used by the DSP code. Soundfile has a MAX_SOUNDFILE_PARTS parts 
 (even a single soundfile or an empty soundfile). 
 The fLength, fOffset and fSR fields are filled accordingly by repeating the actual parts if needed.
 The fBuffers contains MAX_CHAN non-interleaved arrays of samples.
 
 It has to be 'packed' to that the LLVM backend can correctly access it.

 Index computation:
    - p is the current part number [0..MAX_SOUNDFILE_PARTS-1] (must be proved by the type system)
    - i is the current position in the part. It will be constrained between [0..length]
    - idx(p,i) = fOffset[p] + max(0, min(i, fLength[p]));
*/

PRE_PACKED_STRUCTURE
struct Soundfile {
    void* fBuffers; // will correspond to a double** or float** pointer chosen at runtime
    int* fLength;   // length of each part (so fLength[P] contains the length in frames of part P)
    int* fSR;       // sample rate of each part (so fSR[P] contains the SR of part P)
    int* fOffset;   // offset of each part in the global buffer (so fOffset[P] contains the offset in frames of part P)
    int fChannels;  // max number of channels of all concatenated files
    int fParts;     // the total number of loaded parts
    bool fIsDouble; // keep the sample format (float or double)

    Soundfile(int cur_chan, int length, int max_chan, int total_parts, bool is_double)
    {
        fLength   = new int[MAX_SOUNDFILE_PARTS];
        fSR       = new int[MAX_SOUNDFILE_PARTS];
        fOffset   = new int[MAX_SOUNDFILE_PARTS];
        fIsDouble = is_double;
        fChannels = cur_chan;
        fParts    = total_parts;
        if (fIsDouble) {
            fBuffers = allocBufferReal<double>(cur_chan, length, max_chan);
        } else {
            fBuffers = allocBufferReal<float>(cur_chan, length, max_chan);
        }
    }
    
    template <typename REAL>
    void* allocBufferReal(int cur_chan, int length, int max_chan)
    {
        REAL** buffers = new REAL*[max_chan];
        for (int chan = 0; chan < cur_chan; chan++) {
            buffers[chan] = new REAL[length];
            memset(buffers[chan], 0, sizeof(REAL) * length);
        }
        return buffers;
    }
    
    void copyToOut(int size, int channels, int max_channels, int offset, void* buffer)
    {
        if (fIsDouble) {
            copyToOutReal<double>(size, channels, max_channels, offset, buffer);
       } else {
            copyToOutReal<float>(size, channels, max_channels, offset, buffer);
        }
    }
    
    void shareBuffers(int cur_chan, int max_chan)
    {
        // Share the same buffers for all other channels so that we have max_chan channels available
        if (fIsDouble) {
            for (int chan = cur_chan; chan < max_chan; chan++) {
                static_cast<double**>(fBuffers)[chan] = static_cast<double**>(fBuffers)[chan % cur_chan];
            }
        } else {
            for (int chan = cur_chan; chan < max_chan; chan++) {
                static_cast<float**>(fBuffers)[chan] = static_cast<float**>(fBuffers)[chan % cur_chan];
            }
        }
    }
    
    template <typename REAL>
    void copyToOutReal(int size, int channels, int max_channels, int offset, void* buffer)
    {
        for (int sample = 0; sample < size; sample++) {
            for (int chan = 0; chan < channels; chan++) {
                static_cast<REAL**>(fBuffers)[chan][offset + sample] = static_cast<REAL*>(buffer)[sample * max_channels + chan];
            }
        }
    }
    
    template <typename REAL>
    void getBuffersOffsetReal(void* buffers, int offset)
    {
        for (int chan = 0; chan < fChannels; chan++) {
            static_cast<REAL**>(buffers)[chan] = &(static_cast<REAL**>(fBuffers))[chan][offset];
        }
    }
    
    void emptyFile(int part, int& offset)
    {
        fLength[part] = BUFFER_SIZE;
        fSR[part] = SAMPLE_RATE;
        fOffset[part] = offset;
        // Update offset
        offset += fLength[part];
    }
 
    ~Soundfile()
    {
        // Free the real channels only
        if (fIsDouble) {
            for (int chan = 0; chan < fChannels; chan++) {
                delete[] static_cast<double**>(fBuffers)[chan];
            }
            delete[] static_cast<double**>(fBuffers);
        } else {
            for (int chan = 0; chan < fChannels; chan++) {
                delete[] static_cast<float**>(fBuffers)[chan];
            }
            delete[] static_cast<float**>(fBuffers);
        }
        delete[] fLength;
        delete[] fSR;
        delete[] fOffset;
    }

} POST_PACKED_STRUCTURE;

/*
 The generic soundfile reader.
 */

class SoundfileReader {
    
   protected:
    
    int fDriverSR;
   
    // Check if a soundfile exists and return its real path_name
    std::string checkFile(const std::vector<std::string>& sound_directories, const std::string& file_name)
    {
        if (checkFile(file_name)) {
            return file_name;
        } else {
            for (size_t i = 0; i < sound_directories.size(); i++) {
                std::string path_name = sound_directories[i] + "/" + file_name;
                if (checkFile(path_name)) { return path_name; }
            }
            return "";
        }
    }
    
    bool isResampling(int sample_rate) { return (fDriverSR > 0 && fDriverSR != sample_rate); }
 
    // To be implemented by subclasses

    /**
     * Check the availability of a sound resource.
     *
     * @param path_name - the name of the file, or sound resource identified this way
     *
     * @return true if the sound resource is available, false otherwise.
     */
    virtual bool checkFile(const std::string& path_name) = 0;
    
    /**
     * Check the availability of a sound resource.
     *
     * @param buffer - the sound buffer
     * @param size - the sound buffer length
     *
     * @return true if the sound resource is available, false otherwise.
     */

    virtual bool checkFile(unsigned char* buffer, size_t size) { return true; }

    /**
     * Get the channels and length values of the given sound resource.
     *
     * @param path_name - the name of the file, or sound resource identified this way
     * @param channels - the channels value to be filled with the sound resource number of channels
     * @param length - the length value to be filled with the sound resource length in frames
     *
     */
    virtual void getParamsFile(const std::string& path_name, int& channels, int& length) = 0;
    
    /**
     * Get the channels and length values of the given sound resource.
     *
     * @param buffer - the sound buffer
     * @param size - the sound buffer length
     * @param channels - the channels value to be filled with the sound resource number of channels
     * @param length - the length value to be filled with the sound resource length in frames
     *
     */
    virtual void getParamsFile(unsigned char* buffer, size_t size, int& channels, int& length) {}

    /**
     * Read one sound resource and fill the 'soundfile' structure accordingly
     *
     * @param soundfile - the soundfile to be filled
     * @param path_name - the name of the file, or sound resource identified this way
     * @param part - the part number to be filled in the soundfile
     * @param offset - the offset value to be incremented with the actual sound resource length in frames
     * @param max_chan - the maximum number of mono channels to fill
     *
     */
    virtual void readFile(Soundfile* soundfile, const std::string& path_name, int part, int& offset, int max_chan) = 0;
    
    /**
     * Read one sound resource and fill the 'soundfile' structure accordingly
     *
     * @param soundfile - the soundfile to be filled
     * @param buffer - the sound buffer
     * @param size - the sound buffer length
     * @param part - the part number to be filled in the soundfile
     * @param offset - the offset value to be incremented with the actual sound resource length in frames
     * @param max_chan - the maximum number of mono channels to fill
     *
     */
    virtual void readFile(Soundfile* soundfile, unsigned char* buffer, size_t size, int part, int& offset, int max_chan) {}

  public:
    
    SoundfileReader() {}
    virtual ~SoundfileReader() {}
    
    void setSampleRate(int sample_rate) { fDriverSR = sample_rate; }
   
    Soundfile* createSoundfile(const std::vector<std::string>& path_name_list, int max_chan, bool is_double)
    {
        try {
            int cur_chan = 1; // At least one channel
            int total_length = 0;
            
            // Compute total length and channels max of all files
            for (size_t i = 0; i < path_name_list.size(); i++) {
                int chan, length;
                if (path_name_list[i] == "__empty_sound__") {
                    length = BUFFER_SIZE;
                    chan = 1;
                } else {
                    getParamsFile(path_name_list[i], chan, length);
                }
                cur_chan = std::max<int>(cur_chan, chan);
                total_length += length;
            }
           
            // Complete with empty parts
            total_length += (MAX_SOUNDFILE_PARTS - path_name_list.size()) * BUFFER_SIZE;
            
            // Create the soundfile
            Soundfile* soundfile = new Soundfile(cur_chan, total_length, max_chan, path_name_list.size(), is_double);
            
            // Init offset
            int offset = 0;
            
            // Read all files
            for (size_t i = 0; i < path_name_list.size(); i++) {
                if (path_name_list[i] == "__empty_sound__") {
                    soundfile->emptyFile(i, offset);
                } else {
                    readFile(soundfile, path_name_list[i], i, offset, max_chan);
                }
            }
            
            // Complete with empty parts
            for (size_t i = path_name_list.size(); i < MAX_SOUNDFILE_PARTS; i++) {
                soundfile->emptyFile(i, offset);
            }
            
            // Share the same buffers for all other channels so that we have max_chan channels available
            soundfile->shareBuffers(cur_chan, max_chan);
            return soundfile;
            
        } catch (...) {
            return nullptr;
        }
    }

    // Check if all soundfiles exist and return their real path_name
    std::vector<std::string> checkFiles(const std::vector<std::string>& sound_directories,
                                        const std::vector<std::string>& file_name_list)
    {
        std::vector<std::string> path_name_list;
        for (size_t i = 0; i < file_name_list.size(); i++) {
            std::string path_name = checkFile(sound_directories, file_name_list[i]);
            // If 'path_name' is not found, it is replaced by an empty sound (= silence)
            path_name_list.push_back((path_name == "") ? "__empty_sound__" : path_name);
        }
        return path_name_list;
    }

};

#endif
/**************************  END  Soundfile.h **************************/

#if defined(JUCE_32BIT) || defined(JUCE_64BIT)
/************************** BEGIN JuceReader.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __JuceReader__
#define __JuceReader__

#include <assert.h>

#include "../JuceLibraryCode/JuceHeader.h"


struct JuceReader : public SoundfileReader {
    
    juce::AudioFormatManager fFormatManager;
    
    JuceReader() { fFormatManager.registerBasicFormats(); }
    virtual ~JuceReader()
    {}
    
    bool checkFile(const std::string& path_name) override
    {
        juce::File file = juce::File::getCurrentWorkingDirectory().getChildFile(path_name);
        if (file.existsAsFile()) {
            return true;
        } else {
            std::cerr << "ERROR : cannot open '" << path_name << "'" << std::endl;
            return false;
        }
    }
    
    void getParamsFile(const std::string& path_name, int& channels, int& length) override
    {
        std::unique_ptr<juce::AudioFormatReader> formatReader (fFormatManager.createReaderFor (juce::File::getCurrentWorkingDirectory().getChildFile(path_name)));
        channels = int(formatReader->numChannels);
        length = int(formatReader->lengthInSamples);
    }
    
    void readFile(Soundfile* soundfile, const std::string& path_name, int part, int& offset, int max_chan) override
    {
        std::unique_ptr<juce::AudioFormatReader> formatReader (fFormatManager.createReaderFor (juce::File::getCurrentWorkingDirectory().getChildFile(path_name)));
        
        soundfile->fLength[part] = int(formatReader->lengthInSamples);
        soundfile->fSR[part] = int(formatReader->sampleRate);
        soundfile->fOffset[part] = offset;
        
        void* buffers;
        if (soundfile->fIsDouble) {
            buffers = alloca(soundfile->fChannels * sizeof(double*));
            soundfile->getBuffersOffsetReal<double>(buffers, offset);
        } else {
            buffers = alloca(soundfile->fChannels * sizeof(float*));
            soundfile->getBuffersOffsetReal<float>(buffers, offset);
        }
        
        if (formatReader->read(reinterpret_cast<int *const *>(buffers), int(formatReader->numChannels), 0, int(formatReader->lengthInSamples), false)) {
            
            // Possibly convert samples
            if (!formatReader->usesFloatingPointData) {
                for (int chan = 0; chan < int(formatReader->numChannels); ++chan) {
                    if (soundfile->fIsDouble) {
                        // TODO
                    } else {
                        float* buffer = &(static_cast<float**>(soundfile->fBuffers))[chan][soundfile->fOffset[part]];
                        juce::FloatVectorOperations::convertFixedToFloat(buffer, reinterpret_cast<const int*>(buffer),
                                                                         1.0f/0x7fffffff, int(formatReader->lengthInSamples));
                    }
                }
            }
            
        } else {
            std::cerr << "Error reading the file : " << path_name << std::endl;
        }
            
        // Update offset
        offset += soundfile->fLength[part];
    }
    
};

#endif
/**************************  END  JuceReader.h **************************/
static JuceReader gReader;
#elif defined(ESP32)
/************************** BEGIN Esp32Reader.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 *************************************************************************/

#ifndef FAUST_ESP32READER_H
#define FAUST_ESP32READER_H

#include <stdio.h>
#include "esp_err.h"
#include "esp_log.h"
#include "esp_spi_flash.h"
#include "esp_vfs_fat.h"
#include "driver/sdspi_host.h"
#include "sdmmc_cmd.h"

/************************** BEGIN WaveReader.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ********************************************************************/

#ifndef __WaveReader__
#define __WaveReader__

#include <string.h>
#include <assert.h>
#include <stdio.h>


// WAVE file description
typedef struct {
    
    // The canonical WAVE format starts with the RIFF header
    
    /**
     Variable: chunk_id
     Contains the letters "RIFF" in ASCII form (0x52494646 big-endian form).
     **/
    int chunk_id;
    
    /**
     Variable: chunk_size
     36 + SubChunk2Size, or more precisely: 4 + (8 + SubChunk1Size) + (8 + SubChunk2Size)
     This is the size of the rest of the chunk following this number.
     This is the size of the entire file in bytes minus 8 bytes for the
     two fields not included in this count: ChunkID and ChunkSize.
     **/
    int chunk_size;
    
    /**
     Variable: format
     Contains the letters "WAVE" (0x57415645 big-endian form).
     **/
    int format;
    
    // The "WAVE" format consists of two subchunks: "fmt " and "data":
    // The "fmt " subchunk describes the sound data's format:
    
    /**
     Variable: subchunk_1_id
     Contains the letters "fmt " (0x666d7420 big-endian form).
     **/
    int subchunk_1_id;
    
    /**
     Variable: subchunk_1_size
     16 for PCM. This is the size of the rest of the Subchunk which follows this number.
     **/
    int subchunk_1_size;
    
    /**
     Variable: audio_format
     PCM = 1 (i.e. Linear quantization) Values other than 1 indicate some form of compression.
     **/
    short audio_format;
    
    /**
     Variable: num_channels
     Mono = 1, Stereo = 2, etc.
     **/
    short num_channels;
    
    /**
     Variable: sample_rate
     8000, 44100, etc.
     **/
    int sample_rate;
    
    /**
     Variable: byte_rate
     == SampleRate * NumChannels * BitsPerSample/8
     **/
    int byte_rate;
    
    /**
     Variable: block_align
     == NumChannels * BitsPerSample/8
     The number of bytes for one sample including all channels. I wonder what happens
     when this number isn't an integer?
     **/
    short block_align;
    
    /**
     Variable: bits_per_sample
     8 bits = 8, 16 bits = 16, etc.
     **/
    short bits_per_sample;
    
    /**
     Here should come some extra parameters which i will avoid.
     **/
    
    // The "data" subchunk contains the size of the data and the actual sound:
    
    /**
     Variable: subchunk_2_id
     Contains the letters "data" (0x64617461 big-endian form).
     **/
    int subchunk_2_id;
    
    /**
     Variable: subchunk_2_size
     == NumSamples * NumChannels * BitsPerSample/8
     This is the number of bytes in the data. You can also think of this as the size
     of the read of the subchunk following this number.
     **/
    int subchunk_2_size;
    
    /**
     Variable: data
     The actual sound data.
     **/
    char* data;
    
} wave_t;

// Base reader
struct Reader {
    
    wave_t* fWave;

    inline int is_big_endian()
    {
        int a = 1;
        return !((char*)&a)[0];
    }
    
    inline int convert_to_int(char* buffer, int len)
    {
        int a = 0;
        if (!is_big_endian()) {
            for(int i = 0; i < len; i++) {
                ((char*)&a)[i] = buffer[i];
            }
        } else {
            for(int i = 0; i < len; i++) {
                ((char*)&a)[3-i] = buffer[i];
            }
        }
        return a;
    }
    
    Reader()
    {
        fWave = (wave_t*)calloc(1, sizeof(wave_t));
    }

    virtual ~Reader()
    {
        free(fWave->data);
        free(fWave);
    }

    bool load_wave_header()
    {
        char buffer[4];
        
        read(buffer, 4);
        if (strncmp(buffer, "RIFF", 4) != 0) {
            fprintf(stderr, "This is not valid WAV file!\n");
            return false;
        }
        fWave->chunk_id = convert_to_int(buffer, 4);
        
        read(buffer, 4);
        fWave->chunk_size = convert_to_int(buffer, 4);
        
        read(buffer, 4);
        fWave->format = convert_to_int(buffer, 4);
        
        read(buffer, 4);
        fWave->subchunk_1_id = convert_to_int(buffer, 4);
        
        read(buffer, 4);
        fWave->subchunk_1_size = convert_to_int(buffer, 4);
        
        read(buffer, 2);
        fWave->audio_format = convert_to_int(buffer, 2);
        
        read(buffer, 2);
        fWave->num_channels = convert_to_int(buffer, 2);
        
        read(buffer, 4);
        fWave->sample_rate = convert_to_int(buffer, 4);
        
        read(buffer, 4);
        fWave->byte_rate = convert_to_int(buffer, 4);
        
        read(buffer, 2);
        fWave->block_align = convert_to_int(buffer, 2);
        
        read(buffer, 2);
        fWave->bits_per_sample = convert_to_int(buffer, 2);
        
        read(buffer, 4);
        if (strncmp(buffer, "data", 4) != 0) {
            read(buffer, 4);
            int _extra_size = convert_to_int(buffer, 4);
            char _extra_data[_extra_size];
            read(_extra_data, _extra_size);
            read(buffer, 4);
            fWave->subchunk_2_id = convert_to_int(buffer, 4);
        } else {
            fWave->subchunk_2_id = convert_to_int(buffer, 4);
        }
        
        read(buffer, 4);
        fWave->subchunk_2_size = convert_to_int(buffer, 4);
        return true;
    }
    
    void load_wave()
    {
        // Read sound data
        fWave->data = (char*)malloc(fWave->subchunk_2_size);
        read(fWave->data, fWave->subchunk_2_size);
    }

    virtual void read(char* buffer, unsigned int size) = 0;
   
};

struct FileReader : public Reader {
    
    FILE* fFile;
    
    FileReader(const std::string& file_path)
    {
        fFile = fopen(file_path.c_str(), "rb");
        if (!fFile) {
            fprintf(stderr, "FileReader : cannot open file!\n");
            throw -1;
        }
        if (!load_wave_header()) {
            fprintf(stderr, "FileReader : not a WAV file!\n");
            throw -1;
        }
    }
    
    virtual ~FileReader()
    {
        fclose(fFile);
    }
    
    void read(char* buffer, unsigned int size)
    {
        fread(buffer, 1, size, fFile);
    }
    
};

extern const uint8_t file_start[] asm("_binary_FILE_start");
extern const uint8_t file_end[]   asm("_binary_FILE_end");

struct MemoryReader : public Reader {
    
    int fPos;
    const uint8_t* fStart;
    const uint8_t* fEnd;
    
    MemoryReader(const uint8_t* start, const uint8_t* end):fPos(0)
    {
        fStart = start;
        fEnd = end;
        if (!load_wave_header()) {
            fprintf(stderr, "MemoryReader : not a WAV file!\n");
            throw -1;
        }
    }
    
    virtual ~MemoryReader()
    {}
    
    void read(char* buffer, unsigned int size)
    {
        memcpy(buffer, fStart + fPos, size);
        fPos += size;
    }
    
};

// Using a FileReader to implement SoundfileReader

struct WaveReader : public SoundfileReader {
    
    WaveReader() {}
    virtual ~WaveReader() {}
    
    bool checkFile(const std::string& path_name) override
    {
        try {
            FileReader reader(path_name);
            return true;
        } catch (...)  {
            return false;
        }
    }
    
    void getParamsFile(const std::string& path_name, int& channels, int& length) override
    {
        FileReader reader(path_name);
        channels = reader.fWave->num_channels;
        length = (reader.fWave->subchunk_2_size * 8) / (reader.fWave->num_channels * reader.fWave->bits_per_sample);
    }
    
    void readFile(Soundfile* soundfile, const std::string& path_name, int part, int& offset, int max_chan) override
    {
        FileReader reader(path_name);
        reader.load_wave();
        
        soundfile->fLength[part] = (reader.fWave->subchunk_2_size * 8) / (reader.fWave->num_channels * reader.fWave->bits_per_sample);
        soundfile->fSR[part] = reader.fWave->sample_rate;
        soundfile->fOffset[part] = offset;
        
        // Audio frames have to be written for each chan
        if (reader.fWave->bits_per_sample == 16) {
            float factor = 1.f/32767.f;
            for (int sample = 0; sample < soundfile->fLength[part]; sample++) {
                short* frame = (short*)&reader.fWave->data[reader.fWave->block_align * sample];
                for (int chan = 0; chan < reader.fWave->num_channels; chan++) {
                    soundfile->fBuffers[chan][offset + sample] = frame[chan] * factor;
                }
            }
        } else if (reader.fWave->bits_per_sample == 32) {
            fprintf(stderr, "readFile : not implemented\n");
        }
        
        // Update offset
        offset += soundfile->fLength[part];
    }
};

#endif
/**************************  END  WaveReader.h **************************/

#define TAG "Esp32Reader"

#define SD_PIN_NUM_MISO GPIO_NUM_2
#define SD_PIN_NUM_MOSI GPIO_NUM_15
#define SD_PIN_NUM_CLK  GPIO_NUM_14
#define SD_PIN_NUM_CS   GPIO_NUM_13

struct Esp32Reader : public WaveReader {
    
    void sdcard_init()
    {
        ESP_LOGI(TAG, "Initializing SD card");
        ESP_LOGI(TAG, "Using SPI peripheral");
        
        sdmmc_host_t host = SDSPI_HOST_DEFAULT();
        sdspi_slot_config_t slot_config = SDSPI_SLOT_CONFIG_DEFAULT();
        slot_config.gpio_miso = SD_PIN_NUM_MISO;
        slot_config.gpio_mosi = SD_PIN_NUM_MOSI;
        slot_config.gpio_sck  = SD_PIN_NUM_CLK;
        slot_config.gpio_cs   = SD_PIN_NUM_CS;
        // This initializes the slot without card detect (CD) and write protect (WP) signals.
        // Modify slot_config.gpio_cd and slot_config.gpio_wp if your board has these signals.
        
        // Options for mounting the filesystem.
        // If format_if_mount_failed is set to true, SD card will be partitioned and
        // formatted in case when mounting fails.
        esp_vfs_fat_sdmmc_mount_config_t mount_config = {
            .format_if_mount_failed = false,
            .max_files = 5,
            .allocation_unit_size = 16 * 1024
        };
        
        // Use settings defined above to initialize SD card and mount FAT filesystem.
        // Note: esp_vfs_fat_sdmmc_mount is an all-in-one convenience function.
        // Please check its source code and implement error recovery when developing
        // production applications.
        sdmmc_card_t* card;
        esp_err_t ret = esp_vfs_fat_sdmmc_mount("/sdcard", &host, &slot_config, &mount_config, &card);
        
        if (ret != ESP_OK) {
            if (ret == ESP_FAIL) {
                ESP_LOGE(TAG, "Failed to mount filesystem. "
                         "If you want the card to be formatted, set format_if_mount_failed = true.");
            } else {
                ESP_LOGE(TAG, "Failed to initialize the card (%s). "
                         "Make sure SD card lines have pull-up resistors in place.", esp_err_to_name(ret));
            }
            return;
        }
        
        // Card has been initialized, print its properties
        sdmmc_card_print_info(stdout, card);
        ESP_LOGI(TAG, "SD card initialized");
    }
    
    Esp32Reader()
    {
        sdcard_init();
    }
   
    // Access methods inherited from WaveReader
};

#endif // FAUST_ESP32READER_H
/**************************  END  Esp32Reader.h **************************/
static Esp32Reader gReader;
#elif defined(DAISY)
static WaveReader gReader;
#elif defined(MEMORY_READER)
/************************** BEGIN MemoryReader.h ************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __MemoryReader__
#define __MemoryReader__


/*
 A 'MemoryReader' object can be used to prepare a set of sound resources in memory, to be used by SoundUI::addSoundfile.
 
 A Soundfile* object will have to be filled with a list of sound resources: the fLength, fOffset, fSampleRate and fBuffers fields 
 have to be completed with the appropriate values, and will be accessed in the DSP object while running.
 *
 */

// To adapt for a real case use

#define SOUND_CHAN      2
#define SOUND_LENGTH    4096
#define SOUND_SR        44100

struct MemoryReader : public SoundfileReader {
    
    MemoryReader()
    {}
    virtual ~MemoryReader()
    {}
    
    /**
     * Check the availability of a sound resource.
     *
     * @param path_name - the name of the file, or sound resource identified this way
     *
     * @return true if the sound resource is available, false otherwise.
     */
    virtual bool checkFile(const std::string& path_name) override { return true; }
    
    /**
     * Get the channels and length values of the given sound resource.
     *
     * @param path_name - the name of the file, or sound resource identified this way
     * @param channels - the channels value to be filled with the sound resource number of channels
     * @param length - the length value to be filled with the sound resource length in frames
     *
     */
    virtual void getParamsFile(const std::string& path_name, int& channels, int& length) override
    {
        channels = SOUND_CHAN;
        length = SOUND_LENGTH;
    }
    
    /**
     * Read one sound resource and fill the 'soundfile' structure accordingly
     *
     * @param path_name - the name of the file, or sound resource identified this way
     * @param part - the part number to be filled in the soundfile
     * @param offset - the offset value to be incremented with the actual sound resource length in frames
     * @param max_chan - the maximum number of mono channels to fill
     *
     */
    virtual void readFile(Soundfile* soundfile, const std::string& path_name, int part, int& offset, int max_chan) override
    {
        soundfile->fLength[part] = SOUND_LENGTH;
        soundfile->fSR[part] = SOUND_SR;
        soundfile->fOffset[part] = offset;
        
        // Audio frames have to be written for each chan
        if (soundfile->fIsDouble) {
            for (int sample = 0; sample < SOUND_LENGTH; sample++) {
                for (int chan = 0; chan < SOUND_CHAN; chan++) {
                    static_cast<double**>(soundfile->fBuffers)[chan][offset + sample] = 0.f;
                }
            }
        } else {
            for (int sample = 0; sample < SOUND_LENGTH; sample++) {
                for (int chan = 0; chan < SOUND_CHAN; chan++) {
                    static_cast<float**>(soundfile->fBuffers)[chan][offset + sample] = 0.f;
                }
            }
        }
        
        // Update offset
        offset += SOUND_LENGTH;
    }
    
};

#endif
/**************************  END  MemoryReader.h **************************/
static MemoryReader gReader;
#else
/************************** BEGIN LibsndfileReader.h *********************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __LibsndfileReader__
#define __LibsndfileReader__

#ifdef SAMPLERATE
#include <samplerate.h>
#endif
#include <sndfile.h>
#include <string.h>
#include <assert.h>
#include <iostream>
#include <fstream>


/*
// Deactivated for now, since the macOS remote cross-compiler fails with this code.
#if __has_include(<filesystem>) && __cplusplus >= 201703L
    #define HAS_FILESYSTEM
    #include <filesystem>
    namespace fs = std::filesystem;
#elif __has_include(<experimental/filesystem>) && __cplusplus >= 201103L
    #define HAS_FILESYSTEM
    #include <experimental/filesystem>
    namespace fs = std::experimental::filesystem;
#endif
*/

struct VFLibsndfile {
    
    #define SIGNED_SIZEOF(x) ((int)sizeof(x))
    
    unsigned char* fBuffer;
    size_t fLength;
    size_t fOffset;
    SF_VIRTUAL_IO fVIO;
    
    VFLibsndfile(unsigned char* buffer, size_t length):fBuffer(buffer), fLength(length), fOffset(0)
    {
        fVIO.get_filelen = vfget_filelen;
        fVIO.seek = vfseek;
        fVIO.read = vfread;
        fVIO.write = vfwrite;
        fVIO.tell = vftell;
    }
    
    static sf_count_t vfget_filelen(void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        return vf->fLength;
    }
  
    static sf_count_t vfseek(sf_count_t offset, int whence, void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        switch (whence) {
            case SEEK_SET:
                vf->fOffset = offset;
                break;
                
            case SEEK_CUR:
                vf->fOffset = vf->fOffset + offset;
                break;
                
            case SEEK_END:
                vf->fOffset = vf->fLength + offset;
                break;
                
            default:
                break;
        };
        
        return vf->fOffset;
    }
    
    static sf_count_t vfread(void* ptr, sf_count_t count, void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        
        /*
         **	This will break badly for files over 2Gig in length, but
         **	is sufficient for testing.
         */
        if (vf->fOffset + count > vf->fLength) {
            count = vf->fLength - vf->fOffset;
        }
        
        memcpy(ptr, vf->fBuffer + vf->fOffset, count);
        vf->fOffset += count;
        
        return count;
    }
    
    static sf_count_t vfwrite(const void* ptr, sf_count_t count, void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        
        /*
         **	This will break badly for files over 2Gig in length, but
         **	is sufficient for testing.
         */
        if (vf->fOffset >= SIGNED_SIZEOF(vf->fBuffer)) {
            return 0;
        }
        
        if (vf->fOffset + count > SIGNED_SIZEOF(vf->fBuffer)) {
            count = sizeof (vf->fBuffer) - vf->fOffset;
        }
        
        memcpy(vf->fBuffer + vf->fOffset, ptr, (size_t)count);
        vf->fOffset += count;
        
        if (vf->fOffset > vf->fLength) {
            vf->fLength = vf->fOffset;
        }
        
        return count;
    }
    
    static sf_count_t vftell(void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        return vf->fOffset;
    }
 
};

struct LibsndfileReader : public SoundfileReader {
	
    LibsndfileReader() {}
	
    typedef sf_count_t (* sample_read)(SNDFILE* sndfile, void* buffer, sf_count_t frames);
	
    // Check file
    bool checkFile(const std::string& path_name) override
    {
        /*
         // Better since it supports Unicode characters.
         #ifdef HAS_FILESYSTEM
         if (!fs::exists(path_name)) {
            std::cerr << "FILE NOT FOUND\n";
            return false;
         }
         #endif
         */
        
        std::ofstream ofs;
        ofs.open(path_name, std::ios_base::in);
        if (!ofs.is_open()) {
            return false;
        }
    
        SF_INFO snd_info;
        snd_info.format = 0;
        SNDFILE* snd_file = sf_open(path_name.c_str(), SFM_READ, &snd_info);
        return checkFileAux(snd_file, path_name);
    }
    
    bool checkFile(unsigned char* buffer, size_t length) override
    {
        SF_INFO snd_info;
        snd_info.format = 0;
        VFLibsndfile vio(buffer, length);
        SNDFILE* snd_file = sf_open_virtual(&vio.fVIO, SFM_READ, &snd_info, &vio);
        return checkFileAux(snd_file, "virtual file");
    }
    
    bool checkFileAux(SNDFILE* snd_file, const std::string& path_name)
    {
        if (snd_file) {
            sf_close(snd_file);
            return true;
        } else {
            std::cerr << "ERROR : cannot open '" << path_name << "' (" << sf_strerror(NULL) << ")" << std::endl;
            return false;
        }
    }

    // Open the file and returns its length and channels
    void getParamsFile(const std::string& path_name, int& channels, int& length) override
    {
        SF_INFO	snd_info;
        snd_info.format = 0;
        SNDFILE* snd_file = sf_open(path_name.c_str(), SFM_READ, &snd_info);
        getParamsFileAux(snd_file, snd_info, channels, length);
    }
    
    void getParamsFile(unsigned char* buffer, size_t size, int& channels, int& length) override
    {
        SF_INFO	snd_info;
        snd_info.format = 0;
        VFLibsndfile vio(buffer, size);
        SNDFILE* snd_file = sf_open_virtual(&vio.fVIO, SFM_READ, &snd_info, &vio);
        getParamsFileAux(snd_file, snd_info, channels, length);
    }
    
    void getParamsFileAux(SNDFILE* snd_file, const SF_INFO& snd_info, int& channels, int& length)
    {
        assert(snd_file);
        channels = int(snd_info.channels);
    #ifdef SAMPLERATE
        length = (isResampling(snd_info.samplerate)) ? ((double(snd_info.frames) * double(fDriverSR) / double(snd_info.samplerate)) + BUFFER_SIZE) : int(snd_info.frames);
    #else
        length = int(snd_info.frames);
    #endif
        sf_close(snd_file);
    }
    
    // Read the file
    void readFile(Soundfile* soundfile, const std::string& path_name, int part, int& offset, int max_chan) override
    {
        SF_INFO	snd_info;
        snd_info.format = 0;
        SNDFILE* snd_file = sf_open(path_name.c_str(), SFM_READ, &snd_info);
        readFileAux(soundfile, snd_file, snd_info, part, offset, max_chan);
    }
    
    void readFile(Soundfile* soundfile, unsigned char* buffer, size_t length, int part, int& offset, int max_chan) override
    {
        SF_INFO	snd_info;
        snd_info.format = 0;
        VFLibsndfile vio(buffer, length);
        SNDFILE* snd_file = sf_open_virtual(&vio.fVIO, SFM_READ, &snd_info, &vio);
        readFileAux(soundfile, snd_file, snd_info, part, offset, max_chan);
    }
	
    // Will be called to fill all parts from 0 to MAX_SOUNDFILE_PARTS-1
    void readFileAux(Soundfile* soundfile, SNDFILE* snd_file, const SF_INFO& snd_info, int part, int& offset, int max_chan)
    {
        assert(snd_file);
        int channels = std::min<int>(max_chan, snd_info.channels);
    #ifdef SAMPLERATE
        if (isResampling(snd_info.samplerate)) {
            soundfile->fLength[part] = int(double(snd_info.frames) * double(fDriverSR) / double(snd_info.samplerate));
            soundfile->fSR[part] = fDriverSR;
        } else {
            soundfile->fLength[part] = int(snd_info.frames);
            soundfile->fSR[part] = snd_info.samplerate;
        }
    #else
        soundfile->fLength[part] = int(snd_info.frames);
        soundfile->fSR[part] = snd_info.samplerate;
    #endif
        soundfile->fOffset[part] = offset;
		
        // Read and fill snd_info.channels number of channels
        sf_count_t nbf;
        
        sample_read reader;
        void* buffer_in = nullptr;
        if (soundfile->fIsDouble) {
            buffer_in = static_cast<double*>(alloca(BUFFER_SIZE * sizeof(double) * snd_info.channels));
            reader = reinterpret_cast<sample_read>(sf_readf_double);
        } else {
            buffer_in = static_cast<float*>(alloca(BUFFER_SIZE * sizeof(float) * snd_info.channels));
            reader = reinterpret_cast<sample_read>(sf_readf_float);
        }
        
    #ifdef SAMPLERATE
        // Resampling
        SRC_STATE* resampler = nullptr;
        float* src_buffer_out = nullptr;
        float* src_buffer_in = nullptr;
        void* buffer_out = nullptr;
        if  (isResampling(snd_info.samplerate)) {
            int error;
            resampler = src_new(SRC_SINC_FASTEST, channels, &error);
            if (error != 0) {
                std::cerr << "ERROR : src_new " << src_strerror(error) << std::endl;
                throw -1;
            }
            if (soundfile->fIsDouble) {
                // Additional buffers for SRC resampling
                src_buffer_in = static_cast<float*>(alloca(BUFFER_SIZE * sizeof(float) * snd_info.channels));
                src_buffer_out = static_cast<float*>(alloca(BUFFER_SIZE * sizeof(float) * snd_info.channels));
                buffer_out = static_cast<double*>(alloca(BUFFER_SIZE * sizeof(double) * snd_info.channels));
            } else {
                buffer_out = static_cast<float*>(alloca(BUFFER_SIZE * sizeof(float) * snd_info.channels));
            }
        }
    #endif
        
        do {
            nbf = reader(snd_file, buffer_in, BUFFER_SIZE);
        #ifdef SAMPLERATE
            // Resampling
            if  (isResampling(snd_info.samplerate)) {
                int in_offset = 0;
                SRC_DATA src_data;
                src_data.src_ratio = double(fDriverSR)/double(snd_info.samplerate);
                if (soundfile->fIsDouble) {
                    for (int frame = 0; frame < (BUFFER_SIZE * snd_info.channels); frame++) {
                        src_buffer_in[frame] = float(static_cast<float*>(buffer_in)[frame]);
                    }
                }
                do {
                    if (soundfile->fIsDouble) {
                        src_data.data_in = src_buffer_in;
                        src_data.data_out = src_buffer_out;
                    } else {
                        src_data.data_in = static_cast<const float*>(buffer_in);
                        src_data.data_out = static_cast<float*>(buffer_out);
                    }
                    src_data.input_frames = nbf - in_offset;
                    src_data.output_frames = BUFFER_SIZE;
                    src_data.end_of_input = (nbf < BUFFER_SIZE);
                    int res = src_process(resampler, &src_data);
                    if (res != 0) {
                        std::cerr << "ERROR : src_process " << src_strerror(res) << std::endl;
                        throw -1;
                    }
                    if (soundfile->fIsDouble) {
                        for (int frame = 0; frame < (BUFFER_SIZE * snd_info.channels); frame++) {
                            static_cast<double*>(buffer_out)[frame] = double(src_buffer_out[frame]);
                        }
                    }
                    soundfile->copyToOut(src_data.output_frames_gen, channels, snd_info.channels, offset, buffer_out);
                    in_offset += src_data.input_frames_used;
                    // Update offset
                    offset += src_data.output_frames_gen;
                } while (in_offset < nbf);
            } else {
                soundfile->copyToOut(nbf, channels, snd_info.channels, offset, buffer_in);
                // Update offset
                offset += nbf;
            }
        #else
            soundfile->copyToOut(nbf, channels, snd_info.channels, offset, buffer_in);
            // Update offset
            offset += nbf;
        #endif
        } while (nbf == BUFFER_SIZE);
		
        sf_close(snd_file);
    #ifdef SAMPLERATE
        if (resampler) src_delete(resampler);
    #endif
    }

};

#endif
/**************************  END  LibsndfileReader.h **************************/
static LibsndfileReader gReader;
#endif

// To be used by DSP code if no SoundUI is used
static std::vector<std::string> gPathNameList;
static Soundfile* defaultsound = nullptr;

class SoundUI : public SoundUIInterface
{
		
    protected:
    
        // The soundfile directories
        std::vector<std::string> fSoundfileDir;
        // Map to share loaded soundfiles
        std::map<std::string, std::shared_ptr<Soundfile>> fSoundfileMap;
        // The soundfile reader
        std::shared_ptr<SoundfileReader> fSoundReader;
        bool fIsDouble;

     public:
    
        /**
         * Create a soundfile loader which will typically use a concrete SoundfileReader like LibsndfileReader or JuceReader to load soundfiles.
         *
         * @param sound_directory - the base directory to look for files, which paths will be relative to this one
         * @param sample_rate - the audio driver SR which may be different from the file SR, to possibly resample files
         * @param reader - an alternative soundfile reader
         * @param is_double - whether Faust code has been compiled in -double mode and soundfile buffers have to be in double
         *
         * @return the soundfile loader.
         */
        SoundUI(const std::string& sound_directory = "", int sample_rate = -1, SoundfileReader* reader = nullptr, bool is_double = false)
        {
            fSoundfileDir.push_back(sound_directory);
            fSoundReader = (reader)
                ? std::shared_ptr<SoundfileReader>(reader)
                // the static gReader should not be deleted, so use an empty destructor
                : std::shared_ptr<SoundfileReader>(std::shared_ptr<SoundfileReader>{}, &gReader);
            fSoundReader->setSampleRate(sample_rate);
            fIsDouble = is_double;
            if (!defaultsound) defaultsound = gReader.createSoundfile(gPathNameList, MAX_CHAN, is_double);
        }
    
        /**
         * Create a soundfile loader which will typically use a concrete SoundfileReader like LibsndfileReader or JuceReader to load soundfiles.
         *
         * @param sound_directories - a vector of base directories to look for files, which paths will be relative to these ones
         * @param sample_rate - the audio driver SR which may be different from the file SR, to possibly resample files
         * @param reader - an alternative soundfile reader
         * @param is_double - whether Faust code has been compiled in -double mode and soundfile buffers have to be in double
         *
         * @return the soundfile loader.
         */
        SoundUI(const std::vector<std::string>& sound_directories, int sample_rate = -1, SoundfileReader* reader = nullptr, bool is_double = false)
        :fSoundfileDir(sound_directories)
        {
            fSoundReader = (reader)
                ? std::shared_ptr<SoundfileReader>(reader)
                // the static gReader should not be deleted, so use an empty destructor
                : std::shared_ptr<SoundfileReader>(std::shared_ptr<SoundfileReader>{}, &gReader);
            fSoundReader->setSampleRate(sample_rate);
            fIsDouble = is_double;
            if (!defaultsound) defaultsound = gReader.createSoundfile(gPathNameList, MAX_CHAN, is_double);
        }
    
        virtual ~SoundUI()
        {}

        // -- soundfiles
        virtual void addSoundfile(const char* label, const char* url, Soundfile** sf_zone)
        {
            const char* saved_url = url; // 'url' is consumed by parseMenuList2
            std::vector<std::string> file_name_list;
            
            bool menu = parseMenuList2(url, file_name_list, true);
            // If not a list, we have as single file
            if (!menu) { file_name_list.push_back(saved_url); }
            
            // Parse the possible list
            std::string saved_url_real = std::string(saved_url) + "_" + std::to_string(fIsDouble); // fIsDouble is used in the key
            if (fSoundfileMap.find(saved_url_real) == fSoundfileMap.end()) {
                // Check all files and get their complete path
                std::vector<std::string> path_name_list = fSoundReader->checkFiles(fSoundfileDir, file_name_list);
                // Read them and create the Soundfile
                Soundfile* sound_file = fSoundReader->createSoundfile(path_name_list, MAX_CHAN, fIsDouble);
                if (sound_file) {
                    fSoundfileMap[saved_url_real] = std::shared_ptr<Soundfile>(sound_file);
                } else {
                    // If failure, use 'defaultsound'
                    std::cerr << "addSoundfile : soundfile for " << saved_url << " cannot be created !" << std::endl;
                    *sf_zone = defaultsound;
                    return;
                }
            }
            
            // Get the soundfile pointer
            *sf_zone = fSoundfileMap[saved_url_real].get();
        }
    
        /**
         * An OS dependant function to get the path of the running executable or plugin.
         * This will typically be used when creating a SoundUI soundfile loader, like new SoundUI(SoundUI::getBinaryPath());
         *
         * @return the running executable or plugin path.
         */
        static std::string getBinaryPath()
        {
            std::string bundle_path_str;
        #if defined(__APPLE__) && !defined(__VCVRACK__) && !defined(JUCE_32BIT) && !defined(JUCE_64BIT)
            CFURLRef bundle_ref = CFBundleCopyBundleURL(CFBundleGetMainBundle());
            if (!bundle_ref) { std::cerr << "getBinaryPath CFBundleCopyBundleURL error\n"; return ""; }
      
            UInt8 bundle_path[1024];
            if (CFURLGetFileSystemRepresentation(bundle_ref, true, bundle_path, 1024)) {
                bundle_path_str = std::string((char*)bundle_path);
            } else {
                std::cerr << "getBinaryPath CFURLGetFileSystemRepresentation error\n";
            }
        #endif
        #ifdef ANDROID_DRIVER
            bundle_path_str = "/data/data/__CURRENT_ANDROID_PACKAGE__/files";
        #endif
            return bundle_path_str;
        }
    
        /**
         * An OS dependant function to get the path of the running executable or plugin.
         * This will typically be used when creating a SoundUI soundfile loader, like new SoundUI(SoundUI::getBinaryPathFrom());
         *
         * @param path - entry point to start getting the path of the running executable or plugin.
         *
         * @return the running executable or plugin path.
         */
        static std::string getBinaryPathFrom(const std::string& path)
        {
            std::string bundle_path_str;
        #if defined(__APPLE__) && !defined(__VCVRACK__) && !defined(JUCE_32BIT) && !defined(JUCE_64BIT)
            CFBundleRef bundle = CFBundleGetBundleWithIdentifier(CFStringCreateWithCString(kCFAllocatorDefault, path.c_str(), CFStringGetSystemEncoding()));
            if (!bundle) { std::cerr << "getBinaryPathFrom CFBundleGetBundleWithIdentifier error '" << path << "'" << std::endl; return ""; }
         
            CFURLRef bundle_ref = CFBundleCopyBundleURL(bundle);
            if (!bundle_ref) { std::cerr << "getBinaryPathFrom CFBundleCopyBundleURL error\n"; return ""; }
            
            UInt8 bundle_path[1024];
            if (CFURLGetFileSystemRepresentation(bundle_ref, true, bundle_path, 1024)) {
                bundle_path_str = std::string((char*)bundle_path);
            } else {
                std::cerr << "getBinaryPathFrom CFURLGetFileSystemRepresentation error\n";
            }
        #endif
        #ifdef ANDROID_DRIVER
            bundle_path_str = "/data/data/__CURRENT_ANDROID_PACKAGE__/files";
        #endif
            return bundle_path_str;
        }
};

#endif
/**************************  END  SoundUI.h **************************/
#endif

// Always include this file, otherwise -nvoices only mode does not compile....
/************************** BEGIN MidiUI.h ****************************
FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
************************************************************************/

#ifndef FAUST_MIDIUI_H
#define FAUST_MIDIUI_H

#include <vector>
#include <string>
#include <utility>
#include <cstdlib>
#include <cmath>

/************************** BEGIN MapUI.h ******************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ***********************************************************************/

#ifndef FAUST_MAPUI_H
#define FAUST_MAPUI_H

#include <vector>
#include <map>
#include <string>
#include <stdio.h>


/*******************************************************************************
 * MapUI : Faust User Interface.
 *
 * This class creates:
 * - a map of 'labels' and zones for each UI item.
 * - a map of unique 'shortname' (built so that they never collide) and zones for each UI item
 * - a map of complete hierarchical 'paths' and zones for each UI item
 *
 * Simple 'labels', 'shortname' and complete 'paths' (to fully discriminate between possible same
 * 'labels' at different location in the UI hierachy) can be used to access a given parameter.
 ******************************************************************************/

class FAUST_API MapUI : public UI, public PathBuilder
{
    
    protected:
    
        // Label zone map
        std::map<std::string, FAUSTFLOAT*> fLabelZoneMap;
    
        // Shortname zone map
        std::map<std::string, FAUSTFLOAT*> fShortnameZoneMap;
    
        // Full path map
        std::map<std::string, FAUSTFLOAT*> fPathZoneMap;
    
        void addZoneLabel(const std::string& label, FAUSTFLOAT* zone)
        {
            std::string path = buildPath(label);
            fFullPaths.push_back(path);
            fPathZoneMap[path] = zone;
            fLabelZoneMap[label] = zone;
        }
    
    public:
        
        MapUI() {}
        virtual ~MapUI() {}
        
        // -- widget's layouts
        void openTabBox(const char* label)
        {
            pushLabel(label);
        }
        void openHorizontalBox(const char* label)
        {
            pushLabel(label);
        }
        void openVerticalBox(const char* label)
        {
            pushLabel(label);
        }
        void closeBox()
        {
            if (popLabel()) {
                // Shortnames can be computed when all fullnames are known
                computeShortNames();
                // Fill 'shortname' map
                for (const auto& it : fFullPaths) {
                    fShortnameZoneMap[fFull2Short[it]] = fPathZoneMap[it];
                }
            }
        }
        
        // -- active widgets
        void addButton(const char* label, FAUSTFLOAT* zone)
        {
            addZoneLabel(label, zone);
        }
        void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            addZoneLabel(label, zone);
        }
        void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            addZoneLabel(label, zone);
        }
        void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            addZoneLabel(label, zone);
        }
        void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            addZoneLabel(label, zone);
        }
        
        // -- passive widgets
        void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
        {
            addZoneLabel(label, zone);
        }
        void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
        {
            addZoneLabel(label, zone);
        }
    
        // -- soundfiles
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}
        
        // -- metadata declarations
        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val)
        {}
    
        //-------------------------------------------------------------------------------
        // Public API
        //-------------------------------------------------------------------------------
    
        /**
         * Set the param value.
         *
         * @param str - the UI parameter label/shortname/path
         * @param value - the UI parameter value
         *
         */
        void setParamValue(const std::string& str, FAUSTFLOAT value)
        {
            const auto fPathZoneMapIter = fPathZoneMap.find(str);
            if (fPathZoneMapIter != fPathZoneMap.end()) {
                *fPathZoneMapIter->second = value;
                return;
            }
            
            const auto fShortnameZoneMapIter = fShortnameZoneMap.find(str);
            if (fShortnameZoneMapIter != fShortnameZoneMap.end()) {
                *fShortnameZoneMapIter->second = value;
                return;
            }
            
            const auto fLabelZoneMapIter = fLabelZoneMap.find(str);
            if (fLabelZoneMapIter != fLabelZoneMap.end()) {
                *fLabelZoneMapIter->second = value;
                return;
            }
            
            fprintf(stderr, "ERROR : setParamValue '%s' not found\n", str.c_str());
        }
        
        /**
         * Return the param value.
         *
         * @param str - the UI parameter label/shortname/path
         *
         * @return the param value.
         */
        FAUSTFLOAT getParamValue(const std::string& str)
        {
            const auto fPathZoneMapIter = fPathZoneMap.find(str);
            if (fPathZoneMapIter != fPathZoneMap.end()) {
                return *fPathZoneMapIter->second;
            }
            
            const auto fShortnameZoneMapIter = fShortnameZoneMap.find(str);
            if (fShortnameZoneMapIter != fShortnameZoneMap.end()) {
                return *fShortnameZoneMapIter->second;
            }
            
            const auto fLabelZoneMapIter = fLabelZoneMap.find(str);
            if (fLabelZoneMapIter != fLabelZoneMap.end()) {
                return *fLabelZoneMapIter->second;
            }
            
            fprintf(stderr, "ERROR : getParamValue '%s' not found\n", str.c_str());
            return 0;
        }
    
        // map access 
        std::map<std::string, FAUSTFLOAT*>& getFullpathMap() { return fPathZoneMap; }
        std::map<std::string, FAUSTFLOAT*>& getShortnameMap() { return fShortnameZoneMap; }
        std::map<std::string, FAUSTFLOAT*>& getLabelMap() { return fLabelZoneMap; }
            
        /**
         * Return the number of parameters in the UI.
         *
         * @return the number of parameters
         */
        int getParamsCount() { return int(fPathZoneMap.size()); }
        
        /**
         * Return the param path.
         *
         * @param index - the UI parameter index
         *
         * @return the param path
         */
        std::string getParamAddress(int index)
        {
            if (index < 0 || index > int(fPathZoneMap.size())) {
                return "";
            } else {
                auto it = fPathZoneMap.begin();
                while (index-- > 0 && it++ != fPathZoneMap.end()) {}
                return it->first;
            }
        }
        
        const char* getParamAddress1(int index)
        {
            if (index < 0 || index > int(fPathZoneMap.size())) {
                return nullptr;
            } else {
                auto it = fPathZoneMap.begin();
                while (index-- > 0 && it++ != fPathZoneMap.end()) {}
                return it->first.c_str();
            }
        }
    
        /**
         * Return the param shortname.
         *
         * @param index - the UI parameter index
         *
         * @return the param shortname
         */
        std::string getParamShortname(int index)
        {
            if (index < 0 || index > int(fShortnameZoneMap.size())) {
                return "";
            } else {
                auto it = fShortnameZoneMap.begin();
                while (index-- > 0 && it++ != fShortnameZoneMap.end()) {}
                return it->first;
            }
        }
        
        const char* getParamShortname1(int index)
        {
            if (index < 0 || index > int(fShortnameZoneMap.size())) {
                return nullptr;
            } else {
                auto it = fShortnameZoneMap.begin();
                while (index-- > 0 && it++ != fShortnameZoneMap.end()) {}
                return it->first.c_str();
            }
        }
    
        /**
         * Return the param label.
         *
         * @param index - the UI parameter index
         *
         * @return the param label
         */
        std::string getParamLabel(int index)
        {
            if (index < 0 || index > int(fLabelZoneMap.size())) {
                return "";
            } else {
                auto it = fLabelZoneMap.begin();
                while (index-- > 0 && it++ != fLabelZoneMap.end()) {}
                return it->first;
            }
        }
        
        const char* getParamLabel1(int index)
        {
            if (index < 0 || index > int(fLabelZoneMap.size())) {
                return nullptr;
            } else {
                auto it = fLabelZoneMap.begin();
                while (index-- > 0 && it++ != fLabelZoneMap.end()) {}
                return it->first.c_str();
            }
        }
    
        /**
         * Return the param path.
         *
         * @param zone - the UI parameter memory zone
         *
         * @return the param path
         */
        std::string getParamAddress(FAUSTFLOAT* zone)
        {
            for (const auto& it : fPathZoneMap) {
                if (it.second == zone) return it.first;
            }
            return "";
        }
    
        /**
         * Return the param memory zone.
         *
         * @param zone - the UI parameter label/shortname/path
         *
         * @return the param path
         */
        FAUSTFLOAT* getParamZone(const std::string& str)
        {
            const auto fPathZoneMapIter = fPathZoneMap.find(str);
            if (fPathZoneMapIter != fPathZoneMap.end()) {
                return fPathZoneMapIter->second;
            }
            
            const auto fShortnameZoneMapIter = fShortnameZoneMap.find(str);
            if (fShortnameZoneMapIter != fShortnameZoneMap.end()) {
                return fShortnameZoneMapIter->second;
            }
            
            const auto fLabelZoneMapIter = fLabelZoneMap.find(str);
            if (fLabelZoneMapIter != fLabelZoneMap.end()) {
                return fLabelZoneMapIter->second;
            }

            return nullptr;
        }
    
        /**
         * Return the param memory zone.
         *
         * @param zone - the UI parameter index
         *
         * @return the param path
         */
        FAUSTFLOAT* getParamZone(int index)
        {
            if (index < 0 || index > int(fPathZoneMap.size())) {
                return nullptr;
            } else {
                auto it = fPathZoneMap.begin();
                while (index-- > 0 && it++ != fPathZoneMap.end()) {}
                return it->second;
            }
        }
    
        static bool endsWith(const std::string& str, const std::string& end)
        {
            size_t l1 = str.length();
            size_t l2 = end.length();
            return (l1 >= l2) && (0 == str.compare(l1 - l2, l2, end));
        }
    
};

#endif // FAUST_MAPUI_H
/**************************  END  MapUI.h **************************/
/************************** BEGIN midi.h *******************************
FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
************************************************************************/

#ifndef __midi__
#define __midi__

#include <vector>
#include <string>
#include <string.h>
#include <algorithm>
#include <assert.h>


class FAUST_API MapUI;

/**
 * A timestamped short MIDI message used with SOUL.
 */

// Force contiguous memory layout
#pragma pack (push, 1)
struct MIDIMessage
{
    uint32_t frameIndex;
    uint8_t byte0, byte1, byte2;
};
#pragma pack (pop)

/**
 * For timestamped MIDI messages (in usec).
 */
struct DatedMessage {
    
    double fDate;
    unsigned char fBuffer[3];
    size_t fSize;
    
    DatedMessage(double date, unsigned char* buffer, size_t size)
    :fDate(date), fSize(size)
    {
        assert(size <= 3);
        memcpy(fBuffer, buffer, size);
    }
    
    DatedMessage():fDate(0.0), fSize(0)
    {}
    
};

/**
 * MIDI processor definition.
 *
 * MIDI input or output handling classes will implement this interface,
 * so the same method names (keyOn, keyOff, ctrlChange...) will be used either
 * when decoding MIDI input or encoding MIDI output events.
 * MIDI channel is numbered in [0..15] in this layer.
 */
class midi {

    public:

        midi() {}
        virtual ~midi() {}

        // Additional time-stamped API for MIDI input
        virtual MapUI* keyOn(double, int channel, int pitch, int velocity)
        {
            return keyOn(channel, pitch, velocity);
        }
        
        virtual void keyOff(double, int channel, int pitch, int velocity = 0)
        {
            keyOff(channel, pitch, velocity);
        }
    
        virtual void keyPress(double, int channel, int pitch, int press)
        {
            keyPress(channel, pitch, press);
        }
        
        virtual void chanPress(double date, int channel, int press)
        {
            chanPress(channel, press);
        }
    
        virtual void pitchWheel(double, int channel, int wheel)
        {
            pitchWheel(channel, wheel);
        }
           
        virtual void ctrlChange(double, int channel, int ctrl, int value)
        {
            ctrlChange(channel, ctrl, value);
        }
    
        virtual void ctrlChange14bits(double, int channel, int ctrl, int value)
        {
            ctrlChange14bits(channel, ctrl, value);
        }
    
        virtual void rpn(double, int channel, int ctrl, int value)
        {
            rpn(channel, ctrl, value);
        }

        virtual void progChange(double, int channel, int pgm)
        {
            progChange(channel, pgm);
        }
    
        virtual void sysEx(double, std::vector<unsigned char>& message)
        {
            sysEx(message);
        }

        // MIDI sync
        virtual void startSync(double date)  {}
        virtual void stopSync(double date)   {}
        virtual void clock(double date)  {}

        // Standard MIDI API
        virtual MapUI* keyOn(int channel, int pitch, int velocity)      { return nullptr; }
        virtual void keyOff(int channel, int pitch, int velocity)       {}
        virtual void keyPress(int channel, int pitch, int press)        {}
        virtual void chanPress(int channel, int press)                  {}
        virtual void ctrlChange(int channel, int ctrl, int value)       {}
        virtual void ctrlChange14bits(int channel, int ctrl, int value) {}
        virtual void rpn(int channel, int ctrl, int value)              {}
        virtual void pitchWheel(int channel, int wheel)                 {}
        virtual void progChange(int channel, int pgm)                   {}
        virtual void sysEx(std::vector<unsigned char>& message)         {}

        enum MidiStatus {
            // channel voice messages
            MIDI_NOTE_OFF = 0x80,
            MIDI_NOTE_ON = 0x90,
            MIDI_CONTROL_CHANGE = 0xB0,
            MIDI_PROGRAM_CHANGE = 0xC0,
            MIDI_PITCH_BEND = 0xE0,
            MIDI_AFTERTOUCH = 0xD0,         // aka channel pressure
            MIDI_POLY_AFTERTOUCH = 0xA0,    // aka key pressure
            MIDI_CLOCK = 0xF8,
            MIDI_START = 0xFA,
            MIDI_CONT = 0xFB,
            MIDI_STOP = 0xFC,
            MIDI_SYSEX_START = 0xF0,
            MIDI_SYSEX_STOP = 0xF7
        };

        enum MidiCtrl {
            ALL_NOTES_OFF = 123,
            ALL_SOUND_OFF = 120
        };
    
        enum MidiNPN {
            PITCH_BEND_RANGE = 0
        };

};

/**
 * A class to decode NRPN and RPN messages, adapted from JUCE forum message:
 * https://forum.juce.com/t/14bit-midi-controller-support/11517
 */
class MidiNRPN {
    
    private:
    
        bool ctrlnew;
        int ctrlnum;
        int ctrlval;
        
        int nrpn_lsb, nrpn_msb;
        int data_lsb, data_msb;
        
        enum
        {
            midi_nrpn_lsb = 98,
            midi_nrpn_msb = 99,
            midi_rpn_lsb  = 100,
            midi_rpn_msb  = 101,
            midi_data_lsb = 38,
            midi_data_msb = 6
        };
    
    public:
        
        MidiNRPN(): ctrlnew(false), nrpn_lsb(-1), nrpn_msb(-1), data_lsb(-1), data_msb(-1)
        {}
        
        // return true if the message has been filtered
        bool process(int data1, int data2)
        {
            switch (data1)
            {
                case midi_nrpn_lsb: nrpn_lsb = data2; return true;
                case midi_nrpn_msb: nrpn_msb = data2; return true;
                case midi_rpn_lsb: {
                    if (data2 == 127) {
                        nrpn_lsb = data_lsb = -1;
                    } else {
                        nrpn_lsb = 0;
                        data_lsb = -1;
                    }
                    return true;
                }
                case midi_rpn_msb: {
                    if (data2 == 127) {
                        nrpn_msb = data_msb = -1;
                    } else {
                        nrpn_msb = 0;
                        data_msb = -1;
                    }
                    return true;
                }
                case midi_data_lsb:
                case midi_data_msb:
                {
                    if (data1 == midi_data_msb) {
                        if (nrpn_msb < 0) {
                            return false;
                        }
                        data_msb = data2;
                    } else { // midi_data_lsb
                        if (nrpn_lsb < 0) {
                            return false;
                        }
                        data_lsb = data2;
                    }
                    if (data_lsb >= 0 && data_msb >= 0) {
                        ctrlnum = (nrpn_msb << 7) | nrpn_lsb;
                        ctrlval = (data_msb << 7) | data_lsb;
                        data_lsb = data_msb = -1;
                        nrpn_msb = nrpn_lsb = -1;
                        ctrlnew = true;
                    }
                    return true;
                }
                default: return false;
            };
        }
        
        bool hasNewNRPN() { bool res = ctrlnew; ctrlnew = false; return res; }
        
        // results in [0, 16383]
        int getCtrl() const { return ctrlnum; }
        int getVal() const { return ctrlval; }
    
};

/**
 * A pure interface for MIDI handlers that can send/receive MIDI messages to/from 'midi' objects.
 */
struct midi_interface {
    virtual void addMidiIn(midi* midi_dsp)      = 0;
    virtual void removeMidiIn(midi* midi_dsp)   = 0;
    virtual ~midi_interface() {}
};

/****************************************************
 * Base class for MIDI input handling.
 *
 * Shared common code used for input handling:
 * - decoding Real-Time messages: handleSync
 * - decoding one data byte messages: handleData1
 * - decoding two data byte messages: handleData2
 * - getting ready messages in polling mode
 ****************************************************/
class midi_handler : public midi, public midi_interface {

    protected:

        std::vector<midi*> fMidiInputs;
        std::string fName;
        MidiNRPN fNRPN;
    
        int range(int min, int max, int val) { return (val < min) ? min : ((val >= max) ? max : val); }
  
    public:

        midi_handler(const std::string& name = "MIDIHandler"):midi_interface(), fName(name) {}
        virtual ~midi_handler() {}

        void addMidiIn(midi* midi_dsp) { if (midi_dsp) fMidiInputs.push_back(midi_dsp); }
        void removeMidiIn(midi* midi_dsp)
        {
            std::vector<midi*>::iterator it = std::find(fMidiInputs.begin(), fMidiInputs.end(), midi_dsp);
            if (it != fMidiInputs.end()) {
                fMidiInputs.erase(it);
            }
        }

        // Those 2 methods have to be implemented by subclasses
        virtual bool startMidi() { return true; }
        virtual void stopMidi() {}
    
        void setName(const std::string& name) { fName = name; }
        std::string getName() { return fName; }
    
        // To be used in polling mode
        virtual int recvMessages(std::vector<MIDIMessage>* message) { return 0; }
        virtual void sendMessages(std::vector<MIDIMessage>* message, int count) {}
    
        // MIDI Real-Time
        void handleClock(double time)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->clock(time);
            }
        }
        
        void handleStart(double time)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->startSync(time);
            }
        }
        
        void handleStop(double time)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->stopSync(time);
            }
        }
    
        void handleSync(double time, int type)
        {
            if (type == MIDI_CLOCK) {
                handleClock(time);
            // We can consider start and continue as identical messages
            } else if ((type == MIDI_START) || (type == MIDI_CONT)) {
                handleStart(time);
            } else if (type == MIDI_STOP) {
                handleStop(time);
            }
        }
    
        // MIDI 1 data
        void handleProgChange(double time, int channel, int data1)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->progChange(time, channel, data1);
            }
        }
    
        void handleAfterTouch(double time, int channel, int data1)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->chanPress(time, channel, data1);
            }
        }

        void handleData1(double time, int type, int channel, int data1)
        {
            if (type == MIDI_PROGRAM_CHANGE) {
                handleProgChange(time, channel, data1);
            } else if (type == MIDI_AFTERTOUCH) {
                handleAfterTouch(time, channel, data1);
            }
        }
    
        // MIDI 2 datas
        void handleKeyOff(double time, int channel, int data1, int data2)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->keyOff(time, channel, data1, data2);
            }
        }
        
        void handleKeyOn(double time, int channel, int data1, int data2)
        {
            if (data2 == 0) {
                handleKeyOff(time, channel, data1, data2);
            } else {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->keyOn(time, channel, data1, data2);
                }
            }
        }
    
        void handleCtrlChange(double time, int channel, int data1, int data2)
        {
            // Special processing for NRPN and RPN
            if (fNRPN.process(data1, data2)) {
                if (fNRPN.hasNewNRPN()) {
                    for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                        fMidiInputs[i]->rpn(time, channel, fNRPN.getCtrl(), fNRPN.getVal());
                    }
                }
            } else {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->ctrlChange(time, channel, data1, data2);
                }
            }
        }
        
        void handlePitchWheel(double time, int channel, int data1, int data2)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->pitchWheel(time, channel, (data2 << 7) + data1);
            }
        }
    
        void handlePitchWheel(double time, int channel, int bend)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->pitchWheel(time, channel, bend);
            }
        }
        
        void handlePolyAfterTouch(double time, int channel, int data1, int data2)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->keyPress(time, channel, data1, data2);
            }
        }
  
        void handleData2(double time, int type, int channel, int data1, int data2)
        {
            if (type == MIDI_NOTE_OFF) {
                handleKeyOff(time, channel,  data1, data2);
            } else if (type == MIDI_NOTE_ON) {
                handleKeyOn(time, channel, data1, data2);
            } else if (type == MIDI_CONTROL_CHANGE) {
                handleCtrlChange(time, channel, data1, data2);
            } else if (type == MIDI_PITCH_BEND) {
                handlePitchWheel(time, channel, data1, data2);
            } else if (type == MIDI_POLY_AFTERTOUCH) {
                handlePolyAfterTouch(time, channel, data1, data2);
            }
        }
    
        // SysEx
        void handleSysex(double time, std::vector<unsigned char>& message)
        {
            for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                fMidiInputs[i]->sysEx(time, message);
            }
        }
    
        void handleMessage(double time, int type, std::vector<unsigned char>& message)
        {
            if (type == MIDI_SYSEX_START) {
                handleSysex(time, message);
            }
        }
  
};

#define ucast(v) static_cast<unsigned char>(v)

#endif // __midi__
/**************************  END  midi.h **************************/

#ifdef _MSC_VER
#define gsscanf sscanf_s
#else
#define gsscanf sscanf
#endif

/**
 * Helper code for MIDI meta and polyphonic 'nvoices' parsing.
 */
struct MidiMeta : public Meta, public std::map<std::string, std::string> {
    
    void declare(const char* key, const char* value)
    {
        (*this)[key] = value;
    }
    
    const std::string get(const char* key, const char* def)
    {
        return (this->find(key) != this->end()) ? (*this)[key] : def;
    }
    
    static void analyse(dsp* mono_dsp, bool& midi_sync, int& nvoices)
    {
        JSONUI jsonui;
        mono_dsp->buildUserInterface(&jsonui);
        std::string json = jsonui.JSON();
        midi_sync = ((json.find("midi") != std::string::npos) &&
                     ((json.find("start") != std::string::npos) ||
                      (json.find("stop") != std::string::npos) ||
                      (json.find("clock") != std::string::npos) ||
                      (json.find("timestamp") != std::string::npos)));
    
    #if defined(NVOICES) && NVOICES!=NUM_VOICES
        nvoices = NVOICES;
    #else
        MidiMeta meta;
        mono_dsp->metadata(&meta);
        bool found_voices = false;
        // If "options" metadata is used
        std::string options = meta.get("options", "");
        if (options != "") {
            std::map<std::string, std::string> metadata;
            std::string res;
            MetaDataUI::extractMetadata(options, res, metadata);
            if (metadata.find("nvoices") != metadata.end()) {
                nvoices = std::atoi(metadata["nvoices"].c_str());
                found_voices = true;
            }
        }
        // Otherwise test for "nvoices" metadata
        if (!found_voices) {
            std::string numVoices = meta.get("nvoices", "0");
            nvoices = std::atoi(numVoices.c_str());
        }
        nvoices = std::max<int>(0, nvoices);
    #endif
    }
    
    static bool checkPolyphony(dsp* mono_dsp)
    {
        MapUI map_ui;
        mono_dsp->buildUserInterface(&map_ui);
        bool has_freq = false;
        bool has_gate = false;
        bool has_gain = false;
        for (int i = 0; i < map_ui.getParamsCount(); i++) {
            std::string path = map_ui.getParamAddress(i);
            has_freq |= MapUI::endsWith(path, "/freq");
            has_freq |= MapUI::endsWith(path, "/key");
            has_gate |= MapUI::endsWith(path, "/gate");
            has_gain |= MapUI::endsWith(path, "/gain");
            has_gain |= MapUI::endsWith(path, "/vel");
            has_gain |= MapUI::endsWith(path, "/velocity");
        }
        return (has_freq && has_gate && has_gain);
    }
    
};

/**
 * uiMidi : Faust User Interface
 * This class decodes MIDI meta data and maps incoming MIDI messages to them.
 * Currently ctrlChange, keyOn/keyOff, keyPress, progChange, chanPress, pitchWheel/pitchBend
 * start/stop/clock meta data is handled.
 * MIDI channel is numbered in [1..16] in this layer.
 * Channel 0 means "all channels" when receiving or sending.
 */
class uiMidi {
    
    friend class MidiUI;
    
    protected:
        
        midi* fMidiOut;
        bool fInputCtrl;
        int fChan;
    
        bool inRange(FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT v) { return (min <= v && v <= max); }
    
    public:
        
        uiMidi(midi* midi_out, bool input, int chan = 0):fMidiOut(midi_out), fInputCtrl(input), fChan(chan)
        {}
        virtual ~uiMidi()
        {}

};

/**
 * Base class for MIDI aware UI items.
 */
class uiMidiItem : public uiMidi, public uiItem {
    
    public:
        
        uiMidiItem(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true, int chan = 0)
            :uiMidi(midi_out, input, chan), uiItem(ui, zone)
        {}
        virtual ~uiMidiItem()
        {}
    
        virtual void reflectZone() {}
    
};

/**
 * Base class for MIDI aware UI items with timestamp support.
 */
class uiMidiTimedItem : public uiMidi, public uiTimedItem {
    
    public:
        
        uiMidiTimedItem(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true, int chan = 0)
            :uiMidi(midi_out, input, chan), uiTimedItem(ui, zone)
        {}
        virtual ~uiMidiTimedItem()
        {}
    
        virtual void reflectZone() {}
    
};

/**
 * MIDI sync.
 */
class uiMidiStart : public uiMidiTimedItem
{
  
    public:
    
        uiMidiStart(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input)
        {}
        virtual ~uiMidiStart()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            if (v != FAUSTFLOAT(0)) {
                fMidiOut->startSync(0);
            }
        }
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(v));
            }
        }
        
};

class uiMidiStop : public uiMidiTimedItem {
  
    public:
    
        uiMidiStop(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input)
        {}
        virtual ~uiMidiStop()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            if (v != FAUSTFLOAT(1)) {
                fMidiOut->stopSync(0);
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(v));
            }
        }
};

class uiMidiClock : public uiMidiTimedItem {

    private:
        
        bool fState;
  
    public:
    
        uiMidiClock(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input), fState(false)
        {}
        virtual ~uiMidiClock()
        {}
    
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fMidiOut->clock(0);
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                fState = !fState;
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fState));
            }
        }

};

/**
 * Standard MIDI events.
 */

/**
 * uiMidiProgChange uses the [min...max] range.
 */
class uiMidiProgChange : public uiMidiTimedItem {
    
    public:
    
        FAUSTFLOAT fMin, fMax;
    
        uiMidiProgChange(midi* midi_out, GUI* ui, FAUSTFLOAT* zone,
                         FAUSTFLOAT min, FAUSTFLOAT max,
                         bool input = true, int chan = 0)
            :uiMidiTimedItem(midi_out, ui, zone, input, chan), fMin(min), fMax(max)
        {}
        virtual ~uiMidiProgChange()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            if (inRange(fMin, fMax, v)) {
                if (fChan == 0) {
                    // Send on [0..15] channels on the MIDI layer
                    for (int chan = 0; chan < 16; chan++) {
                        fMidiOut->progChange(chan, v);
                    }
                } else {
                    fMidiOut->progChange(fChan - 1, v);
                }
            }
        }
    
        void modifyZone(FAUSTFLOAT v)
        {
            if (fInputCtrl && inRange(fMin, fMax, v)) {
                uiItem::modifyZone(v);
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl && inRange(fMin, fMax, v)) {
                uiMidiTimedItem::modifyZone(date, v);
            }
        }
        
};

/**
 * uiMidiChanPress.
 */
class uiMidiChanPress : public uiMidiTimedItem, public uiConverter {
    
    public:
    
        uiMidiChanPress(midi* midi_out, GUI* ui,
                        FAUSTFLOAT* zone,
                        FAUSTFLOAT min, FAUSTFLOAT max,
                        bool input = true,
                        MetaDataUI::Scale scale = MetaDataUI::kLin,
                        int chan = 0)
            :uiMidiTimedItem(midi_out, ui, zone, input, chan), uiConverter(scale, 0., 127., min, max)
        {}
        virtual ~uiMidiChanPress()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            int conv = std::round(fConverter->faust2ui(v));
            if (fChan == 0) {
                // Send on [0..15] channels on the MIDI layer
                for (int chan = 0; chan < 16; chan++) {
                    fMidiOut->chanPress(chan, conv);
                }
            } else {
                fMidiOut->chanPress(fChan - 1, conv);
            }
        }
    
        void modifyZone(FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
        
};

/**
 * uiMidiCtrlChange does scale (kLin/kLog/kExp) mapping.
 */
class uiMidiCtrlChange : public uiMidiTimedItem, public uiConverter {
    
    private:
    
        int fCtrl;
 
    public:

        uiMidiCtrlChange(midi* midi_out, int ctrl, GUI* ui,
                     FAUSTFLOAT* zone,
                     FAUSTFLOAT min, FAUSTFLOAT max,
                     bool input = true,
                     MetaDataUI::Scale scale = MetaDataUI::kLin,
                     int chan = 0)
            :uiMidiTimedItem(midi_out, ui, zone, input, chan), uiConverter(scale, 0., 127., min, max), fCtrl(ctrl)
        {}
        virtual ~uiMidiCtrlChange()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            int conv = std::round(fConverter->faust2ui(v));
            if (fChan == 0) {
                // Send on [0..15] channels on the MIDI layer
                for (int chan = 0; chan < 16; chan++) {
                    fMidiOut->ctrlChange(chan, fCtrl, conv);
                }
            } else {
                fMidiOut->ctrlChange(fChan - 1, fCtrl, conv);
            }
        }
        
        void modifyZone(FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
};

// Use a two segments linear converter
class uiMidiPitchWheel : public uiMidiTimedItem {

    private:
    
        LinearValueConverter2 fConverter;
    
    public:
    
        uiMidiPitchWheel(midi* midi_out, GUI* ui, FAUSTFLOAT* zone,
                         FAUSTFLOAT min, FAUSTFLOAT max,
                         bool input = true, int chan = 0)
            :uiMidiTimedItem(midi_out, ui, zone, input, chan)
        {
            if (min <= 0 && max >= 0) {
                fConverter = LinearValueConverter2(0., 8191., 16383., double(min), 0., double(max));
            } else {
                // Degenerated case...
                fConverter = LinearValueConverter2(0., 8191., 16383., double(min),double(min + (max - min)/FAUSTFLOAT(2)), double(max));
            }
        }
    
        virtual ~uiMidiPitchWheel()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            int conv = std::round(fConverter.faust2ui(v));
            if (fChan == 0) {
                // Send on [0..15] channels on the MIDI layer
                for (int chan = 0; chan < 16; chan++) {
                    fMidiOut->pitchWheel(chan, conv);
                }
            } else {
                fMidiOut->pitchWheel(fChan - 1, conv);
            }
        }
        
        void modifyZone(FAUSTFLOAT v)
        { 
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
    
        void setRange(int val)
        {
            double semi = (val / 128) + ((val % 128) / 100.);
            fConverter.setMappingValues(0., 8191., 16383., -semi, 0., semi);
        }
 
};

/**
 * uiMidiKeyOn does scale (kLin/kLog/kExp) mapping for velocity.
 */
class uiMidiKeyOn : public uiMidiTimedItem, public uiConverter {

    private:
        
        int fKeyOn;
  
    public:
    
        uiMidiKeyOn(midi* midi_out, int key, GUI* ui,
                    FAUSTFLOAT* zone,
                    FAUSTFLOAT min, FAUSTFLOAT max,
                    bool input = true,
                    MetaDataUI::Scale scale = MetaDataUI::kLin,
                    int chan = 0)
            :uiMidiTimedItem(midi_out, ui, zone, input, chan), uiConverter(scale, 0., 127., min, max), fKeyOn(key)
        {}
        virtual ~uiMidiKeyOn()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            int conv = std::round(fConverter->faust2ui(v));
            if (fChan == 0) {
                // Send on [0..15] channels on the MIDI layer
                for (int chan = 0; chan < 16; chan++) {
                    fMidiOut->keyOn(chan, fKeyOn, conv);
                }
            } else {
                fMidiOut->keyOn(fChan - 1, fKeyOn, conv);
            }
        }
        
        void modifyZone(FAUSTFLOAT v)
        { 
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
    
};

/**
 * uiMidiKeyOff does scale (kLin/kLog/kExp) mapping for velocity.
 */
class uiMidiKeyOff : public uiMidiTimedItem, public uiConverter {

    private:
        
        int fKeyOff;
  
    public:
    
        uiMidiKeyOff(midi* midi_out, int key, GUI* ui,
                     FAUSTFLOAT* zone,
                     FAUSTFLOAT min, FAUSTFLOAT max,
                     bool input = true,
                     MetaDataUI::Scale scale = MetaDataUI::kLin,
                     int chan = 0)
            :uiMidiTimedItem(midi_out, ui, zone, input, chan), uiConverter(scale, 0., 127., min, max), fKeyOff(key)
        {}
        virtual ~uiMidiKeyOff()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            int conv = std::round(fConverter->faust2ui(v));
            if (fChan == 0) {
                // Send on [0..15] channels on the MIDI layer
                for (int chan = 0; chan < 16; chan++) {
                    fMidiOut->keyOff(chan, fKeyOff, conv);
                }
            } else {
                fMidiOut->keyOff(fChan - 1, fKeyOff, conv);
            }
        }
        
        void modifyZone(FAUSTFLOAT v)
        { 
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
    
};

/**
 * uiMidiKeyPress does scale (kLin/kLog/kExp) mapping for velocity.
 */
class uiMidiKeyPress : public uiMidiTimedItem, public uiConverter {

    private:
    
        int fKey;
  
    public:
    
        uiMidiKeyPress(midi* midi_out, int key, GUI* ui,
                       FAUSTFLOAT* zone,
                       FAUSTFLOAT min, FAUSTFLOAT max,
                       bool input = true,
                       MetaDataUI::Scale scale = MetaDataUI::kLin,
                       int chan = 0)
            :uiMidiTimedItem(midi_out, ui, zone, input, chan), uiConverter(scale, 0., 127., min, max), fKey(key)
        {}
        virtual ~uiMidiKeyPress()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            int conv = std::round(fConverter->faust2ui(v));
            if (fChan == 0) {
                // Send on [0..15] channels on the MIDI layer
                for (int chan = 0; chan < 16; chan++) {
                    fMidiOut->keyPress(chan, fKey, conv);
                }
            } else {
                fMidiOut->keyPress(fChan - 1, fKey, conv);
            }
        }
        
        void modifyZone(FAUSTFLOAT v)
        { 
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fConverter->ui2faust(v)));
            }
        }
    
};

/******************************************************************************************
 * MidiUI : Faust User Interface
 * This class decodes MIDI metadata and maps incoming MIDI messages to them.
 * Currently ctrlChange, keyOn/keyOff, keyPress, progChange, chanPress, pitchWheel/pitchBend
 * start/stop/clock meta data are handled.
 *
 * Maps associating MIDI event ID (like each ctrl number) with all MIDI aware UI items
 * are defined and progressively filled when decoding MIDI related metadata.
 * MIDI aware UI items are used in both directions:
 *  - modifying their internal state when receving MIDI input events
 *  - sending their internal state as MIDI output events
 *******************************************************************************************/

class MidiUI : public GUI, public midi, public midi_interface, public MetaDataUI {

    // Add uiItem subclasses objects are deallocated by the inherited GUI class
    typedef std::map <int, std::vector<uiMidiCtrlChange*> > TCtrlChangeTable;
    typedef std::vector<uiMidiProgChange*>                  TProgChangeTable;
    typedef std::vector<uiMidiChanPress*>                   TChanPressTable;
    typedef std::map <int, std::vector<uiMidiKeyOn*> >      TKeyOnTable;
    typedef std::map <int, std::vector<uiMidiKeyOff*> >     TKeyOffTable;
    typedef std::map <int, std::vector<uiMidiKeyPress*> >   TKeyPressTable;
    typedef std::vector<uiMidiPitchWheel*>                  TPitchWheelTable;
    
    protected:
    
        TCtrlChangeTable fCtrlChangeTable;
        TProgChangeTable fProgChangeTable;
        TChanPressTable  fChanPressTable;
        TKeyOnTable      fKeyOnTable;
        TKeyOffTable     fKeyOffTable;
        TKeyOnTable      fKeyTable;
        TKeyPressTable   fKeyPressTable;
        TPitchWheelTable fPitchWheelTable;
        
        std::vector<uiMidiStart*> fStartTable;
        std::vector<uiMidiStop*>  fStopTable;
        std::vector<uiMidiClock*> fClockTable;
        
        std::vector<std::pair <std::string, std::string> > fMetaAux;
        
        midi_handler* fMidiHandler;
        bool fDelete;
        bool fTimeStamp;
    
        void addGenericZone(FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max, bool input = true)
        {
            if (fMetaAux.size() > 0) {
                for (size_t i = 0; i < fMetaAux.size(); i++) {
                    unsigned num;
                    unsigned chan;
                    if (fMetaAux[i].first == "midi") {
                        if (gsscanf(fMetaAux[i].second.c_str(), "ctrl %u %u", &num, &chan) == 2) {
                            fCtrlChangeTable[num].push_back(new uiMidiCtrlChange(fMidiHandler, num, this, zone, min, max, input, getScale(zone), chan));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "ctrl %u", &num) == 1) {
                            fCtrlChangeTable[num].push_back(new uiMidiCtrlChange(fMidiHandler, num, this, zone, min, max, input, getScale(zone)));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "keyon %u %u", &num, &chan) == 2) {
                            fKeyOnTable[num].push_back(new uiMidiKeyOn(fMidiHandler, num, this, zone, min, max, input, getScale(zone), chan));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "keyon %u", &num) == 1) {
                            fKeyOnTable[num].push_back(new uiMidiKeyOn(fMidiHandler, num, this, zone, min, max, input, getScale(zone)));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "keyoff %u %u", &num, &chan) == 2) {
                            fKeyOffTable[num].push_back(new uiMidiKeyOff(fMidiHandler, num, this, zone, min, max, input, getScale(zone), chan));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "keyoff %u", &num) == 1) {
                            fKeyOffTable[num].push_back(new uiMidiKeyOff(fMidiHandler, num, this, zone, min, max, input, getScale(zone)));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "key %u %u", &num, &chan) == 2) {
                            fKeyTable[num].push_back(new uiMidiKeyOn(fMidiHandler, num, this, zone, min, max, input, getScale(zone), chan));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "key %u", &num) == 1) {
                            fKeyTable[num].push_back(new uiMidiKeyOn(fMidiHandler, num, this, zone, min, max, input, getScale(zone)));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "keypress %u %u", &num, &chan) == 2) {
                            fKeyPressTable[num].push_back(new uiMidiKeyPress(fMidiHandler, num, this, zone, min, max, input, getScale(zone), chan));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "keypress %u", &num) == 1) {
                            fKeyPressTable[num].push_back(new uiMidiKeyPress(fMidiHandler, num, this, zone, min, max, input, getScale(zone)));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "pgm %u", &chan) == 1) {
                            fProgChangeTable.push_back(new uiMidiProgChange(fMidiHandler, this, zone, min, max, input, chan));
                        } else if (strcmp(fMetaAux[i].second.c_str(), "pgm") == 0) {
                            fProgChangeTable.push_back(new uiMidiProgChange(fMidiHandler, this, zone, min, max, input));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "chanpress %u", &chan) == 1) {
                            fChanPressTable.push_back(new uiMidiChanPress(fMidiHandler, this, zone, min, max, input, getScale(zone), chan));
                        } else if ((fMetaAux[i].second == "chanpress")) {
                            fChanPressTable.push_back(new uiMidiChanPress(fMidiHandler, this, zone, min, max, input, getScale(zone)));
                        } else if ((gsscanf(fMetaAux[i].second.c_str(), "pitchwheel %u", &chan) == 1) || (gsscanf(fMetaAux[i].second.c_str(), "pitchbend %u", &chan) == 1)) {
                            fPitchWheelTable.push_back(new uiMidiPitchWheel(fMidiHandler, this, zone, min, max, input, chan));
                        } else if ((fMetaAux[i].second == "pitchwheel") || (fMetaAux[i].second == "pitchbend")) {
                            fPitchWheelTable.push_back(new uiMidiPitchWheel(fMidiHandler, this, zone, min, max, input));
                        // MIDI sync
                        } else if (fMetaAux[i].second == "start") {
                            fStartTable.push_back(new uiMidiStart(fMidiHandler, this, zone, input));
                        } else if (fMetaAux[i].second == "stop") {
                            fStopTable.push_back(new uiMidiStop(fMidiHandler, this, zone, input));
                        } else if (fMetaAux[i].second == "clock") {
                            fClockTable.push_back(new uiMidiClock(fMidiHandler, this, zone, input));
                        // Explicit metadata to activate 'timestamp' mode
                        } else if (fMetaAux[i].second == "timestamp") {
                            fTimeStamp = true;
                        }
                    }
                }
            }
            fMetaAux.clear();
        }
    
        template <typename TABLE>
        void updateTable1(TABLE& table, double date, int channel, int val1)
        {
            for (size_t i = 0; i < table.size(); i++) {
                int channel_aux = table[i]->fChan;
                // channel_aux == 0 means "all channels"
                if (channel_aux == 0 || channel == channel_aux - 1) {
                    if (fTimeStamp) {
                        table[i]->modifyZone(date, FAUSTFLOAT(val1));
                    } else {
                        table[i]->modifyZone(FAUSTFLOAT(val1));
                    }
                }
            }
        }
        
        template <typename TABLE>
        void updateTable2(TABLE& table, double date, int channel, int val1, int val2)
        {
            if (table.find(val1) != table.end()) {
                for (size_t i = 0; i < table[val1].size(); i++) {
                    int channel_aux = table[val1][i]->fChan;
                    // channel_aux == 0 means "all channels"
                    if (channel_aux == 0 || channel == channel_aux - 1) {
                        if (fTimeStamp) {
                            table[val1][i]->modifyZone(date, FAUSTFLOAT(val2));
                        } else {
                            table[val1][i]->modifyZone(FAUSTFLOAT(val2));
                        }
                    }
                }
            }
        }
    
    public:
    
        MidiUI(midi_handler* midi_handler, bool delete_handler = false)
        {
            fMidiHandler = midi_handler;
            fMidiHandler->addMidiIn(this);
            // TODO: use shared_ptr based implementation
            fDelete = delete_handler;
            fTimeStamp = false;
        }
 
        virtual ~MidiUI() 
        {
            // Remove from fMidiHandler
            fMidiHandler->removeMidiIn(this);
            // TODO: use shared_ptr based implementation
            if (fDelete) delete fMidiHandler;
        }
    
        bool run() { return fMidiHandler->startMidi(); }
        void stop() { fMidiHandler->stopMidi(); }
        
        void addMidiIn(midi* midi_dsp) { fMidiHandler->addMidiIn(midi_dsp); }
        void removeMidiIn(midi* midi_dsp) { fMidiHandler->removeMidiIn(midi_dsp); }
      
        // -- active widgets
        
        virtual void addButton(const char* label, FAUSTFLOAT* zone)
        {
            addGenericZone(zone, FAUSTFLOAT(0), FAUSTFLOAT(1));
        }
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            addGenericZone(zone, FAUSTFLOAT(0), FAUSTFLOAT(1));
        }
        
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addGenericZone(zone, min, max);
        }
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addGenericZone(zone, min, max);
        }
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addGenericZone(zone, min, max);
        }

        // -- passive widgets

        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) 
        {
            addGenericZone(zone, min, max, false);
        }
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            addGenericZone(zone, min, max, false);
        }

        // -- metadata declarations

        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val)
        {
            MetaDataUI::declare(zone, key, val);
            fMetaAux.push_back(std::make_pair(key, val));
        }
        
        // -- MIDI API
    
        void key(double date, int channel, int note, int velocity)
        {
            updateTable2<TKeyOnTable>(fKeyTable, date, channel, note, velocity);
        }
    
        MapUI* keyOn(double date, int channel, int note, int velocity)
        {
            updateTable2<TKeyOnTable>(fKeyOnTable, date, channel, note, velocity);
            // If note is in fKeyTable, handle it as a keyOn
            key(date, channel, note, velocity);
            return nullptr;
        }
        
        void keyOff(double date, int channel, int note, int velocity)
        {
            updateTable2<TKeyOffTable>(fKeyOffTable, date, channel, note, velocity);
            // If note is in fKeyTable, handle it as a keyOff with a 0 velocity
            key(date, channel, note, 0);
        }
        
        void ctrlChange(double date, int channel, int ctrl, int value)
        {
            updateTable2<TCtrlChangeTable>(fCtrlChangeTable, date, channel, ctrl, value);
        }
    
        void rpn(double date, int channel, int ctrl, int value)
        {
            if (ctrl == midi::PITCH_BEND_RANGE) {
                for (size_t i = 0; i < fPitchWheelTable.size(); i++) {
                    // channel_aux == 0 means "all channels"
                    int channel_aux = fPitchWheelTable[i]->fChan;
                    if (channel_aux == 0 || channel == channel_aux - 1) {
                        fPitchWheelTable[i]->setRange(value);
                    }
                }
            }
        }
    
        void progChange(double date, int channel, int pgm)
        {
            updateTable1<TProgChangeTable>(fProgChangeTable, date, channel, pgm);
        }
        
        void pitchWheel(double date, int channel, int wheel) 
        {
            updateTable1<TPitchWheelTable>(fPitchWheelTable, date, channel, wheel);
        }
        
        void keyPress(double date, int channel, int pitch, int press) 
        {
            updateTable2<TKeyPressTable>(fKeyPressTable, date, channel, pitch, press);
        }
        
        void chanPress(double date, int channel, int press)
        {
            updateTable1<TChanPressTable>(fChanPressTable, date, channel, press);
        }
        
        void ctrlChange14bits(double date, int channel, int ctrl, int value) {}
        
        // MIDI sync
        
        void startSync(double date)
        {
            for (size_t i = 0; i < fStartTable.size(); i++) {
                fStartTable[i]->modifyZone(date, FAUSTFLOAT(1));
            }
        }
        
        void stopSync(double date)
        {
            for (size_t i = 0; i < fStopTable.size(); i++) {
                fStopTable[i]->modifyZone(date, FAUSTFLOAT(0));
            }
        }
        
        void clock(double date)
        {
            for (size_t i = 0; i < fClockTable.size(); i++) {
                fClockTable[i]->modifyZone(date, FAUSTFLOAT(1));
            }
        }
};

#endif // FAUST_MIDIUI_H
/**************************  END  MidiUI.h **************************/

#ifdef MIDICTRL
/************************** BEGIN rt-midi.h *****************************
FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
***************************************************************************/

#ifndef __rt_midi__
#define __rt_midi__ 
 
#include <iostream>
#include <cstdlib>

/************************** BEGIN RtMidi.h **************************/
/*
 File: CAHostTimeBase.h
 Abstract: Part of CoreAudio Utility Classes
 Version: 1.0.3
 
 Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
 Inc. ("Apple") in consideration of your agreement to the following
 terms, and your use, installation, modification or redistribution of
 this Apple software constitutes acceptance of these terms.  If you do
 not agree with these terms, please do not use, install, modify or
 redistribute this Apple software.
 
 In consideration of your agreement to abide by the following terms, and
 subject to these terms, Apple grants you a personal, non-exclusive
 license, under Apple's copyrights in this original Apple software (the
 "Apple Software"), to use, reproduce, modify and redistribute the Apple
 Software, with or without modifications, in source and/or binary forms;
 provided that if you redistribute the Apple Software in its entirety and
 without modifications, you must retain this notice and the following
 text and disclaimers in all such redistributions of the Apple Software.
 Neither the name, trademarks, service marks or logos of Apple Inc. may
 be used to endorse or promote products derived from the Apple Software
 without specific prior written permission from Apple.  Except as
 expressly stated in this notice, no other rights or licenses, express or
 implied, are granted by Apple herein, including but not limited to any
 patent rights that may be infringed by your derivative works or by other
 works in which the Apple Software may be incorporated.
 
 The Apple Software is provided by Apple on an "AS IS" basis.  APPLE
 MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
 THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
 FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
 OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
 
 IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
 OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
 MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
 AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
 STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.
 
 Copyright (C) 2013 Apple Inc. All Rights Reserved.
 */

#if !defined(__CAHostTimeBase_h__)
#define __CAHostTimeBase_h__

#ifdef __APPLE__

//=============================================================================
//	Includes
//=============================================================================

#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
#include <CoreAudio/CoreAudioTypes.h>
#else
#include <CoreAudioTypes.h>
#endif

#if TARGET_OS_MAC
#include <mach/mach_time.h>
#elif TARGET_OS_WIN32
#include <windows.h>
#else
#error	Unsupported operating system
#endif

//=============================================================================
//	CAHostTimeBase
//
//	This class provides platform independent access to the host's time base.
//=============================================================================

class CAHostTimeBase
{
    
public:
    static UInt64	ConvertToNanos(UInt64 inHostTime);
    static UInt64	ConvertFromNanos(UInt64 inNanos);
    
    static UInt64	GetTheCurrentTime();
#if TARGET_OS_MAC
    static UInt64	GetCurrentTime() { return GetTheCurrentTime(); }
#endif
    static UInt64	GetCurrentTimeInNanos();
    
    static Float64	GetFrequency() { if(!sIsInited) { Initialize(); } return sFrequency; }
    static Float64	GetInverseFrequency() { if(!sIsInited) { Initialize(); } return sInverseFrequency; }
    static UInt32	GetMinimumDelta() { if(!sIsInited) { Initialize(); } return sMinDelta; }
    
    static UInt64	AbsoluteHostDeltaToNanos(UInt64 inStartTime, UInt64 inEndTime);
    static SInt64	HostDeltaToNanos(UInt64 inStartTime, UInt64 inEndTime);
    
    static void     Initialize();
    
private:
    
    static bool sIsInited;
    
    static Float64 sFrequency;
    static Float64 sInverseFrequency;
    static UInt32 sMinDelta;
    static UInt32 sToNanosNumerator;
    static UInt32 sToNanosDenominator;
    static UInt32 sFromNanosNumerator;
    static UInt32 sFromNanosDenominator;
    static bool sUseMicroseconds;
#if Track_Host_TimeBase
    static UInt64	sLastTime;
#endif
};

inline UInt64 CAHostTimeBase::GetTheCurrentTime()
{
    UInt64 theTime = 0;
    
#if TARGET_OS_MAC
    theTime = mach_absolute_time();
    
#elif TARGET_OS_WIN32
    LARGE_INTEGER theValue;
    QueryPerformanceCounter(&theValue);
    theTime = *((UInt64*)&theValue);
#endif
    
#if	Track_Host_TimeBase
    if(sLastTime != 0)
    {
        if(theTime <= sLastTime)
        {
            DebugMessageN2("CAHostTimeBase::GetTheCurrentTime: the current time is earlier than the last time, now: %qd, then: %qd", theTime, sLastTime);
        }
        sLastTime = theTime;
    }
    else
    {
        sLastTime = theTime;
    }
#endif
    
    return theTime;
}

inline UInt64 CAHostTimeBase::ConvertToNanos(UInt64 inHostTime)
{
    if(!sIsInited)
    {
        Initialize();
    }
    
    Float64 theNumerator = static_cast<Float64>(sToNanosNumerator);
    Float64 theDenominator = static_cast<Float64>(sToNanosDenominator);
    Float64 theHostTime = static_cast<Float64>(inHostTime);
    
    Float64 thePartialAnswer = theHostTime / theDenominator;
    Float64 theFloatAnswer = thePartialAnswer * theNumerator;
    UInt64 theAnswer = static_cast<UInt64>(theFloatAnswer);
    
    return theAnswer;
}

inline UInt64 CAHostTimeBase::ConvertFromNanos(UInt64 inNanos)
{
    if(!sIsInited)
    {
        Initialize();
    }
    
    Float64 theNumerator = static_cast<Float64>(sToNanosNumerator);
    Float64 theDenominator = static_cast<Float64>(sToNanosDenominator);
    Float64 theNanos = static_cast<Float64>(inNanos);
    
    Float64 thePartialAnswer = theNanos / theNumerator;
    Float64 theFloatAnswer = thePartialAnswer * theDenominator;
    UInt64 theAnswer = static_cast<UInt64>(theFloatAnswer);
    
    return theAnswer;
}

inline UInt64 CAHostTimeBase::GetCurrentTimeInNanos()
{
    return ConvertToNanos(GetTheCurrentTime());
}

inline UInt64 CAHostTimeBase::AbsoluteHostDeltaToNanos(UInt64 inStartTime, UInt64 inEndTime)
{
    UInt64 theAnswer;
    
    if(inStartTime <= inEndTime)
    {
        theAnswer = inEndTime - inStartTime;
    }
    else
    {
        theAnswer = inStartTime - inEndTime;
    }
    
    return ConvertToNanos(theAnswer);
}

inline SInt64 CAHostTimeBase::HostDeltaToNanos(UInt64 inStartTime, UInt64 inEndTime)
{
    SInt64 theAnswer;
    SInt64 theSign = 1;
    
    if(inStartTime <= inEndTime)
    {
        theAnswer = inEndTime - inStartTime;
    }
    else
    {
        theAnswer = inStartTime - inEndTime;
        theSign = -1;
    }
    
    return theSign * ConvertToNanos(theAnswer);
}

#endif // __APPLE__

#endif

/**********************************************************************/
/*! \class RtMidi
    \brief An abstract base class for realtime MIDI input/output.

    This class implements some common functionality for the realtime
    MIDI input/output subclasses RtMidiIn and RtMidiOut.

    RtMidi WWW site: http://music.mcgill.ca/~gary/rtmidi/

    RtMidi: realtime MIDI i/o C++ classes
    Copyright (c) 2003-2017 Gary P. Scavone

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    Any person wishing to distribute modifications to the Software is
    asked to send the modifications to the original developer so that
    they can be incorporated into the canonical version.  This is,
    however, not a binding provision of this license.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**********************************************************************/

/*!
  \file RtMidi.h
 */

#ifndef RTMIDI_H
#define RTMIDI_H

#define RTMIDI_VERSION "3.0.0"

#include <exception>
#include <iostream>
#include <string>
#include <vector>

#if __APPLE__
#define __MACOSX_CORE__ 1
//#define __UNIX_JACK__ 1
#endif

#if __linux__
#define __LINUX_ALSA__ 1
#endif

#if _WIN32
#define __WINDOWS_MM__ 1
#endif


/************************************************************************/
/*! \class RtMidiError
    \brief Exception handling class for RtMidi.

    The RtMidiError class is quite simple but it does allow errors to be
    "caught" by RtMidiError::Type. See the RtMidi documentation to know
    which methods can throw an RtMidiError.
*/
/************************************************************************/

class RtMidiError : public std::exception
{
 public:
  //! Defined RtMidiError types.
  enum Type {
    WARNING,           /*!< A non-critical error. */
    DEBUG_WARNING,     /*!< A non-critical error which might be useful for debugging. */
    UNSPECIFIED,       /*!< The default, unspecified error type. */
    NO_DEVICES_FOUND,  /*!< No devices found on system. */
    INVALID_DEVICE,    /*!< An invalid device ID was specified. */
    MEMORY_ERROR,      /*!< An error occured during memory allocation. */
    INVALID_PARAMETER, /*!< An invalid parameter was specified to a function. */
    INVALID_USE,       /*!< The function was called incorrectly. */
    DRIVER_ERROR,      /*!< A system driver error occured. */
    SYSTEM_ERROR,      /*!< A system error occured. */
    THREAD_ERROR       /*!< A thread error occured. */
  };

  //! The constructor.
  RtMidiError( const std::string& message, Type type = RtMidiError::UNSPECIFIED ) throw() : message_(message), type_(type) {}
 
  //! The destructor.
  virtual ~RtMidiError( void ) throw() {}

  //! Prints thrown error message to stderr.
  virtual void printMessage( void ) const throw() { std::cerr << '\n' << message_ << "\n\n"; }

  //! Returns the thrown error message type.
  virtual const Type& getType(void) const throw() { return type_; }

  //! Returns the thrown error message string.
  virtual const std::string& getMessage(void) const throw() { return message_; }

  //! Returns the thrown error message as a c-style string.
  virtual const char* what( void ) const throw() { return message_.c_str(); }

 protected:
  std::string message_;
  Type type_;
};

//! RtMidi error callback function prototype.
/*!
    \param type Type of error.
    \param errorText Error description.

    Note that class behaviour is undefined after a critical error (not
    a warning) is reported.
 */
typedef void (*RtMidiErrorCallback)( RtMidiError::Type type, const std::string &errorText, void *userData );

class MidiApi;

class RtMidi
{
 public:

  //! MIDI API specifier arguments.
  enum Api {
    UNSPECIFIED,    /*!< Search for a working compiled API. */
    MACOSX_CORE,    /*!< Macintosh OS-X Core Midi API. */
    LINUX_ALSA,     /*!< The Advanced Linux Sound Architecture API. */
    UNIX_JACK,      /*!< The JACK Low-Latency MIDI Server API. */
    WINDOWS_MM,     /*!< The Microsoft Multimedia MIDI API. */
    RTMIDI_DUMMY    /*!< A compilable but non-functional API. */
  };

  //! A static function to determine the current RtMidi version.
  static std::string getVersion( void ) throw();

  //! A static function to determine the available compiled MIDI APIs.
  /*!
    The values returned in the std::vector can be compared against
    the enumerated list values.  Note that there can be more than one
    API compiled for certain operating systems.
  */
  static void getCompiledApi( std::vector<RtMidi::Api> &apis ) throw();

  //! Pure virtual openPort() function.
  virtual void openPort( unsigned int portNumber = 0, const std::string &portName = std::string( "RtMidi" ) ) = 0;

  //! Pure virtual openVirtualPort() function.
  virtual void openVirtualPort( const std::string &portName = std::string( "RtMidi" ) ) = 0;

  //! Pure virtual getPortCount() function.
  virtual unsigned int getPortCount() = 0;

  //! Pure virtual getPortName() function.
  virtual std::string getPortName( unsigned int portNumber = 0 ) = 0;

  //! Pure virtual closePort() function.
  virtual void closePort( void ) = 0;

  //! Returns true if a port is open and false if not.
  /*!
      Note that this only applies to connections made with the openPort()
      function, not to virtual ports.
  */
  virtual bool isPortOpen( void ) const = 0;

  //! Set an error callback function to be invoked when an error has occured.
  /*!
    The callback function will be called whenever an error has occured. It is best
    to set the error callback function before opening a port.
  */
  virtual void setErrorCallback( RtMidiErrorCallback errorCallback = NULL, void *userData = 0 ) = 0;

 protected:

  RtMidi();
  virtual ~RtMidi();

  MidiApi *rtapi_;
};

/**********************************************************************/
/*! \class RtMidiIn
    \brief A realtime MIDI input class.

    This class provides a common, platform-independent API for
    realtime MIDI input.  It allows access to a single MIDI input
    port.  Incoming MIDI messages are either saved to a queue for
    retrieval using the getMessage() function or immediately passed to
    a user-specified callback function.  Create multiple instances of
    this class to connect to more than one MIDI device at the same
    time.  With the OS-X, Linux ALSA, and JACK MIDI APIs, it is also
    possible to open a virtual input port to which other MIDI software
    clients can connect.

    by Gary P. Scavone, 2003-2017.
*/
/**********************************************************************/

// **************************************************************** //
//
// RtMidiIn and RtMidiOut class declarations.
//
// RtMidiIn / RtMidiOut are "controllers" used to select an available
// MIDI input or output interface.  They present common APIs for the
// user to call but all functionality is implemented by the classes
// MidiInApi, MidiOutApi and their subclasses.  RtMidiIn and RtMidiOut
// each create an instance of a MidiInApi or MidiOutApi subclass based
// on the user's API choice.  If no choice is made, they attempt to
// make a "logical" API selection.
//
// **************************************************************** //

class RtMidiIn : public RtMidi
{
 public:

  //! User callback function type definition.
  typedef void (*RtMidiCallback)( double timeStamp, std::vector<unsigned char> *message, void *userData);

  //! Default constructor that allows an optional api, client name and queue size.
  /*!
    An exception will be thrown if a MIDI system initialization
    error occurs.  The queue size defines the maximum number of
    messages that can be held in the MIDI queue (when not using a
    callback function).  If the queue size limit is reached,
    incoming messages will be ignored.

    If no API argument is specified and multiple API support has been
    compiled, the default order of use is ALSA, JACK (Linux) and CORE,
    JACK (OS-X).

    \param api        An optional API id can be specified.
    \param clientName An optional client name can be specified. This
                      will be used to group the ports that are created
                      by the application.
    \param queueSizeLimit An optional size of the MIDI input queue can be specified.
  */
  RtMidiIn( RtMidi::Api api=UNSPECIFIED,
            const std::string& clientName = "RtMidi Input Client",
            unsigned int queueSizeLimit = 100 );

  //! If a MIDI connection is still open, it will be closed by the destructor.
  ~RtMidiIn ( void ) throw();

  //! Returns the MIDI API specifier for the current instance of RtMidiIn.
  RtMidi::Api getCurrentApi( void ) throw();

  //! Open a MIDI input connection given by enumeration number.
  /*!
    \param portNumber An optional port number greater than 0 can be specified.
                      Otherwise, the default or first port found is opened.
    \param portName An optional name for the application port that is used to connect to portId can be specified.
  */
  void openPort( unsigned int portNumber = 0, const std::string &portName = std::string( "RtMidi Input" ) );

  //! Create a virtual input port, with optional name, to allow software connections (OS X, JACK and ALSA only).
  /*!
    This function creates a virtual MIDI input port to which other
    software applications can connect.  This type of functionality
    is currently only supported by the Macintosh OS-X, any JACK,
    and Linux ALSA APIs (the function returns an error for the other APIs).

    \param portName An optional name for the application port that is
                    used to connect to portId can be specified.
  */
  void openVirtualPort( const std::string &portName = std::string( "RtMidi Input" ) );

  //! Set a callback function to be invoked for incoming MIDI messages.
  /*!
    The callback function will be called whenever an incoming MIDI
    message is received.  While not absolutely necessary, it is best
    to set the callback function before opening a MIDI port to avoid
    leaving some messages in the queue.

    \param callback A callback function must be given.
    \param userData Optionally, a pointer to additional data can be
                    passed to the callback function whenever it is called.
  */
  void setCallback( RtMidiCallback callback, void *userData = 0 );

  //! Cancel use of the current callback function (if one exists).
  /*!
    Subsequent incoming MIDI messages will be written to the queue
    and can be retrieved with the \e getMessage function.
  */
  void cancelCallback();

  //! Close an open MIDI connection (if one exists).
  void closePort( void );

  //! Returns true if a port is open and false if not.
  /*!
      Note that this only applies to connections made with the openPort()
      function, not to virtual ports.
  */
  virtual bool isPortOpen() const;

  //! Return the number of available MIDI input ports.
  /*!
    \return This function returns the number of MIDI ports of the selected API.
  */
  unsigned int getPortCount();

  //! Return a string identifier for the specified MIDI input port number.
  /*!
    \return The name of the port with the given Id is returned.
    \retval An empty string is returned if an invalid port specifier
            is provided. User code should assume a UTF-8 encoding.
  */
  std::string getPortName( unsigned int portNumber = 0 );

  //! Specify whether certain MIDI message types should be queued or ignored during input.
  /*!
    By default, MIDI timing and active sensing messages are ignored
    during message input because of their relative high data rates.
    MIDI sysex messages are ignored by default as well.  Variable
    values of "true" imply that the respective message type will be
    ignored.
  */
  void ignoreTypes( bool midiSysex = true, bool midiTime = true, bool midiSense = true );

  //! Fill the user-provided vector with the data bytes for the next available MIDI message in the input queue and return the event delta-time in seconds.
  /*!
    This function returns immediately whether a new message is
    available or not.  A valid message is indicated by a non-zero
    vector size.  An exception is thrown if an error occurs during
    message retrieval or an input connection was not previously
    established.
  */
  double getMessage( std::vector<unsigned char> *message );

  //! Set an error callback function to be invoked when an error has occured.
  /*!
    The callback function will be called whenever an error has occured. It is best
    to set the error callback function before opening a port.
  */
  virtual void setErrorCallback( RtMidiErrorCallback errorCallback = NULL, void *userData = 0 );

 protected:
  void openMidiApi( RtMidi::Api api, const std::string &clientName, unsigned int queueSizeLimit );

};

/**********************************************************************/
/*! \class RtMidiOut
    \brief A realtime MIDI output class.

    This class provides a common, platform-independent API for MIDI
    output.  It allows one to probe available MIDI output ports, to
    connect to one such port, and to send MIDI bytes immediately over
    the connection.  Create multiple instances of this class to
    connect to more than one MIDI device at the same time.  With the
    OS-X, Linux ALSA and JACK MIDI APIs, it is also possible to open a
    virtual port to which other MIDI software clients can connect.

    by Gary P. Scavone, 2003-2017.
*/
/**********************************************************************/

class RtMidiOut : public RtMidi
{
 public:

  //! Default constructor that allows an optional client name.
  /*!
    An exception will be thrown if a MIDI system initialization error occurs.

    If no API argument is specified and multiple API support has been
    compiled, the default order of use is ALSA, JACK (Linux) and CORE,
    JACK (OS-X).
  */
  RtMidiOut( RtMidi::Api api=UNSPECIFIED,
             const std::string& clientName = "RtMidi Output Client" );

  //! The destructor closes any open MIDI connections.
  ~RtMidiOut( void ) throw();

  //! Returns the MIDI API specifier for the current instance of RtMidiOut.
  RtMidi::Api getCurrentApi( void ) throw();

  //! Open a MIDI output connection.
  /*!
      An optional port number greater than 0 can be specified.
      Otherwise, the default or first port found is opened.  An
      exception is thrown if an error occurs while attempting to make
      the port connection.
  */
  void openPort( unsigned int portNumber = 0, const std::string &portName = std::string( "RtMidi Output" ) );

  //! Close an open MIDI connection (if one exists).
  void closePort( void );

  //! Returns true if a port is open and false if not.
  /*!
      Note that this only applies to connections made with the openPort()
      function, not to virtual ports.
  */
  virtual bool isPortOpen() const;

  //! Create a virtual output port, with optional name, to allow software connections (OS X, JACK and ALSA only).
  /*!
      This function creates a virtual MIDI output port to which other
      software applications can connect.  This type of functionality
      is currently only supported by the Macintosh OS-X, Linux ALSA
      and JACK APIs (the function does nothing with the other APIs).
      An exception is thrown if an error occurs while attempting to
      create the virtual port.
  */
  void openVirtualPort( const std::string &portName = std::string( "RtMidi Output" ) );

  //! Return the number of available MIDI output ports.
  unsigned int getPortCount( void );

  //! Return a string identifier for the specified MIDI port type and number.
  /*!
    \return The name of the port with the given Id is returned.
    \retval An empty string is returned if an invalid port specifier
            is provided. User code should assume a UTF-8 encoding.
  */
  std::string getPortName( unsigned int portNumber = 0 );

  //! Immediately send a single message out an open MIDI output port.
  /*!
      An exception is thrown if an error occurs during output or an
      output connection was not previously established.
  */
  void sendMessage( const std::vector<unsigned char> *message );

  //! Immediately send a single message out an open MIDI output port.
  /*!
      An exception is thrown if an error occurs during output or an
      output connection was not previously established.

      \param message A pointer to the MIDI message as raw bytes
      \param size    Length of the MIDI message in bytes
  */
  void sendMessage( const unsigned char *message, size_t size );

  //! Set an error callback function to be invoked when an error has occured.
  /*!
    The callback function will be called whenever an error has occured. It is best
    to set the error callback function before opening a port.
  */
  virtual void setErrorCallback( RtMidiErrorCallback errorCallback = NULL, void *userData = 0 );

 protected:
  void openMidiApi( RtMidi::Api api, const std::string &clientName );
};


// **************************************************************** //
//
// MidiInApi / MidiOutApi class declarations.
//
// Subclasses of MidiInApi and MidiOutApi contain all API- and
// OS-specific code necessary to fully implement the RtMidi API.
//
// Note that MidiInApi and MidiOutApi are abstract base classes and
// cannot be explicitly instantiated.  RtMidiIn and RtMidiOut will
// create instances of a MidiInApi or MidiOutApi subclass.
//
// **************************************************************** //

class MidiApi
{
 public:

  MidiApi();
  virtual ~MidiApi();
  virtual RtMidi::Api getCurrentApi( void ) = 0;
  virtual void openPort( unsigned int portNumber, const std::string &portName ) = 0;
  virtual void openVirtualPort( const std::string &portName ) = 0;
  virtual void closePort( void ) = 0;

  virtual unsigned int getPortCount( void ) = 0;
  virtual std::string getPortName( unsigned int portNumber ) = 0;

  inline bool isPortOpen() const { return connected_; }
  void setErrorCallback( RtMidiErrorCallback errorCallback, void *userData );

  //! A basic error reporting function for RtMidi classes.
  void error( RtMidiError::Type type, std::string errorString );

protected:
  virtual void initialize( const std::string& clientName ) = 0;

  void *apiData_;
  bool connected_;
  std::string errorString_;
  RtMidiErrorCallback errorCallback_;
  bool firstErrorOccurred_;
  void *errorCallbackUserData_;
};

class MidiInApi : public MidiApi
{
 public:

  MidiInApi( unsigned int queueSizeLimit );
  virtual ~MidiInApi( void );
  void setCallback( RtMidiIn::RtMidiCallback callback, void *userData );
  void cancelCallback( void );
  virtual void ignoreTypes( bool midiSysex, bool midiTime, bool midiSense );
  double getMessage( std::vector<unsigned char> *message );

  // A MIDI structure used internally by the class to store incoming
  // messages.  Each message represents one and only one MIDI message.
  struct MidiMessage { 
    std::vector<unsigned char> bytes; 

    //! Time in seconds elapsed since the previous message
    double timeStamp;

    // Default constructor.
  MidiMessage()
  :bytes(0), timeStamp(0.0) {}
  };

  struct MidiQueue {
    unsigned int front;
    unsigned int back;
    unsigned int ringSize;
    MidiMessage *ring;

    // Default constructor.
  MidiQueue()
  :front(0), back(0), ringSize(0), ring(0) {}
    bool push(const MidiMessage&);
    bool pop(std::vector<unsigned char>*, double*);
    unsigned int size(unsigned int *back=0,
		      unsigned int *front=0);
  };

  // The RtMidiInData structure is used to pass private class data to
  // the MIDI input handling function or thread.
  struct RtMidiInData {
    MidiQueue queue;
    MidiMessage message;
    unsigned char ignoreFlags;
    bool doInput;
    bool firstMessage;
    void *apiData;
    bool usingCallback;
    RtMidiIn::RtMidiCallback userCallback;
    void *userData;
    bool continueSysex;

    // Default constructor.
  RtMidiInData()
  : ignoreFlags(7), doInput(false), firstMessage(true),
      apiData(0), usingCallback(false), userCallback(0), userData(0),
      continueSysex(false) {}
  };

 protected:
  RtMidiInData inputData_;
};

class MidiOutApi : public MidiApi
{
 public:

  MidiOutApi( void );
  virtual ~MidiOutApi( void );
  virtual void sendMessage( const unsigned char *message, size_t size ) = 0;
};

// **************************************************************** //
//
// Inline RtMidiIn and RtMidiOut definitions.
//
// **************************************************************** //

inline RtMidi::Api RtMidiIn :: getCurrentApi( void ) throw() { return rtapi_->getCurrentApi(); }
inline void RtMidiIn :: openPort( unsigned int portNumber, const std::string &portName ) { rtapi_->openPort( portNumber, portName ); }
inline void RtMidiIn :: openVirtualPort( const std::string &portName ) { rtapi_->openVirtualPort( portName ); }
inline void RtMidiIn :: closePort( void ) { rtapi_->closePort(); }
inline bool RtMidiIn :: isPortOpen() const { return rtapi_->isPortOpen(); }
inline void RtMidiIn :: setCallback( RtMidiCallback callback, void *userData ) { ((MidiInApi *)rtapi_)->setCallback( callback, userData ); }
inline void RtMidiIn :: cancelCallback( void ) { ((MidiInApi *)rtapi_)->cancelCallback(); }
inline unsigned int RtMidiIn :: getPortCount( void ) { return rtapi_->getPortCount(); }
inline std::string RtMidiIn :: getPortName( unsigned int portNumber ) { return rtapi_->getPortName( portNumber ); }
inline void RtMidiIn :: ignoreTypes( bool midiSysex, bool midiTime, bool midiSense ) { ((MidiInApi *)rtapi_)->ignoreTypes( midiSysex, midiTime, midiSense ); }
inline double RtMidiIn :: getMessage( std::vector<unsigned char> *message ) { return ((MidiInApi *)rtapi_)->getMessage( message ); }
inline void RtMidiIn :: setErrorCallback( RtMidiErrorCallback errorCallback, void *userData ) { rtapi_->setErrorCallback(errorCallback, userData); }

inline RtMidi::Api RtMidiOut :: getCurrentApi( void ) throw() { return rtapi_->getCurrentApi(); }
inline void RtMidiOut :: openPort( unsigned int portNumber, const std::string &portName ) { rtapi_->openPort( portNumber, portName ); }
inline void RtMidiOut :: openVirtualPort( const std::string &portName ) { rtapi_->openVirtualPort( portName ); }
inline void RtMidiOut :: closePort( void ) { rtapi_->closePort(); }
inline bool RtMidiOut :: isPortOpen() const { return rtapi_->isPortOpen(); }
inline unsigned int RtMidiOut :: getPortCount( void ) { return rtapi_->getPortCount(); }
inline std::string RtMidiOut :: getPortName( unsigned int portNumber ) { return rtapi_->getPortName( portNumber ); }
inline void RtMidiOut :: sendMessage( const std::vector<unsigned char> *message ) { ((MidiOutApi *)rtapi_)->sendMessage( &message->at(0), message->size() ); }
inline void RtMidiOut :: sendMessage( const unsigned char *message, size_t size ) { ((MidiOutApi *)rtapi_)->sendMessage( message, size ); }
inline void RtMidiOut :: setErrorCallback( RtMidiErrorCallback errorCallback, void *userData ) { rtapi_->setErrorCallback(errorCallback, userData); }

// **************************************************************** //
//
// MidiInApi and MidiOutApi subclass prototypes.
//
// **************************************************************** //

#if !defined(__LINUX_ALSA__) && !defined(__UNIX_JACK__) && !defined(__MACOSX_CORE__) && !defined(__WINDOWS_MM__)
  #define __RTMIDI_DUMMY__
#endif

#if defined(__MACOSX_CORE__)

class MidiInCore: public MidiInApi
{
 public:
  MidiInCore( const std::string &clientName, unsigned int queueSizeLimit );
  ~MidiInCore( void );
  RtMidi::Api getCurrentApi( void ) { return RtMidi::MACOSX_CORE; };
  void openPort( unsigned int portNumber, const std::string &portName );
  void openVirtualPort( const std::string &portName );
  void closePort( void );
  unsigned int getPortCount( void );
  std::string getPortName( unsigned int portNumber );

 protected:
  void initialize( const std::string& clientName );
};

class MidiOutCore: public MidiOutApi
{
 public:
  MidiOutCore( const std::string &clientName );
  ~MidiOutCore( void );
  RtMidi::Api getCurrentApi( void ) { return RtMidi::MACOSX_CORE; };
  void openPort( unsigned int portNumber, const std::string &portName );
  void openVirtualPort( const std::string &portName );
  void closePort( void );
  unsigned int getPortCount( void );
  std::string getPortName( unsigned int portNumber );
  void sendMessage( const unsigned char *message, size_t size );

 protected:
  void initialize( const std::string& clientName );
};

#endif

#if defined(__UNIX_JACK__)

class MidiInJack: public MidiInApi
{
 public:
  MidiInJack( const std::string &clientName, unsigned int queueSizeLimit );
  ~MidiInJack( void );
  RtMidi::Api getCurrentApi( void ) { return RtMidi::UNIX_JACK; };
  void openPort( unsigned int portNumber, const std::string &portName );
  void openVirtualPort( const std::string &portName );
  void closePort( void );
  unsigned int getPortCount( void );
  std::string getPortName( unsigned int portNumber );

 protected:
  std::string clientName;

  void connect( void );
  void initialize( const std::string& clientName );
};

class MidiOutJack: public MidiOutApi
{
 public:
  MidiOutJack( const std::string &clientName );
  ~MidiOutJack( void );
  RtMidi::Api getCurrentApi( void ) { return RtMidi::UNIX_JACK; };
  void openPort( unsigned int portNumber, const std::string &portName );
  void openVirtualPort( const std::string &portName );
  void closePort( void );
  unsigned int getPortCount( void );
  std::string getPortName( unsigned int portNumber );
  void sendMessage( const unsigned char *message, size_t size );

 protected:
  std::string clientName;

  void connect( void );
  void initialize( const std::string& clientName );
};

#endif

#if defined(__LINUX_ALSA__)

class MidiInAlsa: public MidiInApi
{
 public:
  MidiInAlsa( const std::string &clientName, unsigned int queueSizeLimit );
  ~MidiInAlsa( void );
  RtMidi::Api getCurrentApi( void ) { return RtMidi::LINUX_ALSA; };
  void openPort( unsigned int portNumber, const std::string &portName );
  void openVirtualPort( const std::string &portName );
  void closePort( void );
  unsigned int getPortCount( void );
  std::string getPortName( unsigned int portNumber );

 protected:
  void initialize( const std::string& clientName );
};

class MidiOutAlsa: public MidiOutApi
{
 public:
  MidiOutAlsa( const std::string &clientName );
  ~MidiOutAlsa( void );
  RtMidi::Api getCurrentApi( void ) { return RtMidi::LINUX_ALSA; };
  void openPort( unsigned int portNumber, const std::string &portName );
  void openVirtualPort( const std::string &portName );
  void closePort( void );
  unsigned int getPortCount( void );
  std::string getPortName( unsigned int portNumber );
  void sendMessage( const unsigned char *message, size_t size );

 protected:
  void initialize( const std::string& clientName );
};

#endif

#if defined(__WINDOWS_MM__)

class MidiInWinMM: public MidiInApi
{
 public:
  MidiInWinMM( const std::string &clientName, unsigned int queueSizeLimit );
  ~MidiInWinMM( void );
  RtMidi::Api getCurrentApi( void ) { return RtMidi::WINDOWS_MM; };
  void openPort( unsigned int portNumber, const std::string &portName );
  void openVirtualPort( const std::string &portName );
  void closePort( void );
  unsigned int getPortCount( void );
  std::string getPortName( unsigned int portNumber );

 protected:
  void initialize( const std::string& clientName );
};

class MidiOutWinMM: public MidiOutApi
{
 public:
  MidiOutWinMM( const std::string &clientName );
  ~MidiOutWinMM( void );
  RtMidi::Api getCurrentApi( void ) { return RtMidi::WINDOWS_MM; };
  void openPort( unsigned int portNumber, const std::string &portName );
  void openVirtualPort( const std::string &portName );
  void closePort( void );
  unsigned int getPortCount( void );
  std::string getPortName( unsigned int portNumber );
  void sendMessage( const unsigned char *message, size_t size );

 protected:
  void initialize( const std::string& clientName );
};

#endif

#if defined(__RTMIDI_DUMMY__)

class MidiInDummy: public MidiInApi
{
 public:
 MidiInDummy( const std::string &/*clientName*/, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit ) { errorString_ = "MidiInDummy: This class provides no functionality."; error( RtMidiError::WARNING, errorString_ ); }
  RtMidi::Api getCurrentApi( void ) { return RtMidi::RTMIDI_DUMMY; }
  void openPort( unsigned int /*portNumber*/, const std::string &/*portName*/ ) {}
  void openVirtualPort( const std::string &/*portName*/ ) {}
  void closePort( void ) {}
  unsigned int getPortCount( void ) { return 0; }
  std::string getPortName( unsigned int /*portNumber*/ ) { return ""; }

 protected:
  void initialize( const std::string& /*clientName*/ ) {}
};

class MidiOutDummy: public MidiOutApi
{
 public:
  MidiOutDummy( const std::string &/*clientName*/ ) { errorString_ = "MidiOutDummy: This class provides no functionality."; error( RtMidiError::WARNING, errorString_ ); }
  RtMidi::Api getCurrentApi( void ) { return RtMidi::RTMIDI_DUMMY; }
  void openPort( unsigned int /*portNumber*/, const std::string &/*portName*/ ) {}
  void openVirtualPort( const std::string &/*portName*/ ) {}
  void closePort( void ) {}
  unsigned int getPortCount( void ) { return 0; }
  std::string getPortName( unsigned int /*portNumber*/ ) { return ""; }
  void sendMessage( const unsigned char * /*message*/, size_t /*size*/ ) {}

 protected:
  void initialize( const std::string& /*clientName*/ ) {}
};

#endif

#endif
/**************************  END  RtMidi.h **************************/

class MapUI;

/**
 *  MIDI input/output handling using RtMidi library: http://www.music.mcgill.ca/~gary/rtmidi/
 */
class rt_midi : public midi_handler {

    private:
    
        std::vector<RtMidiIn*> fInput;
        std::vector<RtMidiOut*> fOutput;
        bool fIsVirtual;
        bool fPolling;
    
        static void midiCallback(double time, std::vector<unsigned char>* message, void* arg)
        {
            rt_midi* midi = static_cast<rt_midi*>(arg);
            size_t nBytes = message->size();
            int type = (int)message->at(0) & 0xf0;
            int channel = (int)message->at(0) & 0x0f;
            
            // MIDI sync
            if (nBytes == 1) {
                midi->handleSync(time, (int)message->at(0));
            // One data byte messages
            } else if (nBytes == 2) {
                midi->handleData1(time, type, channel, (int)message->at(1));
            // Two data bytes messages
            } else if (nBytes == 3) {
                midi->handleData2(time, type, channel, (int)message->at(1), (int)message->at(2));
            } else {
                midi->handleMessage(time, (int)message->at(0), *message);
            }
        }
        
        bool openMidiInputPorts()
        {
            // Get number of input ports
            RtMidiIn midi_in;
            unsigned nInPorts = midi_in.getPortCount();
            if (nInPorts == 0) {
                std::cout << "No input ports available!" << std::endl;
                return false;
            }
    
            // Then open all of them
            for (unsigned int i = 0; i < nInPorts; i++) {
                RtMidiIn* midi_in = new RtMidiIn();
                midi_in->ignoreTypes(true, false, true);
                fInput.push_back(midi_in);
                midi_in->openPort(i);
                if (!fPolling) {
                    midi_in->setCallback(&midiCallback, this);
                }
                //std::cout << "Input port #" << i << ": " << midi_in->getPortName(i) << '\n';
            }
            return true;
        }
        
        bool openMidiOutputPorts()
        {
            // Get number of output ports
            RtMidiOut midi_out;
            unsigned nOutPorts = midi_out.getPortCount();
            if (nOutPorts == 0) {
                std::cout << "No output ports available!" << std::endl;
                return false;
            }
    
            // Then open all of them
            for (unsigned int i = 0; i < nOutPorts; i++) {
                RtMidiOut* midi_out = new RtMidiOut();
                fOutput.push_back(midi_out);
                midi_out->openPort(i);
                //std::cout << "Output port #" << i << ": " << midi_out->getPortName(i) << '\n';
            }
            return true;
        }
        
        void chooseMidiInputPort(const std::string& name)
        {
            RtMidiIn* midi_in = new RtMidiIn();
            midi_in->ignoreTypes(true, false, true);
            fInput.push_back(midi_in);
            if (!fPolling) {
                midi_in->setCallback(&midiCallback, this);
            }
            midi_in->openVirtualPort(name);
        }
        
        void chooseMidiOutPort(const std::string& name)
        {
            RtMidiOut* midi_out = new RtMidiOut();
            fOutput.push_back(midi_out);
            midi_out->openVirtualPort(name);
        }
        
        void sendMessage(std::vector<unsigned char>& message)
        {
            for (const auto& it : fOutput) {
                it->sendMessage(&message);
            }
        }
    
    public:
    
        rt_midi(const std::string& name = "RtMidi",
                bool is_virtual = false,
                bool is_polling = false)
        :midi_handler(name), fIsVirtual(is_virtual), fPolling(is_polling)
        {}
        
        virtual ~rt_midi()
        {
            stopMidi();
        }
        
        bool startMidi()
        {
            try {
            
            #if TARGET_OS_IPHONE
                if (!openMidiInputPorts())  { stopMidi(); return false; }
                if (!openMidiOutputPorts()) { stopMidi(); return false; }
            #else
                if (fIsVirtual) {
                    chooseMidiInputPort(fName);
                    chooseMidiOutPort(fName);
                } else {
                    if (!openMidiInputPorts())  { stopMidi(); return false; }
                    if (!openMidiOutputPorts()) { stopMidi(); return false; }
                }
            #endif
                return true;
                
            } catch (RtMidiError &error) {
                error.printMessage();
                stopMidi();
                return false;
            }
        }
        
        void stopMidi()
        {
            for (const auto& it1 : fInput) {
                delete it1;
            }
            fInput.clear();
            for (const auto& it2 : fOutput) {
                delete it2;
            }
            fOutput.clear();
        }
    
        // To be used in polling mode
        int recvMessages(std::vector<MIDIMessage>* messages)
        {
            int count = 0;
            double first_time_stamp = 0.;
            for (const auto& it : fInput) {
                std::vector<unsigned char> message;
                double time_stamp = (uint32_t)it->getMessage(&message);
                // Small messages
                if (message.size() > 0) {
                    if (count == 0) first_time_stamp = time_stamp;
                    MIDIMessage& mes = messages->at(count++);
                    mes.frameIndex = (uint32_t)(time_stamp - first_time_stamp);
                    mes.byte0 = message[0];
                    mes.byte1 = message[1];
                    mes.byte2 = message[2];
                }
            }
            return count;
        }
    
        void sendMessages(std::vector<MIDIMessage>* messages, int count)
        {
            for (int i = 0; i < count; ++i) {
                MIDIMessage mes1 = (*messages)[i];
                std::vector<unsigned char> mes2;
                mes2.push_back(mes1.byte0);
                mes2.push_back(mes1.byte1);
                mes2.push_back(mes1.byte2);
                sendMessage(mes2);
            }
        }
    
        // MIDI output API
        MapUI* keyOn(int channel, int pitch, int velocity)
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_NOTE_ON + channel);
            message.push_back(pitch);
            message.push_back(velocity);
            sendMessage(message);
            return nullptr;
        }
        
        void keyOff(int channel, int pitch, int velocity) 
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_NOTE_OFF + channel);
            message.push_back(pitch);
            message.push_back(velocity);
            sendMessage(message);
        }
        
        void ctrlChange(int channel, int ctrl, int val) 
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_CONTROL_CHANGE + channel);
            message.push_back(ctrl);
            message.push_back(val);
            sendMessage(message);
        }
        
        void chanPress(int channel, int press) 
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_AFTERTOUCH + channel);
            message.push_back(press);
            sendMessage(message);
        }
        
        void progChange(int channel, int pgm) 
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_PROGRAM_CHANGE + channel);
            message.push_back(pgm);
            sendMessage(message);
        }
          
        void keyPress(int channel, int pitch, int press) 
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_POLY_AFTERTOUCH + channel);
            message.push_back(pitch);
            message.push_back(press);
            sendMessage(message);
        }
   
        void pitchWheel(int channel, int wheel) 
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_PITCH_BEND + channel);
            message.push_back(wheel & 0x7F);		// lsb 7bit
            message.push_back((wheel >> 7) & 0x7F);	// msb 7bit
            sendMessage(message);
        }
        
        void ctrlChange14bits(int channel, int ctrl, int value) {}
         
        void startSync(double date)
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_START);
            sendMessage(message);
        }
       
        void stopSync(double date)
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_STOP);
            sendMessage(message);
        }
        
        void clock(double date) 
        {
            std::vector<unsigned char> message;
            message.push_back(MIDI_CLOCK);
            sendMessage(message);
        }
    
        void sysEx(double, std::vector<unsigned char>& message)
        {
            sendMessage(message);
        }
    
};

#endif // __rt_midi__
/**************************  END  rt-midi.h **************************/
/**********************************************************************/
/*! \class RtMidi
    \brief An abstract base class for realtime MIDI input/output.

    This class implements some common functionality for the realtime
    MIDI input/output subclasses RtMidiIn and RtMidiOut.

    RtMidi WWW site: http://music.mcgill.ca/~gary/rtmidi/

    RtMidi: realtime MIDI i/o C++ classes
    Copyright (c) 2003-2017 Gary P. Scavone

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    Any person wishing to distribute modifications to the Software is
    asked to send the modifications to the original developer so that
    they can be incorporated into the canonical version.  This is,
    however, not a binding provision of this license.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**********************************************************************/

#include <sstream>

#ifdef __APPLE__

Float64 CAHostTimeBase::sFrequency = 0;
Float64 CAHostTimeBase::sInverseFrequency = 0;
UInt32 CAHostTimeBase::sMinDelta = 0;
UInt32 CAHostTimeBase::sToNanosNumerator = 0;
UInt32 CAHostTimeBase::sToNanosDenominator = 0;
UInt32 CAHostTimeBase::sFromNanosNumerator = 0;
UInt32 CAHostTimeBase::sFromNanosDenominator = 0;
bool CAHostTimeBase::sUseMicroseconds = false;
bool CAHostTimeBase::sIsInited = false;
#if Track_Host_TimeBase
UInt64 CAHostTimeBase::sLastTime = 0;
#endif

//=============================================================================
//	CAHostTimeBase
//
//	This class provides platform independent access to the host's time base.
//=============================================================================

void CAHostTimeBase::Initialize()
{
    if (!sIsInited) {
        
        //	get the info about Absolute time
#if TARGET_OS_MAC
        struct mach_timebase_info	theTimeBaseInfo;
        mach_timebase_info(&theTimeBaseInfo);
        sMinDelta = 1;
        sToNanosNumerator = theTimeBaseInfo.numer;
        sToNanosDenominator = theTimeBaseInfo.denom;
        sFromNanosNumerator = sToNanosDenominator;
        sFromNanosDenominator = sToNanosNumerator;
        
        //	the frequency of that clock is: (sToNanosDenominator / sToNanosNumerator) * 10^9
        sFrequency = static_cast<Float64>(sToNanosDenominator) / static_cast<Float64>(sToNanosNumerator);
        sFrequency *= 1000000000.0;
#elif TARGET_OS_WIN32
        LARGE_INTEGER theFrequency;
        QueryPerformanceFrequency(&theFrequency);
        sMinDelta = 1;
        sToNanosNumerator = 1000000000ULL;
        sToNanosDenominator = *((UInt64*)&theFrequency);
        sFromNanosNumerator = sToNanosDenominator;
        sFromNanosDenominator = sToNanosNumerator;
        sFrequency = static_cast<Float64>(*((UInt64*)&theFrequency));
#endif
        sInverseFrequency = 1.0 / sFrequency;
        
#if	Log_Host_Time_Base_Parameters
        DebugMessage(  "Host Time Base Parameters");
        DebugMessageN1(" Minimum Delta:          %lu", sMinDelta);
        DebugMessageN1(" Frequency:              %f", sFrequency);
        DebugMessageN1(" To Nanos Numerator:     %lu", sToNanosNumerator);
        DebugMessageN1(" To Nanos Denominator:   %lu", sToNanosDenominator);
        DebugMessageN1(" From Nanos Numerator:   %lu", sFromNanosNumerator);
        DebugMessageN1(" From Nanos Denominator: %lu", sFromNanosDenominator);
#endif
        
        sIsInited = true;
    }
}

#endif

#if defined(__MACOSX_CORE__)
  #if TARGET_OS_IPHONE
    #define AudioGetCurrentHostTime CAHostTimeBase::GetCurrentTime
    #define AudioConvertHostTimeToNanos CAHostTimeBase::ConvertToNanos
  #endif
#endif

// Default for Windows is to add an identifier to the port names; this
// flag can be undefined to disable this behaviour.
#define RTMIDI_ENSURE_UNIQUE_PORTNAMES

//*********************************************************************//
//  RtMidi Definitions
//*********************************************************************//

RtMidi :: RtMidi()
  : rtapi_(0)
{
#if defined(__MACOSX_CORE__)
    #if TARGET_OS_IPHONE
        CAHostTimeBase::Initialize();
    #endif
#endif
}

RtMidi :: ~RtMidi()
{
  delete rtapi_;
  rtapi_ = 0;
}

std::string RtMidi :: getVersion( void ) throw()
{
  return std::string( RTMIDI_VERSION );
}

void RtMidi :: getCompiledApi( std::vector<RtMidi::Api> &apis ) throw()
{
  apis.clear();

  // The order here will control the order of RtMidi's API search in
  // the constructor.
#if defined(__MACOSX_CORE__)
  apis.push_back( MACOSX_CORE );
#endif
#if defined(__LINUX_ALSA__)
  apis.push_back( LINUX_ALSA );
#endif
#if defined(__UNIX_JACK__)
  apis.push_back( UNIX_JACK );
#endif
#if defined(__WINDOWS_MM__)
  apis.push_back( WINDOWS_MM );
#endif
#if defined(__RTMIDI_DUMMY__)
  apis.push_back( RTMIDI_DUMMY );
#endif
}

//*********************************************************************//
//  RtMidiIn Definitions
//*********************************************************************//

void RtMidiIn :: openMidiApi( RtMidi::Api api, const std::string &clientName, unsigned int queueSizeLimit )
{
  delete rtapi_;
  rtapi_ = 0;

#if defined(__UNIX_JACK__)
  if ( api == UNIX_JACK )
    rtapi_ = new MidiInJack( clientName, queueSizeLimit );
#endif
#if defined(__LINUX_ALSA__)
  if ( api == LINUX_ALSA )
    rtapi_ = new MidiInAlsa( clientName, queueSizeLimit );
#endif
#if defined(__WINDOWS_MM__)
  if ( api == WINDOWS_MM )
    rtapi_ = new MidiInWinMM( clientName, queueSizeLimit );
#endif
#if defined(__MACOSX_CORE__)
  if ( api == MACOSX_CORE )
    rtapi_ = new MidiInCore( clientName, queueSizeLimit );
#endif
#if defined(__RTMIDI_DUMMY__)
  if ( api == RTMIDI_DUMMY )
    rtapi_ = new MidiInDummy( clientName, queueSizeLimit );
#endif
}

RtMidiIn :: RtMidiIn( RtMidi::Api api, const std::string &clientName, unsigned int queueSizeLimit )
  : RtMidi()
{
  if ( api != UNSPECIFIED ) {
    // Attempt to open the specified API.
    openMidiApi( api, clientName, queueSizeLimit );
    if ( rtapi_ ) return;

    // No compiled support for specified API value.  Issue a warning
    // and continue as if no API was specified.
    std::cerr << "\nRtMidiIn: no compiled support for specified API argument!\n\n" << std::endl;
  }

  // Iterate through the compiled APIs and return as soon as we find
  // one with at least one port or we reach the end of the list.
  std::vector< RtMidi::Api > apis;
  getCompiledApi( apis );
  for ( unsigned int i=0; i<apis.size(); i++ ) {
    openMidiApi( apis[i], clientName, queueSizeLimit );
    if ( rtapi_ && rtapi_->getPortCount() ) break;
  }

  if ( rtapi_ ) return;

  // It should not be possible to get here because the preprocessor
  // definition __RTMIDI_DUMMY__ is automatically defined if no
  // API-specific definitions are passed to the compiler. But just in
  // case something weird happens, we'll throw an error.
  std::string errorText = "RtMidiIn: no compiled API support found ... critical error!!";
  throw( RtMidiError( errorText, RtMidiError::UNSPECIFIED ) );
}

RtMidiIn :: ~RtMidiIn() throw()
{
}


//*********************************************************************//
//  RtMidiOut Definitions
//*********************************************************************//

void RtMidiOut :: openMidiApi( RtMidi::Api api, const std::string &clientName )
{
  delete rtapi_;
  rtapi_ = 0;

#if defined(__UNIX_JACK__)
  if ( api == UNIX_JACK )
    rtapi_ = new MidiOutJack( clientName );
#endif
#if defined(__LINUX_ALSA__)
  if ( api == LINUX_ALSA )
    rtapi_ = new MidiOutAlsa( clientName );
#endif
#if defined(__WINDOWS_MM__)
  if ( api == WINDOWS_MM )
    rtapi_ = new MidiOutWinMM( clientName );
#endif
#if defined(__MACOSX_CORE__)
  if ( api == MACOSX_CORE )
    rtapi_ = new MidiOutCore( clientName );
#endif
#if defined(__RTMIDI_DUMMY__)
  if ( api == RTMIDI_DUMMY )
    rtapi_ = new MidiOutDummy( clientName );
#endif
}

RtMidiOut :: RtMidiOut( RtMidi::Api api, const std::string &clientName)
{
  if ( api != UNSPECIFIED ) {
    // Attempt to open the specified API.
    openMidiApi( api, clientName );
    if ( rtapi_ ) return;

    // No compiled support for specified API value.  Issue a warning
    // and continue as if no API was specified.
    std::cerr << "\nRtMidiOut: no compiled support for specified API argument!\n\n" << std::endl;
  }

  // Iterate through the compiled APIs and return as soon as we find
  // one with at least one port or we reach the end of the list.
  std::vector< RtMidi::Api > apis;
  getCompiledApi( apis );
  for ( unsigned int i=0; i<apis.size(); i++ ) {
    openMidiApi( apis[i], clientName );
    if ( rtapi_ && rtapi_->getPortCount() ) break;
  }

  if ( rtapi_ ) return;

  // It should not be possible to get here because the preprocessor
  // definition __RTMIDI_DUMMY__ is automatically defined if no
  // API-specific definitions are passed to the compiler. But just in
  // case something weird happens, we'll thrown an error.
  std::string errorText = "RtMidiOut: no compiled API support found ... critical error!!";
  throw( RtMidiError( errorText, RtMidiError::UNSPECIFIED ) );
}

RtMidiOut :: ~RtMidiOut() throw()
{
}

//*********************************************************************//
//  Common MidiApi Definitions
//*********************************************************************//

MidiApi :: MidiApi( void )
  : apiData_( 0 ), connected_( false ), errorCallback_(0), firstErrorOccurred_(false), errorCallbackUserData_(0)
{
}

MidiApi :: ~MidiApi( void )
{
}

void MidiApi :: setErrorCallback( RtMidiErrorCallback errorCallback, void *userData = 0 )
{
    errorCallback_ = errorCallback;
    errorCallbackUserData_ = userData;
}

void MidiApi :: error( RtMidiError::Type type, std::string errorString )
{
  if ( errorCallback_ ) {

    if ( firstErrorOccurred_ )
      return;

    firstErrorOccurred_ = true;
    const std::string errorMessage = errorString;

    errorCallback_( type, errorMessage, errorCallbackUserData_);
    firstErrorOccurred_ = false;
    return;
  }

  if ( type == RtMidiError::WARNING ) {
    std::cerr << '\n' << errorString << "\n\n";
  }
  else if ( type == RtMidiError::DEBUG_WARNING ) {
#if defined(__RTMIDI_DEBUG__)
    std::cerr << '\n' << errorString << "\n\n";
#endif
  }
  else {
    std::cerr << '\n' << errorString << "\n\n";
    throw RtMidiError( errorString, type );
  }
}

//*********************************************************************//
//  Common MidiInApi Definitions
//*********************************************************************//

MidiInApi :: MidiInApi( unsigned int queueSizeLimit )
  : MidiApi()
{
  // Allocate the MIDI queue.
  inputData_.queue.ringSize = queueSizeLimit;
  if ( inputData_.queue.ringSize > 0 )
    inputData_.queue.ring = new MidiMessage[ inputData_.queue.ringSize ];
}

MidiInApi :: ~MidiInApi( void )
{
  // Delete the MIDI queue.
  if ( inputData_.queue.ringSize > 0 ) delete [] inputData_.queue.ring;
}

void MidiInApi :: setCallback( RtMidiIn::RtMidiCallback callback, void *userData )
{
  if ( inputData_.usingCallback ) {
    errorString_ = "MidiInApi::setCallback: a callback function is already set!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  if ( !callback ) {
    errorString_ = "RtMidiIn::setCallback: callback function value is invalid!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  inputData_.userCallback = callback;
  inputData_.userData = userData;
  inputData_.usingCallback = true;
}

void MidiInApi :: cancelCallback()
{
  if ( !inputData_.usingCallback ) {
    errorString_ = "RtMidiIn::cancelCallback: no callback function was set!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  inputData_.userCallback = 0;
  inputData_.userData = 0;
  inputData_.usingCallback = false;
}

void MidiInApi :: ignoreTypes( bool midiSysex, bool midiTime, bool midiSense )
{
  inputData_.ignoreFlags = 0;
  if ( midiSysex ) inputData_.ignoreFlags = 0x01;
  if ( midiTime ) inputData_.ignoreFlags |= 0x02;
  if ( midiSense ) inputData_.ignoreFlags |= 0x04;
}

double MidiInApi :: getMessage( std::vector<unsigned char> *message )
{
  message->clear();

  if ( inputData_.usingCallback ) {
    errorString_ = "RtMidiIn::getNextMessage: a user callback is currently set for this port.";
    error( RtMidiError::WARNING, errorString_ );
    return 0.0;
  }

  double timeStamp;
  if (!inputData_.queue.pop(message, &timeStamp))
    return 0.0;

  return timeStamp;
}

unsigned int MidiInApi::MidiQueue::size(unsigned int *__back,
					unsigned int *__front)
{
  // Access back/front members exactly once and make stack copies for
  // size calculation
  unsigned int _back = back, _front = front, _size;
  if (_back >= _front)
    _size = _back - _front;
  else
    _size = ringSize - _front + _back;

  // Return copies of back/front so no new and unsynchronized accesses
  // to member variables are needed.
  if (__back) *__back = _back;
  if (__front) *__front = _front;
  return _size;
}

// As long as we haven't reached our queue size limit, push the message.
bool MidiInApi::MidiQueue::push(const MidiInApi::MidiMessage& msg)
{
  // Local stack copies of front/back
  unsigned int _back, _front, _size;

  // Get back/front indexes exactly once and calculate current size
  _size = size(&_back, &_front);

  if ( _size < ringSize-1 )
  {
    ring[_back] = msg;
    back = (back+1)%ringSize;
    return true;
  }

  return false;
}

bool MidiInApi::MidiQueue::pop(std::vector<unsigned char> *msg, double* timeStamp)
{
  // Local stack copies of front/back
  unsigned int _back, _front, _size;

  // Get back/front indexes exactly once and calculate current size
  _size = size(&_back, &_front);

  if (_size == 0)
    return false;

  // Copy queued message to the vector pointer argument and then "pop" it.
  msg->assign( ring[_front].bytes.begin(), ring[_front].bytes.end() );
  *timeStamp = ring[_front].timeStamp;

  // Update front
  front = (front+1)%ringSize;
  return true;
}

//*********************************************************************//
//  Common MidiOutApi Definitions
//*********************************************************************//

MidiOutApi :: MidiOutApi( void )
  : MidiApi()
{
}

MidiOutApi :: ~MidiOutApi( void )
{
}

// *************************************************** //
//
// OS/API-specific methods.
//
// *************************************************** //

#if defined(__MACOSX_CORE__)

// The CoreMIDI API is based on the use of a callback function for
// MIDI input.  We convert the system specific time stamps to delta
// time values.

// The CoreMIDI API is based on the use of a callback function for
// MIDI input.  We convert the system specific time stamps to delta
// time values.

// OS-X CoreMIDI header files.
#include <CoreMIDI/CoreMIDI.h>

#if defined(__MACOSX_CORE__)
    #if TARGET_OS_IPHONE
    static inline UInt32 EndianS32_BtoN(UInt32 x)
        {
            return ((x << 24) & 0xFF000000) | ((x << 8) & 0x00FF0000)
            | ((x >> 8) & 0x0000FF00) | ((x >> 24) & 0x000000FF);
        }
    #else
        #include <CoreAudio/HostTime.h>
        #include <CoreServices/CoreServices.h>
    #endif
#endif

// A structure to hold variables related to the CoreMIDI API
// implementation.
struct CoreMidiData {
  MIDIClientRef client;
  MIDIPortRef port;
  MIDIEndpointRef endpoint;
  MIDIEndpointRef destinationId;
  unsigned long long lastTime;
  MIDISysexSendRequest sysexreq;
};

//*********************************************************************//
//  API: OS-X
//  Class Definitions: MidiInCore
//*********************************************************************//

static void midiInputCallback( const MIDIPacketList *list, void *procRef, void */*srcRef*/ )
{
  MidiInApi::RtMidiInData *data = static_cast<MidiInApi::RtMidiInData *> (procRef);
  CoreMidiData *apiData = static_cast<CoreMidiData *> (data->apiData);

  unsigned char status;
  unsigned short nBytes, iByte, size;
  unsigned long long time;

  bool& continueSysex = data->continueSysex;
  MidiInApi::MidiMessage& message = data->message;

  const MIDIPacket *packet = &list->packet[0];
  for ( unsigned int i=0; i<list->numPackets; ++i ) {

    // My interpretation of the CoreMIDI documentation: all message
    // types, except sysex, are complete within a packet and there may
    // be several of them in a single packet.  Sysex messages can be
    // broken across multiple packets and PacketLists but are bundled
    // alone within each packet (these packets do not contain other
    // message types).  If sysex messages are split across multiple
    // MIDIPacketLists, they must be handled by multiple calls to this
    // function.

    nBytes = packet->length;
    if ( nBytes == 0 ) continue;

    // Calculate time stamp.

    /*
    if ( data->firstMessage ) {
      message.timeStamp = 0.0;
      data->firstMessage = false;
    }
    else {
      time = packet->timeStamp;
      if ( time == 0 ) { // this happens when receiving asynchronous sysex messages
        time = AudioGetCurrentHostTime();
      }
      time -= apiData->lastTime;
      time = AudioConvertHostTimeToNanos( time );
      if ( !continueSysex )
        message.timeStamp = time * 0.000000001;
    }
    apiData->lastTime = packet->timeStamp;
    if ( apiData->lastTime == 0 ) { // this happens when receiving asynchronous sysex messages
      apiData->lastTime = AudioGetCurrentHostTime();
    }
    //std::cout << "TimeStamp = " << packet->timeStamp << std::endl;
    */
      
    // 10/02/19: absolute usec based time stamp, possibly using current time if packet timestamp seems wrong...
    double packet_usec = AudioConvertHostTimeToNanos(packet->timeStamp) / 1000;
    double cur_date_usec = double(AudioConvertHostTimeToNanos(AudioGetCurrentHostTime())) / 1000.;
    double delta_usec = cur_date_usec - packet_usec;
    message.timeStamp = (delta_usec > 1000) ? cur_date_usec : packet_usec;
  
    iByte = 0;
    if ( continueSysex ) {
      // We have a continuing, segmented sysex message.
      if ( !( data->ignoreFlags & 0x01 ) ) {
        // If we're not ignoring sysex messages, copy the entire packet.
        for ( unsigned int j=0; j<nBytes; ++j )
          message.bytes.push_back( packet->data[j] );
      }
      continueSysex = packet->data[nBytes-1] != 0xF7;

      if ( !( data->ignoreFlags & 0x01 ) && !continueSysex ) {
        // If not a continuing sysex message, invoke the user callback function or queue the message.
        if ( data->usingCallback ) {
          RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
          callback( message.timeStamp, &message.bytes, data->userData );
        }
        else {
          // As long as we haven't reached our queue size limit, push the message.
          if (!data->queue.push(message))
            std::cerr << "\nMidiInCore: message queue limit reached!!\n\n";
        }
        message.bytes.clear();
      }
    }
    else {
      while ( iByte < nBytes ) {
        size = 0;
        // We are expecting that the next byte in the packet is a status byte.
        status = packet->data[iByte];
        if ( !(status & 0x80) ) break;
        // Determine the number of bytes in the MIDI message.
        if ( status < 0xC0 ) size = 3;
        else if ( status < 0xE0 ) size = 2;
        else if ( status < 0xF0 ) size = 3;
        else if ( status == 0xF0 ) {
          // A MIDI sysex
          if ( data->ignoreFlags & 0x01 ) {
            size = 0;
            iByte = nBytes;
          }
          else size = nBytes - iByte;
          continueSysex = packet->data[nBytes-1] != 0xF7;
        }
        else if ( status == 0xF1 ) {
            // A MIDI time code message
           if ( data->ignoreFlags & 0x02 ) {
            size = 0;
            iByte += 2;
           }
           else size = 2;
        }
        else if ( status == 0xF2 ) size = 3;
        else if ( status == 0xF3 ) size = 2;
        else if ( status == 0xF8 && ( data->ignoreFlags & 0x02 ) ) {
          // A MIDI timing tick message and we're ignoring it.
          size = 0;
          iByte += 1;
        }
        else if ( status == 0xFE && ( data->ignoreFlags & 0x04 ) ) {
          // A MIDI active sensing message and we're ignoring it.
          size = 0;
          iByte += 1;
        }
        else size = 1;

        // Copy the MIDI data to our vector.
        if ( size ) {
          message.bytes.assign( &packet->data[iByte], &packet->data[iByte+size] );
          if ( !continueSysex ) {
            // If not a continuing sysex message, invoke the user callback function or queue the message.
            if ( data->usingCallback ) {
              RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
              callback( message.timeStamp, &message.bytes, data->userData );
            }
            else {
              // As long as we haven't reached our queue size limit, push the message.
              if (!data->queue.push(message))
                std::cerr << "\nMidiInCore: message queue limit reached!!\n\n";
            }
            message.bytes.clear();
          }
          iByte += size;
        }
      }
    }
    packet = MIDIPacketNext(packet);
  }
}

MidiInCore :: MidiInCore( const std::string &clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit )
{
  initialize( clientName );
}

MidiInCore :: ~MidiInCore( void )
{
  // Close a connection if it exists.
  closePort();

  // Cleanup.
  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
  MIDIClientDispose( data->client );
  if ( data->endpoint ) MIDIEndpointDispose( data->endpoint );
  delete data;
}

void MidiInCore :: initialize( const std::string& clientName )
{
  // Set up our client.
  MIDIClientRef client;
  CFStringRef name = CFStringCreateWithCString( NULL, clientName.c_str(), kCFStringEncodingASCII );
  OSStatus result = MIDIClientCreate(name, NULL, NULL, &client );
  if ( result != noErr ) {
    std::ostringstream ost;
    ost << "MidiInCore::initialize: error creating OS-X MIDI client object (" << result << ").";
    errorString_ = ost.str();
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Save our api-specific connection information.
  CoreMidiData *data = (CoreMidiData *) new CoreMidiData;
  data->client = client;
  data->endpoint = 0;
  apiData_ = (void *) data;
  inputData_.apiData = (void *) data;
  CFRelease(name);
}

void MidiInCore :: openPort( unsigned int portNumber, const std::string &portName )
{
  if ( connected_ ) {
    errorString_ = "MidiInCore::openPort: a valid connection already exists!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  CFRunLoopRunInMode( kCFRunLoopDefaultMode, 0, false );
  unsigned int nSrc = MIDIGetNumberOfSources();
  if (nSrc < 1) {
    errorString_ = "MidiInCore::openPort: no MIDI input sources found!";
    error( RtMidiError::NO_DEVICES_FOUND, errorString_ );
    return;
  }

  if ( portNumber >= nSrc ) {
    std::ostringstream ost;
    ost << "MidiInCore::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::INVALID_PARAMETER, errorString_ );
    return;
  }

  MIDIPortRef port;
  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
  OSStatus result = MIDIInputPortCreate( data->client, 
                                         CFStringCreateWithCString( NULL, portName.c_str(), kCFStringEncodingASCII ),
                                         midiInputCallback, (void *)&inputData_, &port );
  if ( result != noErr ) {
    MIDIClientDispose( data->client );
    errorString_ = "MidiInCore::openPort: error creating OS-X MIDI input port.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Get the desired input source identifier.
  MIDIEndpointRef endpoint = MIDIGetSource( portNumber );
  if ( endpoint == 0 ) {
    MIDIPortDispose( port );
    MIDIClientDispose( data->client );
    errorString_ = "MidiInCore::openPort: error getting MIDI input source reference.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Make the connection.
  result = MIDIPortConnectSource( port, endpoint, NULL );
  if ( result != noErr ) {
    MIDIPortDispose( port );
    MIDIClientDispose( data->client );
    errorString_ = "MidiInCore::openPort: error connecting OS-X MIDI input port.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Save our api-specific port information.
  data->port = port;

  connected_ = true;
}

void MidiInCore :: openVirtualPort( const std::string &portName )
{
  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);

  // Create a virtual MIDI input destination.
  MIDIEndpointRef endpoint;
  OSStatus result = MIDIDestinationCreate( data->client,
                                           CFStringCreateWithCString( NULL, portName.c_str(), kCFStringEncodingASCII ),
                                           midiInputCallback, (void *)&inputData_, &endpoint );
  if ( result != noErr ) {
    errorString_ = "MidiInCore::openVirtualPort: error creating virtual OS-X MIDI destination.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Save our api-specific connection information.
  data->endpoint = endpoint;
}

void MidiInCore :: closePort( void )
{
  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);

  if ( data->endpoint ) {
    MIDIEndpointDispose( data->endpoint );
    data->endpoint = 0;
  }

  if ( data->port ) {
    MIDIPortDispose( data->port );
    data->port = 0;
  }

  connected_ = false;
}

unsigned int MidiInCore :: getPortCount()
{
  CFRunLoopRunInMode( kCFRunLoopDefaultMode, 0, false );
  return MIDIGetNumberOfSources();
}

// This function was submitted by Douglas Casey Tucker and apparently
// derived largely from PortMidi.
CFStringRef EndpointName( MIDIEndpointRef endpoint, bool isExternal )
{
  CFMutableStringRef result = CFStringCreateMutable( NULL, 0 );
  CFStringRef str;

  // Begin with the endpoint's name.
  str = NULL;
  MIDIObjectGetStringProperty( endpoint, kMIDIPropertyName, &str );
  if ( str != NULL ) {
    CFStringAppend( result, str );
    CFRelease( str );
  }

  MIDIEntityRef entity = 0;
  MIDIEndpointGetEntity( endpoint, &entity );
  if ( entity == 0 )
    // probably virtual
    return result;

  if ( CFStringGetLength( result ) == 0 ) {
    // endpoint name has zero length -- try the entity
    str = NULL;
    MIDIObjectGetStringProperty( entity, kMIDIPropertyName, &str );
    if ( str != NULL ) {
      CFStringAppend( result, str );
      CFRelease( str );
    }
  }
  // now consider the device's name
  MIDIDeviceRef device = 0;
  MIDIEntityGetDevice( entity, &device );
  if ( device == 0 )
    return result;

  str = NULL;
  MIDIObjectGetStringProperty( device, kMIDIPropertyName, &str );
  if ( CFStringGetLength( result ) == 0 ) {
      CFRelease( result );
      return str;
  }
  if ( str != NULL ) {
    // if an external device has only one entity, throw away
    // the endpoint name and just use the device name
    if ( isExternal && MIDIDeviceGetNumberOfEntities( device ) < 2 ) {
      CFRelease( result );
      return str;
    } else {
      if ( CFStringGetLength( str ) == 0 ) {
        CFRelease( str );
        return result;
      }
      // does the entity name already start with the device name?
      // (some drivers do this though they shouldn't)
      // if so, do not prepend
        if ( CFStringCompareWithOptions( result, /* endpoint name */
             str /* device name */,
             CFRangeMake(0, CFStringGetLength( str ) ), 0 ) != kCFCompareEqualTo ) {
        // prepend the device name to the entity name
        if ( CFStringGetLength( result ) > 0 )
          CFStringInsert( result, 0, CFSTR(" ") );
        CFStringInsert( result, 0, str );
      }
      CFRelease( str );
    }
  }
  return result;
}

// This function was submitted by Douglas Casey Tucker and apparently
// derived largely from PortMidi.
static CFStringRef ConnectedEndpointName( MIDIEndpointRef endpoint )
{
  CFMutableStringRef result = CFStringCreateMutable( NULL, 0 );
  CFStringRef str;
  OSStatus err;
  int i;

  // Does the endpoint have connections?
  CFDataRef connections = NULL;
  int nConnected = 0;
  bool anyStrings = false;
  err = MIDIObjectGetDataProperty( endpoint, kMIDIPropertyConnectionUniqueID, &connections );
  if ( connections != NULL ) {
    // It has connections, follow them
    // Concatenate the names of all connected devices
    nConnected = CFDataGetLength( connections ) / sizeof(MIDIUniqueID);
    if ( nConnected ) {
      const SInt32 *pid = (const SInt32 *)(CFDataGetBytePtr(connections));
      for ( i=0; i<nConnected; ++i, ++pid ) {
        MIDIUniqueID id = EndianS32_BtoN( *pid );
        MIDIObjectRef connObject;
        MIDIObjectType connObjectType;
        err = MIDIObjectFindByUniqueID( id, &connObject, &connObjectType );
        if ( err == noErr ) {
          if ( connObjectType == kMIDIObjectType_ExternalSource  ||
              connObjectType == kMIDIObjectType_ExternalDestination ) {
            // Connected to an external device's endpoint (10.3 and later).
            str = EndpointName( (MIDIEndpointRef)(connObject), true );
          } else {
            // Connected to an external device (10.2) (or something else, catch-
            str = NULL;
            MIDIObjectGetStringProperty( connObject, kMIDIPropertyName, &str );
          }
          if ( str != NULL ) {
            if ( anyStrings )
              CFStringAppend( result, CFSTR(", ") );
            else anyStrings = true;
            CFStringAppend( result, str );
            CFRelease( str );
          }
        }
      }
    }
    CFRelease( connections );
  }
  if ( anyStrings )
    return result;

  CFRelease( result );

  // Here, either the endpoint had no connections, or we failed to obtain names 
  return EndpointName( endpoint, false );
}

std::string MidiInCore :: getPortName( unsigned int portNumber )
{
  CFStringRef nameRef;
  MIDIEndpointRef portRef;
  char name[128];

  std::string stringName;
  CFRunLoopRunInMode( kCFRunLoopDefaultMode, 0, false );
  if ( portNumber >= MIDIGetNumberOfSources() ) {
    std::ostringstream ost;
    ost << "MidiInCore::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::WARNING, errorString_ );
    return stringName;
  }

  portRef = MIDIGetSource( portNumber );
  nameRef = ConnectedEndpointName(portRef);
  CFStringGetCString( nameRef, name, sizeof(name), kCFStringEncodingUTF8);
  CFRelease( nameRef );

  return stringName = name;
}

//*********************************************************************//
//  API: OS-X
//  Class Definitions: MidiOutCore
//*********************************************************************//

MidiOutCore :: MidiOutCore( const std::string &clientName ) : MidiOutApi()
{
  initialize( clientName );
}

MidiOutCore :: ~MidiOutCore( void )
{
  // Close a connection if it exists.
  closePort();

  // Cleanup.
  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
  MIDIClientDispose( data->client );
  if ( data->endpoint ) MIDIEndpointDispose( data->endpoint );
  delete data;
}

void MidiOutCore :: initialize( const std::string& clientName )
{
  // Set up our client.
  MIDIClientRef client;
  CFStringRef name = CFStringCreateWithCString( NULL, clientName.c_str(), kCFStringEncodingASCII );
  OSStatus result = MIDIClientCreate(name, NULL, NULL, &client );
  if ( result != noErr ) {
    std::ostringstream ost;
    ost << "MidiInCore::initialize: error creating OS-X MIDI client object (" << result << ").";
    errorString_ = ost.str();
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Save our api-specific connection information.
  CoreMidiData *data = (CoreMidiData *) new CoreMidiData;
  data->client = client;
  data->endpoint = 0;
  apiData_ = (void *) data;
  CFRelease( name );
}

unsigned int MidiOutCore :: getPortCount()
{
  CFRunLoopRunInMode( kCFRunLoopDefaultMode, 0, false );
  return MIDIGetNumberOfDestinations();
}

std::string MidiOutCore :: getPortName( unsigned int portNumber )
{
  CFStringRef nameRef;
  MIDIEndpointRef portRef;
  char name[128];

  std::string stringName;
  CFRunLoopRunInMode( kCFRunLoopDefaultMode, 0, false );
  if ( portNumber >= MIDIGetNumberOfDestinations() ) {
    std::ostringstream ost;
    ost << "MidiOutCore::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::WARNING, errorString_ );
    return stringName;
  }

  portRef = MIDIGetDestination( portNumber );
  nameRef = ConnectedEndpointName(portRef);
  CFStringGetCString( nameRef, name, sizeof(name), kCFStringEncodingUTF8 );
  CFRelease( nameRef );
  
  return stringName = name;
}

void MidiOutCore :: openPort( unsigned int portNumber, const std::string &portName )
{
  if ( connected_ ) {
    errorString_ = "MidiOutCore::openPort: a valid connection already exists!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  CFRunLoopRunInMode( kCFRunLoopDefaultMode, 0, false );
  unsigned int nDest = MIDIGetNumberOfDestinations();
  if (nDest < 1) {
    errorString_ = "MidiOutCore::openPort: no MIDI output destinations found!";
    error( RtMidiError::NO_DEVICES_FOUND, errorString_ );
    return;
  }

  if ( portNumber >= nDest ) {
    std::ostringstream ost;
    ost << "MidiOutCore::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::INVALID_PARAMETER, errorString_ );
    return;
  }

  MIDIPortRef port;
  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
  CFStringRef portNameRef = CFStringCreateWithCString( NULL, portName.c_str(), kCFStringEncodingASCII );
  OSStatus result = MIDIOutputPortCreate( data->client, 
                                          portNameRef,
                                          &port );
  CFRelease( portNameRef );
  if ( result != noErr ) {
    MIDIClientDispose( data->client );
    errorString_ = "MidiOutCore::openPort: error creating OS-X MIDI output port.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Get the desired output port identifier.
  MIDIEndpointRef destination = MIDIGetDestination( portNumber );
  if ( destination == 0 ) {
    MIDIPortDispose( port );
    MIDIClientDispose( data->client );
    errorString_ = "MidiOutCore::openPort: error getting MIDI output destination reference.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Save our api-specific connection information.
  data->port = port;
  data->destinationId = destination;
  connected_ = true;
}

void MidiOutCore :: closePort( void )
{
  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);

  if ( data->endpoint ) {
    MIDIEndpointDispose( data->endpoint );
    data->endpoint = 0;
  }

  if ( data->port ) {
    MIDIPortDispose( data->port );
    data->port = 0;
  }

  connected_ = false;
}

void MidiOutCore :: openVirtualPort( const std::string &portName )
{
  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);

  if ( data->endpoint ) {
    errorString_ = "MidiOutCore::openVirtualPort: a virtual output port already exists!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  // Create a virtual MIDI output source.
  MIDIEndpointRef endpoint;
  OSStatus result = MIDISourceCreate( data->client,
                                      CFStringCreateWithCString( NULL, portName.c_str(), kCFStringEncodingASCII ),
                                      &endpoint );
  if ( result != noErr ) {
    errorString_ = "MidiOutCore::initialize: error creating OS-X virtual MIDI source.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Save our api-specific connection information.
  data->endpoint = endpoint;
}

void MidiOutCore :: sendMessage( const unsigned char *message, size_t size )
{
  // We use the MIDISendSysex() function to asynchronously send sysex
  // messages.  Otherwise, we use a single CoreMidi MIDIPacket.
  unsigned int nBytes = static_cast<unsigned int> (size);
  if ( nBytes == 0 ) {
    errorString_ = "MidiOutCore::sendMessage: no data in message argument!";      
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  MIDITimeStamp timeStamp = AudioGetCurrentHostTime();
  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
  OSStatus result;

  if ( message[0] != 0xF0 && nBytes > 3 ) {
    errorString_ = "MidiOutCore::sendMessage: message format problem ... not sysex but > 3 bytes?";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  Byte buffer[nBytes+(sizeof(MIDIPacketList))];
  ByteCount listSize = sizeof(buffer);
  MIDIPacketList *packetList = (MIDIPacketList*)buffer;
  MIDIPacket *packet = MIDIPacketListInit( packetList );

  ByteCount remainingBytes = nBytes;
  while (remainingBytes && packet) {
    ByteCount bytesForPacket = remainingBytes > 65535 ? 65535 : remainingBytes; // 65535 = maximum size of a MIDIPacket
    const Byte* dataStartPtr = (const Byte *) &message[nBytes - remainingBytes];
    packet = MIDIPacketListAdd( packetList, listSize, packet, timeStamp, bytesForPacket, dataStartPtr);
    remainingBytes -= bytesForPacket; 
  }

  if ( !packet ) {
    errorString_ = "MidiOutCore::sendMessage: could not allocate packet list";      
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Send to any destinations that may have connected to us.
  if ( data->endpoint ) {
    result = MIDIReceived( data->endpoint, packetList );
    if ( result != noErr ) {
      errorString_ = "MidiOutCore::sendMessage: error sending MIDI to virtual destinations.";
      error( RtMidiError::WARNING, errorString_ );
    }
  }

  // And send to an explicit destination port if we're connected.
  if ( connected_ ) {
    result = MIDISend( data->port, data->destinationId, packetList );
    if ( result != noErr ) {
      errorString_ = "MidiOutCore::sendMessage: error sending MIDI message to port.";
      error( RtMidiError::WARNING, errorString_ );
    }
  }
}

#endif  // __MACOSX_CORE__


//*********************************************************************//
//  API: LINUX ALSA SEQUENCER
//*********************************************************************//

// API information found at:
//   - http://www.alsa-project.org/documentation.php#Library

#if defined(__LINUX_ALSA__)

// The ALSA Sequencer API is based on the use of a callback function for
// MIDI input.
//
// Thanks to Pedro Lopez-Cabanillas for help with the ALSA sequencer
// time stamps and other assorted fixes!!!

// If you don't need timestamping for incoming MIDI events, define the
// preprocessor definition AVOID_TIMESTAMPING to save resources
// associated with the ALSA sequencer queues.

#include <pthread.h>
#include <sys/time.h>

// ALSA header file.
#include <alsa/asoundlib.h>

// A structure to hold variables related to the ALSA API
// implementation.
struct AlsaMidiData {
  snd_seq_t *seq;
  unsigned int portNum;
  int vport;
  snd_seq_port_subscribe_t *subscription;
  snd_midi_event_t *coder;
  unsigned int bufferSize;
  unsigned char *buffer;
  pthread_t thread;
  pthread_t dummy_thread_id;
  snd_seq_real_time_t lastTime;
  int queue_id; // an input queue is needed to get timestamped events
  int trigger_fds[2];
};

#define PORT_TYPE( pinfo, bits ) ((snd_seq_port_info_get_capability(pinfo) & (bits)) == (bits))

//*********************************************************************//
//  API: LINUX ALSA
//  Class Definitions: MidiInAlsa
//*********************************************************************//

static void *alsaMidiHandler( void *ptr )
{
  MidiInApi::RtMidiInData *data = static_cast<MidiInApi::RtMidiInData *> (ptr);
  AlsaMidiData *apiData = static_cast<AlsaMidiData *> (data->apiData);

  long nBytes;
  double time;
  bool continueSysex = false;
  bool doDecode = false;
  MidiInApi::MidiMessage message;
  int poll_fd_count;
  struct pollfd *poll_fds;

  snd_seq_event_t *ev;
  int result;
  apiData->bufferSize = 32;
  result = snd_midi_event_new( 0, &apiData->coder );
  if ( result < 0 ) {
    data->doInput = false;
    std::cerr << "\nMidiInAlsa::alsaMidiHandler: error initializing MIDI event parser!\n\n";
    return 0;
  }
  unsigned char *buffer = (unsigned char *) malloc( apiData->bufferSize );
  if ( buffer == NULL ) {
    data->doInput = false;
    snd_midi_event_free( apiData->coder );
    apiData->coder = 0;
    std::cerr << "\nMidiInAlsa::alsaMidiHandler: error initializing buffer memory!\n\n";
    return 0;
  }
  snd_midi_event_init( apiData->coder );
  snd_midi_event_no_status( apiData->coder, 1 ); // suppress running status messages

  poll_fd_count = snd_seq_poll_descriptors_count( apiData->seq, POLLIN ) + 1;
  poll_fds = (struct pollfd*)alloca( poll_fd_count * sizeof( struct pollfd ));
  snd_seq_poll_descriptors( apiData->seq, poll_fds + 1, poll_fd_count - 1, POLLIN );
  poll_fds[0].fd = apiData->trigger_fds[0];
  poll_fds[0].events = POLLIN;

  while ( data->doInput ) {

    if ( snd_seq_event_input_pending( apiData->seq, 1 ) == 0 ) {
      // No data pending
      if ( poll( poll_fds, poll_fd_count, -1) >= 0 ) {
        if ( poll_fds[0].revents & POLLIN ) {
          bool dummy;
          int res = read( poll_fds[0].fd, &dummy, sizeof(dummy) );
          (void) res;
        }
      }
      continue;
    }

    // If here, there should be data.
    result = snd_seq_event_input( apiData->seq, &ev );
    if ( result == -ENOSPC ) {
      std::cerr << "\nMidiInAlsa::alsaMidiHandler: MIDI input buffer overrun!\n\n";
      continue;
    }
    else if ( result <= 0 ) {
      std::cerr << "\nMidiInAlsa::alsaMidiHandler: unknown MIDI input error!\n";
      perror("System reports");
      continue;
    }

    // This is a bit weird, but we now have to decode an ALSA MIDI
    // event (back) into MIDI bytes.  We'll ignore non-MIDI types.
    if ( !continueSysex ) message.bytes.clear();

    doDecode = false;
    switch ( ev->type ) {

    case SND_SEQ_EVENT_PORT_SUBSCRIBED:
#if defined(__RTMIDI_DEBUG__)
      std::cout << "MidiInAlsa::alsaMidiHandler: port connection made!\n";
#endif
      break;

    case SND_SEQ_EVENT_PORT_UNSUBSCRIBED:
#if defined(__RTMIDI_DEBUG__)
      std::cerr << "MidiInAlsa::alsaMidiHandler: port connection has closed!\n";
      std::cout << "sender = " << (int) ev->data.connect.sender.client << ":"
                << (int) ev->data.connect.sender.port
                << ", dest = " << (int) ev->data.connect.dest.client << ":"
                << (int) ev->data.connect.dest.port
                << std::endl;
#endif
      break;

    case SND_SEQ_EVENT_QFRAME: // MIDI time code
      if ( !( data->ignoreFlags & 0x02 ) ) doDecode = true;
      break;

    case SND_SEQ_EVENT_TICK: // 0xF9 ... MIDI timing tick
      if ( !( data->ignoreFlags & 0x02 ) ) doDecode = true;
      break;

    case SND_SEQ_EVENT_CLOCK: // 0xF8 ... MIDI timing (clock) tick
      if ( !( data->ignoreFlags & 0x02 ) ) doDecode = true;
      break;

    case SND_SEQ_EVENT_SENSING: // Active sensing
      if ( !( data->ignoreFlags & 0x04 ) ) doDecode = true;
      break;

		case SND_SEQ_EVENT_SYSEX:
      if ( (data->ignoreFlags & 0x01) ) break;
      if ( ev->data.ext.len > apiData->bufferSize ) {
        apiData->bufferSize = ev->data.ext.len;
        free( buffer );
        buffer = (unsigned char *) malloc( apiData->bufferSize );
        if ( buffer == NULL ) {
          data->doInput = false;
          std::cerr << "\nMidiInAlsa::alsaMidiHandler: error resizing buffer memory!\n\n";
          break;
        }
      }

    default:
      doDecode = true;
    }

    if ( doDecode ) {

      nBytes = snd_midi_event_decode( apiData->coder, buffer, apiData->bufferSize, ev );
      if ( nBytes > 0 ) {
        // The ALSA sequencer has a maximum buffer size for MIDI sysex
        // events of 256 bytes.  If a device sends sysex messages larger
        // than this, they are segmented into 256 byte chunks.  So,
        // we'll watch for this and concatenate sysex chunks into a
        // single sysex message if necessary.
        if ( !continueSysex )
          message.bytes.assign( buffer, &buffer[nBytes] );
        else
          message.bytes.insert( message.bytes.end(), buffer, &buffer[nBytes] );

        continueSysex = ( ( ev->type == SND_SEQ_EVENT_SYSEX ) && ( message.bytes.back() != 0xF7 ) );
        if ( !continueSysex ) {

          // Calculate the time stamp:
          message.timeStamp = 0.0;

          // Method 1: Use the system time.
          //(void)gettimeofday(&tv, (struct timezone *)NULL);
          //time = (tv.tv_sec * 1000000) + tv.tv_usec;

          // Method 2: Use the ALSA sequencer event time data.
          // (thanks to Pedro Lopez-Cabanillas!).

          // Using method from:
          // https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html

          // Perform the carry for the later subtraction by updating y.
          snd_seq_real_time_t &x(ev->time.time);
          snd_seq_real_time_t &y(apiData->lastTime);
          if (x.tv_nsec < y.tv_nsec) {
              int nsec = (y.tv_nsec - x.tv_nsec) / 1000000000 + 1;
              y.tv_nsec -= 1000000000 * nsec;
              y.tv_sec += nsec;
          }
          if (x.tv_nsec - y.tv_nsec > 1000000000) {
              int nsec = (x.tv_nsec - y.tv_nsec) / 1000000000;
              y.tv_nsec += 1000000000 * nsec;
              y.tv_sec -= nsec;
          }

          // Compute the time difference.
          time = x.tv_sec - y.tv_sec + (x.tv_nsec - y.tv_nsec)*1e-9;

          apiData->lastTime = ev->time.time;

          if ( data->firstMessage == true )
            data->firstMessage = false;
          else
            message.timeStamp = time;
            
          // 10/02/19: absolute usec based time stamp
          message.timeStamp *= 1000000;
        }
        else {
#if defined(__RTMIDI_DEBUG__)
          std::cerr << "\nMidiInAlsa::alsaMidiHandler: event parsing error or not a MIDI event!\n\n";
#endif
        }
      }
    }

    snd_seq_free_event( ev );
    if ( message.bytes.size() == 0 || continueSysex ) continue;

    if ( data->usingCallback ) {
      RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
      callback( message.timeStamp, &message.bytes, data->userData );
    }
    else {
      // As long as we haven't reached our queue size limit, push the message.
      if (!data->queue.push(message))
        std::cerr << "\nMidiInAlsa: message queue limit reached!!\n\n";
    }
  }

  if ( buffer ) free( buffer );
  snd_midi_event_free( apiData->coder );
  apiData->coder = 0;
  apiData->thread = apiData->dummy_thread_id;
  return 0;
}

MidiInAlsa :: MidiInAlsa( const std::string &clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit )
{
  initialize( clientName );
}

MidiInAlsa :: ~MidiInAlsa()
{
  // Close a connection if it exists.
  closePort();

  // Shutdown the input thread.
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  if ( inputData_.doInput ) {
    inputData_.doInput = false;
    int res = write( data->trigger_fds[1], &inputData_.doInput, sizeof(inputData_.doInput) );
    (void) res;
    if ( !pthread_equal(data->thread, data->dummy_thread_id) )
      pthread_join( data->thread, NULL );
  }

  // Cleanup.
  close ( data->trigger_fds[0] );
  close ( data->trigger_fds[1] );
  if ( data->vport >= 0 ) snd_seq_delete_port( data->seq, data->vport );
#ifndef AVOID_TIMESTAMPING
  snd_seq_free_queue( data->seq, data->queue_id );
#endif
  snd_seq_close( data->seq );
  delete data;
}

void MidiInAlsa :: initialize( const std::string& clientName )
{
  // Set up the ALSA sequencer client.
  snd_seq_t *seq;
  int result = snd_seq_open(&seq, "default", SND_SEQ_OPEN_DUPLEX, SND_SEQ_NONBLOCK);
  if ( result < 0 ) {
    errorString_ = "MidiInAlsa::initialize: error creating ALSA sequencer client object.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Set client name.
  snd_seq_set_client_name( seq, clientName.c_str() );

  // Save our api-specific connection information.
  AlsaMidiData *data = (AlsaMidiData *) new AlsaMidiData;
  data->seq = seq;
  data->portNum = -1;
  data->vport = -1;
  data->subscription = 0;
  data->dummy_thread_id = pthread_self();
  data->thread = data->dummy_thread_id;
  data->trigger_fds[0] = -1;
  data->trigger_fds[1] = -1;
  apiData_ = (void *) data;
  inputData_.apiData = (void *) data;

   if ( pipe(data->trigger_fds) == -1 ) {
    errorString_ = "MidiInAlsa::initialize: error creating pipe objects.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Create the input queue
#ifndef AVOID_TIMESTAMPING
  data->queue_id = snd_seq_alloc_named_queue(seq, "RtMidi Queue");
  // Set arbitrary tempo (mm=100) and resolution (240)
  snd_seq_queue_tempo_t *qtempo;
  snd_seq_queue_tempo_alloca(&qtempo);
  snd_seq_queue_tempo_set_tempo(qtempo, 600000);
  snd_seq_queue_tempo_set_ppq(qtempo, 240);
  snd_seq_set_queue_tempo(data->seq, data->queue_id, qtempo);
  snd_seq_drain_output(data->seq);
#endif
}

// This function is used to count or get the pinfo structure for a given port number.
unsigned int portInfo( snd_seq_t *seq, snd_seq_port_info_t *pinfo, unsigned int type, int portNumber )
{
  snd_seq_client_info_t *cinfo;
  int client;
  int count = 0;
  snd_seq_client_info_alloca( &cinfo );

  snd_seq_client_info_set_client( cinfo, -1 );
  while ( snd_seq_query_next_client( seq, cinfo ) >= 0 ) {
    client = snd_seq_client_info_get_client( cinfo );
    if ( client == 0 ) continue;
    // Reset query info
    snd_seq_port_info_set_client( pinfo, client );
    snd_seq_port_info_set_port( pinfo, -1 );
    while ( snd_seq_query_next_port( seq, pinfo ) >= 0 ) {
      unsigned int atyp = snd_seq_port_info_get_type( pinfo );
      if ( ( ( atyp & SND_SEQ_PORT_TYPE_MIDI_GENERIC ) == 0 ) &&
           ( ( atyp & SND_SEQ_PORT_TYPE_SYNTH ) == 0 ) &&
           ( ( atyp & SND_SEQ_PORT_TYPE_APPLICATION ) == 0 ) ) continue;
	    
      unsigned int caps = snd_seq_port_info_get_capability( pinfo );
      if ( ( caps & type ) != type ) continue;
      if ( count == portNumber ) return 1;
      ++count;
    }
  }

  // If a negative portNumber was used, return the port count.
  if ( portNumber < 0 ) return count;
  return 0;
}

unsigned int MidiInAlsa :: getPortCount()
{
  snd_seq_port_info_t *pinfo;
  snd_seq_port_info_alloca( &pinfo );

  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  return portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ, -1 );
}

std::string MidiInAlsa :: getPortName( unsigned int portNumber )
{
  snd_seq_client_info_t *cinfo;
  snd_seq_port_info_t *pinfo;
  snd_seq_client_info_alloca( &cinfo );
  snd_seq_port_info_alloca( &pinfo );

  std::string stringName;
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  if ( portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ, (int) portNumber ) ) {
    int cnum = snd_seq_port_info_get_client( pinfo );
    snd_seq_get_any_client_info( data->seq, cnum, cinfo );
    std::ostringstream os;
    os << snd_seq_client_info_get_name( cinfo );
    os << ":";
    os << snd_seq_port_info_get_name( pinfo );
    os << " ";                                    // These lines added to make sure devices are listed
    os << snd_seq_port_info_get_client( pinfo );  // with full portnames added to ensure individual device names
    os << ":";
    os << snd_seq_port_info_get_port( pinfo );
    stringName = os.str();
    return stringName;
  }

  // If we get here, we didn't find a match.
  errorString_ = "MidiInAlsa::getPortName: error looking for port name!";
  error( RtMidiError::WARNING, errorString_ );
  return stringName;
}

void MidiInAlsa :: openPort( unsigned int portNumber, const std::string &portName )
{
  if ( connected_ ) {
    errorString_ = "MidiInAlsa::openPort: a valid connection already exists!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  unsigned int nSrc = this->getPortCount();
  if ( nSrc < 1 ) {
    errorString_ = "MidiInAlsa::openPort: no MIDI input sources found!";
    error( RtMidiError::NO_DEVICES_FOUND, errorString_ );
    return;
  }

  snd_seq_port_info_t *src_pinfo;
  snd_seq_port_info_alloca( &src_pinfo );
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  if ( portInfo( data->seq, src_pinfo, SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ, (int) portNumber ) == 0 ) {
    std::ostringstream ost;
    ost << "MidiInAlsa::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::INVALID_PARAMETER, errorString_ );
    return;
  }

  snd_seq_addr_t sender, receiver;
  sender.client = snd_seq_port_info_get_client( src_pinfo );
  sender.port = snd_seq_port_info_get_port( src_pinfo );
  receiver.client = snd_seq_client_id( data->seq );

  snd_seq_port_info_t *pinfo;
  snd_seq_port_info_alloca( &pinfo );
  if ( data->vport < 0 ) {
    snd_seq_port_info_set_client( pinfo, 0 );
    snd_seq_port_info_set_port( pinfo, 0 );
    snd_seq_port_info_set_capability( pinfo,
                                      SND_SEQ_PORT_CAP_WRITE |
                                      SND_SEQ_PORT_CAP_SUBS_WRITE );
    snd_seq_port_info_set_type( pinfo,
                                SND_SEQ_PORT_TYPE_MIDI_GENERIC |
                                SND_SEQ_PORT_TYPE_APPLICATION );
    snd_seq_port_info_set_midi_channels(pinfo, 16);
#ifndef AVOID_TIMESTAMPING
    snd_seq_port_info_set_timestamping(pinfo, 1);
    snd_seq_port_info_set_timestamp_real(pinfo, 1);    
    snd_seq_port_info_set_timestamp_queue(pinfo, data->queue_id);
#endif
    snd_seq_port_info_set_name(pinfo,  portName.c_str() );
    data->vport = snd_seq_create_port(data->seq, pinfo);
  
    if ( data->vport < 0 ) {
      errorString_ = "MidiInAlsa::openPort: ALSA error creating input port.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }
    data->vport = snd_seq_port_info_get_port(pinfo);
  }

  receiver.port = data->vport;

  if ( !data->subscription ) {
    // Make subscription
    if (snd_seq_port_subscribe_malloc( &data->subscription ) < 0) {
      errorString_ = "MidiInAlsa::openPort: ALSA error allocation port subscription.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }
    snd_seq_port_subscribe_set_sender(data->subscription, &sender);
    snd_seq_port_subscribe_set_dest(data->subscription, &receiver);
    if ( snd_seq_subscribe_port(data->seq, data->subscription) ) {
      snd_seq_port_subscribe_free( data->subscription );
      data->subscription = 0;
      errorString_ = "MidiInAlsa::openPort: ALSA error making port connection.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }
  }

  if ( inputData_.doInput == false ) {
    // Start the input queue
#ifndef AVOID_TIMESTAMPING
    snd_seq_start_queue( data->seq, data->queue_id, NULL );
    snd_seq_drain_output( data->seq );
#endif
    // Start our MIDI input thread.
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
    pthread_attr_setschedpolicy(&attr, SCHED_OTHER);

    inputData_.doInput = true;
    int err = pthread_create(&data->thread, &attr, alsaMidiHandler, &inputData_);
    pthread_attr_destroy(&attr);
    if ( err ) {
      snd_seq_unsubscribe_port( data->seq, data->subscription );
      snd_seq_port_subscribe_free( data->subscription );
      data->subscription = 0;
      inputData_.doInput = false;
      errorString_ = "MidiInAlsa::openPort: error starting MIDI input thread!";
      error( RtMidiError::THREAD_ERROR, errorString_ );
      return;
    }
  }

  connected_ = true;
}

void MidiInAlsa :: openVirtualPort( const std::string &portName )
{
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  if ( data->vport < 0 ) {
    snd_seq_port_info_t *pinfo;
    snd_seq_port_info_alloca( &pinfo );
    snd_seq_port_info_set_capability( pinfo,
				      SND_SEQ_PORT_CAP_WRITE |
				      SND_SEQ_PORT_CAP_SUBS_WRITE );
    snd_seq_port_info_set_type( pinfo,
				SND_SEQ_PORT_TYPE_MIDI_GENERIC |
				SND_SEQ_PORT_TYPE_APPLICATION );
    snd_seq_port_info_set_midi_channels(pinfo, 16);
#ifndef AVOID_TIMESTAMPING
    snd_seq_port_info_set_timestamping(pinfo, 1);
    snd_seq_port_info_set_timestamp_real(pinfo, 1);    
    snd_seq_port_info_set_timestamp_queue(pinfo, data->queue_id);
#endif
    snd_seq_port_info_set_name(pinfo, portName.c_str());
    data->vport = snd_seq_create_port(data->seq, pinfo);

    if ( data->vport < 0 ) {
      errorString_ = "MidiInAlsa::openVirtualPort: ALSA error creating virtual port.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }
    data->vport = snd_seq_port_info_get_port(pinfo);
  }

  if ( inputData_.doInput == false ) {
    // Wait for old thread to stop, if still running
    if ( !pthread_equal(data->thread, data->dummy_thread_id) )
      pthread_join( data->thread, NULL );

    // Start the input queue
#ifndef AVOID_TIMESTAMPING
    snd_seq_start_queue( data->seq, data->queue_id, NULL );
    snd_seq_drain_output( data->seq );
#endif
    // Start our MIDI input thread.
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
    pthread_attr_setschedpolicy(&attr, SCHED_OTHER);

    inputData_.doInput = true;
    int err = pthread_create(&data->thread, &attr, alsaMidiHandler, &inputData_);
    pthread_attr_destroy(&attr);
    if ( err ) {
      if ( data->subscription ) {
        snd_seq_unsubscribe_port( data->seq, data->subscription );
        snd_seq_port_subscribe_free( data->subscription );
        data->subscription = 0;
      }
      inputData_.doInput = false;
      errorString_ = "MidiInAlsa::openPort: error starting MIDI input thread!";
      error( RtMidiError::THREAD_ERROR, errorString_ );
      return;
    }
  }
}

void MidiInAlsa :: closePort( void )
{
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);

  if ( connected_ ) {
    if ( data->subscription ) {
      snd_seq_unsubscribe_port( data->seq, data->subscription );
      snd_seq_port_subscribe_free( data->subscription );
      data->subscription = 0;
    }
    // Stop the input queue
#ifndef AVOID_TIMESTAMPING
    snd_seq_stop_queue( data->seq, data->queue_id, NULL );
    snd_seq_drain_output( data->seq );
#endif
    connected_ = false;
  }

  // Stop thread to avoid triggering the callback, while the port is intended to be closed
  if ( inputData_.doInput ) {
    inputData_.doInput = false;
    int res = write( data->trigger_fds[1], &inputData_.doInput, sizeof(inputData_.doInput) );
    (void) res;
    if ( !pthread_equal(data->thread, data->dummy_thread_id) )
      pthread_join( data->thread, NULL );
  }
}

//*********************************************************************//
//  API: LINUX ALSA
//  Class Definitions: MidiOutAlsa
//*********************************************************************//

MidiOutAlsa :: MidiOutAlsa( const std::string &clientName ) : MidiOutApi()
{
  initialize( clientName );
}

MidiOutAlsa :: ~MidiOutAlsa()
{
  // Close a connection if it exists.
  closePort();

  // Cleanup.
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  if ( data->vport >= 0 ) snd_seq_delete_port( data->seq, data->vport );
  if ( data->coder ) snd_midi_event_free( data->coder );
  if ( data->buffer ) free( data->buffer );
  snd_seq_close( data->seq );
  delete data;
}

void MidiOutAlsa :: initialize( const std::string& clientName )
{
  // Set up the ALSA sequencer client.
  snd_seq_t *seq;
  int result1 = snd_seq_open( &seq, "default", SND_SEQ_OPEN_OUTPUT, SND_SEQ_NONBLOCK );
  if ( result1 < 0 ) {
    errorString_ = "MidiOutAlsa::initialize: error creating ALSA sequencer client object.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
	}

  // Set client name.
  snd_seq_set_client_name( seq, clientName.c_str() );

  // Save our api-specific connection information.
  AlsaMidiData *data = (AlsaMidiData *) new AlsaMidiData;
  data->seq = seq;
  data->portNum = -1;
  data->vport = -1;
  data->bufferSize = 32;
  data->coder = 0;
  data->buffer = 0;
  int result = snd_midi_event_new( data->bufferSize, &data->coder );
  if ( result < 0 ) {
    delete data;
    errorString_ = "MidiOutAlsa::initialize: error initializing MIDI event parser!\n\n";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }
  data->buffer = (unsigned char *) malloc( data->bufferSize );
  if ( data->buffer == NULL ) {
    delete data;
    errorString_ = "MidiOutAlsa::initialize: error allocating buffer memory!\n\n";
    error( RtMidiError::MEMORY_ERROR, errorString_ );
    return;
  }
  snd_midi_event_init( data->coder );
  apiData_ = (void *) data;
}

unsigned int MidiOutAlsa :: getPortCount()
{
	snd_seq_port_info_t *pinfo;
	snd_seq_port_info_alloca( &pinfo );

  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  return portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE, -1 );
}

std::string MidiOutAlsa :: getPortName( unsigned int portNumber )
{
  snd_seq_client_info_t *cinfo;
  snd_seq_port_info_t *pinfo;
  snd_seq_client_info_alloca( &cinfo );
  snd_seq_port_info_alloca( &pinfo );

  std::string stringName;
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  if ( portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE, (int) portNumber ) ) {
    int cnum = snd_seq_port_info_get_client(pinfo);
    snd_seq_get_any_client_info( data->seq, cnum, cinfo );
    std::ostringstream os;
    os << snd_seq_client_info_get_name(cinfo);
    os << ":";
    os << snd_seq_port_info_get_name( pinfo );
    os << " ";                                    // These lines added to make sure devices are listed
    os << snd_seq_port_info_get_client( pinfo );  // with full portnames added to ensure individual device names
    os << ":";
    os << snd_seq_port_info_get_port(pinfo);
    stringName = os.str();
    return stringName;
  }

  // If we get here, we didn't find a match.
  errorString_ = "MidiOutAlsa::getPortName: error looking for port name!";
  error( RtMidiError::WARNING, errorString_ );
  return stringName;
}

void MidiOutAlsa :: openPort( unsigned int portNumber, const std::string &portName )
{
  if ( connected_ ) {
    errorString_ = "MidiOutAlsa::openPort: a valid connection already exists!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  unsigned int nSrc = this->getPortCount();
  if (nSrc < 1) {
    errorString_ = "MidiOutAlsa::openPort: no MIDI output sources found!";
    error( RtMidiError::NO_DEVICES_FOUND, errorString_ );
    return;
  }

	snd_seq_port_info_t *pinfo;
	snd_seq_port_info_alloca( &pinfo );
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  if ( portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE, (int) portNumber ) == 0 ) {
    std::ostringstream ost;
    ost << "MidiOutAlsa::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::INVALID_PARAMETER, errorString_ );
    return;
  }

  snd_seq_addr_t sender, receiver;
  receiver.client = snd_seq_port_info_get_client( pinfo );
  receiver.port = snd_seq_port_info_get_port( pinfo );
  sender.client = snd_seq_client_id( data->seq );

  if ( data->vport < 0 ) {
    data->vport = snd_seq_create_simple_port( data->seq, portName.c_str(),
                                              SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ,
                                              SND_SEQ_PORT_TYPE_MIDI_GENERIC|SND_SEQ_PORT_TYPE_APPLICATION );
    if ( data->vport < 0 ) {
      errorString_ = "MidiOutAlsa::openPort: ALSA error creating output port.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }
  }

  sender.port = data->vport;

  // Make subscription
  if (snd_seq_port_subscribe_malloc( &data->subscription ) < 0) {
    snd_seq_port_subscribe_free( data->subscription );
    errorString_ = "MidiOutAlsa::openPort: error allocating port subscription.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }
  snd_seq_port_subscribe_set_sender(data->subscription, &sender);
  snd_seq_port_subscribe_set_dest(data->subscription, &receiver);
  snd_seq_port_subscribe_set_time_update(data->subscription, 1);
  snd_seq_port_subscribe_set_time_real(data->subscription, 1);
  if ( snd_seq_subscribe_port(data->seq, data->subscription) ) {
    snd_seq_port_subscribe_free( data->subscription );
    errorString_ = "MidiOutAlsa::openPort: ALSA error making port connection.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  connected_ = true;
}

void MidiOutAlsa :: closePort( void )
{
  if ( connected_ ) {
    AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
    snd_seq_unsubscribe_port( data->seq, data->subscription );
    snd_seq_port_subscribe_free( data->subscription );
    data->subscription = 0;
    connected_ = false;
  }
}

void MidiOutAlsa :: openVirtualPort( const std::string &portName )
{
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  if ( data->vport < 0 ) {
    data->vport = snd_seq_create_simple_port( data->seq, portName.c_str(),
                                              SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ,
                                              SND_SEQ_PORT_TYPE_MIDI_GENERIC|SND_SEQ_PORT_TYPE_APPLICATION );

    if ( data->vport < 0 ) {
      errorString_ = "MidiOutAlsa::openVirtualPort: ALSA error creating virtual port.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
    }
  }
}

void MidiOutAlsa :: sendMessage( const unsigned char *message, size_t size )
{
  int result;
  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
  unsigned int nBytes = static_cast<unsigned int> (size);
  if ( nBytes > data->bufferSize ) {
    data->bufferSize = nBytes;
    result = snd_midi_event_resize_buffer ( data->coder, nBytes);
    if ( result != 0 ) {
      errorString_ = "MidiOutAlsa::sendMessage: ALSA error resizing MIDI event buffer.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }
    free (data->buffer);
    data->buffer = (unsigned char *) malloc( data->bufferSize );
    if ( data->buffer == NULL ) {
    errorString_ = "MidiOutAlsa::initialize: error allocating buffer memory!\n\n";
    error( RtMidiError::MEMORY_ERROR, errorString_ );
    return;
    }
  }

  snd_seq_event_t ev;
  snd_seq_ev_clear(&ev);
  snd_seq_ev_set_source(&ev, data->vport);
  snd_seq_ev_set_subs(&ev);
  snd_seq_ev_set_direct(&ev);
  for ( unsigned int i=0; i<nBytes; ++i ) data->buffer[i] = message[i];
  result = snd_midi_event_encode( data->coder, data->buffer, (long)nBytes, &ev );
  if ( result < (int)nBytes ) {
    errorString_ = "MidiOutAlsa::sendMessage: event parsing error!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  // Send the event.
  result = snd_seq_event_output(data->seq, &ev);
  if ( result < 0 ) {
    errorString_ = "MidiOutAlsa::sendMessage: error sending MIDI message to port.";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }
  snd_seq_drain_output(data->seq);
}

#endif // __LINUX_ALSA__


//*********************************************************************//
//  API: Windows Multimedia Library (MM)
//*********************************************************************//

// API information deciphered from:
//  - http://msdn.microsoft.com/library/default.asp?url=/library/en-us/multimed/htm/_win32_midi_reference.asp

// Thanks to Jean-Baptiste Berruchon for the sysex code.

#if defined(__WINDOWS_MM__)

// The Windows MM API is based on the use of a callback function for
// MIDI input.  We convert the system specific time stamps to delta
// time values.

// Windows MM MIDI header files.
#include <windows.h>
#include <mmsystem.h>

// Convert a null-terminated wide string or ANSI-encoded string to UTF-8.
static std::string ConvertToUTF8(const TCHAR *str)
{
  std::string u8str;
  const WCHAR *wstr = L"";
#if defined( UNICODE ) || defined( _UNICODE )
  wstr = str;
#else
  // Convert from ANSI encoding to wide string
  int wlength = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
  std::wstring wstrtemp;
  if ( wlength )
  {
    wstrtemp.assign( wlength - 1, 0 );
    MultiByteToWideChar( CP_ACP, 0, str, -1, &wstrtemp[0], wlength );
    wstr = &wstrtemp[0];
  }
#endif
  // Convert from wide string to UTF-8
  int length = WideCharToMultiByte( CP_UTF8, 0, wstr, -1, NULL, 0, NULL, NULL );
  if ( length )
  {
    u8str.assign( length - 1, 0 );
    length = WideCharToMultiByte( CP_UTF8, 0, wstr, -1, &u8str[0], length, NULL, NULL );
  }
  return u8str;
}

#define  RT_SYSEX_BUFFER_SIZE 1024
#define  RT_SYSEX_BUFFER_COUNT 4

// A structure to hold variables related to the CoreMIDI API
// implementation.
struct WinMidiData {
  HMIDIIN inHandle;    // Handle to Midi Input Device
  HMIDIOUT outHandle;  // Handle to Midi Output Device
  DWORD lastTime;
  MidiInApi::MidiMessage message;
  LPMIDIHDR sysexBuffer[RT_SYSEX_BUFFER_COUNT];
  CRITICAL_SECTION _mutex; // [Patrice] see https://groups.google.com/forum/#!topic/mididev/6OUjHutMpEo
};

//*********************************************************************//
//  API: Windows MM
//  Class Definitions: MidiInWinMM
//*********************************************************************//

static void CALLBACK midiInputCallback( HMIDIIN /*hmin*/,
                                        UINT inputStatus, 
                                        DWORD_PTR instancePtr,
                                        DWORD_PTR midiMessage,
                                        DWORD timestamp )
{
  if ( inputStatus != MIM_DATA && inputStatus != MIM_LONGDATA && inputStatus != MIM_LONGERROR ) return;

  //MidiInApi::RtMidiInData *data = static_cast<MidiInApi::RtMidiInData *> (instancePtr);
  MidiInApi::RtMidiInData *data = (MidiInApi::RtMidiInData *)instancePtr;
  WinMidiData *apiData = static_cast<WinMidiData *> (data->apiData);

  /*
  // Calculate time stamp.
  if ( data->firstMessage == true ) {
    apiData->message.timeStamp = 0.0;
    data->firstMessage = false;
  }
  else apiData->message.timeStamp = (double) ( timestamp - apiData->lastTime ) * 0.001;
  apiData->lastTime = timestamp;
  */
    
  // 10/02/19: absolute usec based time stamp
  apiData->message.timeStamp = double(timestamp) * 1000;

  if ( inputStatus == MIM_DATA ) { // Channel or system message

    // Make sure the first byte is a status byte.
    unsigned char status = (unsigned char) (midiMessage & 0x000000FF);
    if ( !(status & 0x80) ) return;

    // Determine the number of bytes in the MIDI message.
    unsigned short nBytes = 1;
    if ( status < 0xC0 ) nBytes = 3;
    else if ( status < 0xE0 ) nBytes = 2;
    else if ( status < 0xF0 ) nBytes = 3;
    else if ( status == 0xF1 ) {
      if ( data->ignoreFlags & 0x02 ) return;
      else nBytes = 2;
    }
    else if ( status == 0xF2 ) nBytes = 3;
    else if ( status == 0xF3 ) nBytes = 2;
    else if ( status == 0xF8 && (data->ignoreFlags & 0x02) ) {
      // A MIDI timing tick message and we're ignoring it.
      return;
    }
    else if ( status == 0xFE && (data->ignoreFlags & 0x04) ) {
      // A MIDI active sensing message and we're ignoring it.
      return;
    }

    // Copy bytes to our MIDI message.
    unsigned char *ptr = (unsigned char *) &midiMessage;
    for ( int i=0; i<nBytes; ++i ) apiData->message.bytes.push_back( *ptr++ );
  }
  else { // Sysex message ( MIM_LONGDATA or MIM_LONGERROR )
    MIDIHDR *sysex = ( MIDIHDR *) midiMessage; 
    if ( !( data->ignoreFlags & 0x01 ) && inputStatus != MIM_LONGERROR ) {  
      // Sysex message and we're not ignoring it
      for ( int i=0; i<(int)sysex->dwBytesRecorded; ++i )
        apiData->message.bytes.push_back( sysex->lpData[i] );
    }

    // The WinMM API requires that the sysex buffer be requeued after
    // input of each sysex message.  Even if we are ignoring sysex
    // messages, we still need to requeue the buffer in case the user
    // decides to not ignore sysex messages in the future.  However,
    // it seems that WinMM calls this function with an empty sysex
    // buffer when an application closes and in this case, we should
    // avoid requeueing it, else the computer suddenly reboots after
    // one or two minutes.
    if ( apiData->sysexBuffer[sysex->dwUser]->dwBytesRecorded > 0 ) {
      //if ( sysex->dwBytesRecorded > 0 ) {
      EnterCriticalSection( &(apiData->_mutex) );
      MMRESULT result = midiInAddBuffer( apiData->inHandle, apiData->sysexBuffer[sysex->dwUser], sizeof(MIDIHDR) );
      LeaveCriticalSection( &(apiData->_mutex) );
      if ( result != MMSYSERR_NOERROR )
        std::cerr << "\nRtMidiIn::midiInputCallback: error sending sysex to Midi device!!\n\n";

      if ( data->ignoreFlags & 0x01 ) return;
    }
    else return;
  }

  if ( data->usingCallback ) {
    RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
    callback( apiData->message.timeStamp, &apiData->message.bytes, data->userData );
  }
  else {
    // As long as we haven't reached our queue size limit, push the message.
    if (!data->queue.push(apiData->message))
      std::cerr << "\nMidiInWinMM: message queue limit reached!!\n\n";
  }

  // Clear the vector for the next input message.
  apiData->message.bytes.clear();
}

MidiInWinMM :: MidiInWinMM( const std::string &clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit )
{
  initialize( clientName );
}

MidiInWinMM :: ~MidiInWinMM()
{
  // Close a connection if it exists.
  closePort();

  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
  DeleteCriticalSection( &(data->_mutex) );

  // Cleanup.
  delete data;
}

void MidiInWinMM :: initialize( const std::string& /*clientName*/ )
{
  // We'll issue a warning here if no devices are available but not
  // throw an error since the user can plugin something later.
  unsigned int nDevices = midiInGetNumDevs();
  if ( nDevices == 0 ) {
    errorString_ = "MidiInWinMM::initialize: no MIDI input devices currently available.";
    error( RtMidiError::WARNING, errorString_ );
  }

  // Save our api-specific connection information.
  WinMidiData *data = (WinMidiData *) new WinMidiData;
  apiData_ = (void *) data;
  inputData_.apiData = (void *) data;
  data->message.bytes.clear();  // needs to be empty for first input message

  if ( !InitializeCriticalSectionAndSpinCount(&(data->_mutex), 0x00000400) ) {
    errorString_ = "MidiInWinMM::initialize: InitializeCriticalSectionAndSpinCount failed.";
    error( RtMidiError::WARNING, errorString_ );
  }
}

void MidiInWinMM :: openPort( unsigned int portNumber, const std::string &/*portName*/ )
{
  if ( connected_ ) {
    errorString_ = "MidiInWinMM::openPort: a valid connection already exists!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  unsigned int nDevices = midiInGetNumDevs();
  if (nDevices == 0) {
    errorString_ = "MidiInWinMM::openPort: no MIDI input sources found!";
    error( RtMidiError::NO_DEVICES_FOUND, errorString_ );
    return;
  }

  if ( portNumber >= nDevices ) {
    std::ostringstream ost;
    ost << "MidiInWinMM::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::INVALID_PARAMETER, errorString_ );
    return;
  }

  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
  MMRESULT result = midiInOpen( &data->inHandle,
                                portNumber,
                                (DWORD_PTR)&midiInputCallback,
                                (DWORD_PTR)&inputData_,
                                CALLBACK_FUNCTION );
  if ( result != MMSYSERR_NOERROR ) {
    errorString_ = "MidiInWinMM::openPort: error creating Windows MM MIDI input port.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Allocate and init the sysex buffers.
  for ( int i=0; i<RT_SYSEX_BUFFER_COUNT; ++i ) {
    data->sysexBuffer[i] = (MIDIHDR*) new char[ sizeof(MIDIHDR) ];
    data->sysexBuffer[i]->lpData = new char[ RT_SYSEX_BUFFER_SIZE ];
    data->sysexBuffer[i]->dwBufferLength = RT_SYSEX_BUFFER_SIZE;
    data->sysexBuffer[i]->dwUser = i; // We use the dwUser parameter as buffer indicator
    data->sysexBuffer[i]->dwFlags = 0;

    result = midiInPrepareHeader( data->inHandle, data->sysexBuffer[i], sizeof(MIDIHDR) );
    if ( result != MMSYSERR_NOERROR ) {
      midiInClose( data->inHandle );
      data->inHandle = 0;
      errorString_ = "MidiInWinMM::openPort: error starting Windows MM MIDI input port (PrepareHeader).";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }

    // Register the buffer.
    result = midiInAddBuffer( data->inHandle, data->sysexBuffer[i], sizeof(MIDIHDR) );
    if ( result != MMSYSERR_NOERROR ) {
      midiInClose( data->inHandle );
      data->inHandle = 0;
      errorString_ = "MidiInWinMM::openPort: error starting Windows MM MIDI input port (AddBuffer).";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }
  }

  result = midiInStart( data->inHandle );
  if ( result != MMSYSERR_NOERROR ) {
    midiInClose( data->inHandle );
    data->inHandle = 0;
    errorString_ = "MidiInWinMM::openPort: error starting Windows MM MIDI input port.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  connected_ = true;
}

void MidiInWinMM :: openVirtualPort( const std::string &/*portName*/ )
{
  // This function cannot be implemented for the Windows MM MIDI API.
  errorString_ = "MidiInWinMM::openVirtualPort: cannot be implemented in Windows MM MIDI API!";
  error( RtMidiError::WARNING, errorString_ );
}

void MidiInWinMM :: closePort( void )
{
  if ( connected_ ) {
    WinMidiData *data = static_cast<WinMidiData *> (apiData_);
    EnterCriticalSection( &(data->_mutex) );
    midiInReset( data->inHandle );
    midiInStop( data->inHandle );

    for ( int i=0; i<RT_SYSEX_BUFFER_COUNT; ++i ) {
      int result = midiInUnprepareHeader(data->inHandle, data->sysexBuffer[i], sizeof(MIDIHDR));
      delete [] data->sysexBuffer[i]->lpData;
      delete [] data->sysexBuffer[i];
      if ( result != MMSYSERR_NOERROR ) {
        midiInClose( data->inHandle );
        data->inHandle = 0;
        errorString_ = "MidiInWinMM::openPort: error closing Windows MM MIDI input port (midiInUnprepareHeader).";
        error( RtMidiError::DRIVER_ERROR, errorString_ );
        return;
      }
    }

    midiInClose( data->inHandle );
    data->inHandle = 0;
    connected_ = false;
    LeaveCriticalSection( &(data->_mutex) );
  }
}

unsigned int MidiInWinMM :: getPortCount()
{
  return midiInGetNumDevs();
}

std::string MidiInWinMM :: getPortName( unsigned int portNumber )
{
  std::string stringName;
  unsigned int nDevices = midiInGetNumDevs();
  if ( portNumber >= nDevices ) {
    std::ostringstream ost;
    ost << "MidiInWinMM::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::WARNING, errorString_ );
    return stringName;
  }

  MIDIINCAPS deviceCaps;
  midiInGetDevCaps( portNumber, &deviceCaps, sizeof(MIDIINCAPS));
  stringName = ConvertToUTF8( deviceCaps.szPname );

  // Next lines added to add the portNumber to the name so that 
  // the device's names are sure to be listed with individual names
  // even when they have the same brand name
#ifdef RTMIDI_ENSURE_UNIQUE_PORTNAMES
  std::ostringstream os;
  os << " ";
  os << portNumber;
  stringName += os.str();
#endif

  return stringName;
}

//*********************************************************************//
//  API: Windows MM
//  Class Definitions: MidiOutWinMM
//*********************************************************************//

MidiOutWinMM :: MidiOutWinMM( const std::string &clientName ) : MidiOutApi()
{
  initialize( clientName );
}

MidiOutWinMM :: ~MidiOutWinMM()
{
  // Close a connection if it exists.
  closePort();

  // Cleanup.
  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
  delete data;
}

void MidiOutWinMM :: initialize( const std::string& /*clientName*/ )
{
  // We'll issue a warning here if no devices are available but not
  // throw an error since the user can plug something in later.
  unsigned int nDevices = midiOutGetNumDevs();
  if ( nDevices == 0 ) {
    errorString_ = "MidiOutWinMM::initialize: no MIDI output devices currently available.";
    error( RtMidiError::WARNING, errorString_ );
  }

  // Save our api-specific connection information.
  WinMidiData *data = (WinMidiData *) new WinMidiData;
  apiData_ = (void *) data;
}

unsigned int MidiOutWinMM :: getPortCount()
{
  return midiOutGetNumDevs();
}

std::string MidiOutWinMM :: getPortName( unsigned int portNumber )
{
  std::string stringName;
  unsigned int nDevices = midiOutGetNumDevs();
  if ( portNumber >= nDevices ) {
    std::ostringstream ost;
    ost << "MidiOutWinMM::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::WARNING, errorString_ );
    return stringName;
  }

  MIDIOUTCAPS deviceCaps;
  midiOutGetDevCaps( portNumber, &deviceCaps, sizeof(MIDIOUTCAPS));
  stringName = ConvertToUTF8( deviceCaps.szPname );

  // Next lines added to add the portNumber to the name so that 
  // the device's names are sure to be listed with individual names
  // even when they have the same brand name
  std::ostringstream os;
#ifdef RTMIDI_ENSURE_UNIQUE_PORTNAMES
  os << " ";
  os << portNumber;
  stringName += os.str();
#endif

  return stringName;
}

void MidiOutWinMM :: openPort( unsigned int portNumber, const std::string &/*portName*/ )
{
  if ( connected_ ) {
    errorString_ = "MidiOutWinMM::openPort: a valid connection already exists!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  unsigned int nDevices = midiOutGetNumDevs();
  if (nDevices < 1) {
    errorString_ = "MidiOutWinMM::openPort: no MIDI output destinations found!";
    error( RtMidiError::NO_DEVICES_FOUND, errorString_ );
    return;
  }

  if ( portNumber >= nDevices ) {
    std::ostringstream ost;
    ost << "MidiOutWinMM::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::INVALID_PARAMETER, errorString_ );
    return;
  }

  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
  MMRESULT result = midiOutOpen( &data->outHandle,
                                 portNumber,
                                 (DWORD)NULL,
                                 (DWORD)NULL,
                                 CALLBACK_NULL );
  if ( result != MMSYSERR_NOERROR ) {
    errorString_ = "MidiOutWinMM::openPort: error creating Windows MM MIDI output port.";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  connected_ = true;
}

void MidiOutWinMM :: closePort( void )
{
  if ( connected_ ) {
    WinMidiData *data = static_cast<WinMidiData *> (apiData_);
    midiOutReset( data->outHandle );
    midiOutClose( data->outHandle );
    data->outHandle = 0;
    connected_ = false;
  }
}

void MidiOutWinMM :: openVirtualPort( const std::string &/*portName*/ )
{
  // This function cannot be implemented for the Windows MM MIDI API.
  errorString_ = "MidiOutWinMM::openVirtualPort: cannot be implemented in Windows MM MIDI API!";
  error( RtMidiError::WARNING, errorString_ );
}

void MidiOutWinMM :: sendMessage( const unsigned char *message, size_t size )
{
  if ( !connected_ ) return;

  unsigned int nBytes = static_cast<unsigned int>(size);
  if ( nBytes == 0 ) {
    errorString_ = "MidiOutWinMM::sendMessage: message argument is empty!";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  MMRESULT result;
  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
  if ( message[0] == 0xF0 ) { // Sysex message

    // Allocate buffer for sysex data.
    char *buffer = (char *) malloc( nBytes );
    if ( buffer == NULL ) {
      errorString_ = "MidiOutWinMM::sendMessage: error allocating sysex message memory!";
      error( RtMidiError::MEMORY_ERROR, errorString_ );
      return;
    }

    // Copy data to buffer.
    for ( unsigned int i=0; i<nBytes; ++i ) buffer[i] = message[i];

    // Create and prepare MIDIHDR structure.
    MIDIHDR sysex;
    sysex.lpData = (LPSTR) buffer;
    sysex.dwBufferLength = nBytes;
    sysex.dwFlags = 0;
    result = midiOutPrepareHeader( data->outHandle,  &sysex, sizeof(MIDIHDR) ); 
    if ( result != MMSYSERR_NOERROR ) {
      free( buffer );
      errorString_ = "MidiOutWinMM::sendMessage: error preparing sysex header.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }

    // Send the message.
    result = midiOutLongMsg( data->outHandle, &sysex, sizeof(MIDIHDR) );
    if ( result != MMSYSERR_NOERROR ) {
      free( buffer );
      errorString_ = "MidiOutWinMM::sendMessage: error sending sysex message.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
      return;
    }

    // Unprepare the buffer and MIDIHDR.
    while ( MIDIERR_STILLPLAYING == midiOutUnprepareHeader( data->outHandle, &sysex, sizeof (MIDIHDR) ) ) Sleep( 1 );
    free( buffer );
  }
  else { // Channel or system message.

    // Make sure the message size isn't too big.
    if ( nBytes > 3 ) {
      errorString_ = "MidiOutWinMM::sendMessage: message size is greater than 3 bytes (and not sysex)!";
      error( RtMidiError::WARNING, errorString_ );
      return;
    }

    // Pack MIDI bytes into double word.
    DWORD packet;
    unsigned char *ptr = (unsigned char *) &packet;
    for ( unsigned int i=0; i<nBytes; ++i ) {
      *ptr = message[i];
      ++ptr;
    }

    // Send the message immediately.
    result = midiOutShortMsg( data->outHandle, packet );
    if ( result != MMSYSERR_NOERROR ) {
      errorString_ = "MidiOutWinMM::sendMessage: error sending MIDI message.";
      error( RtMidiError::DRIVER_ERROR, errorString_ );
    }
  }
}

#endif  // __WINDOWS_MM__


//*********************************************************************//
//  API: UNIX JACK
//
//  Written primarily by Alexander Svetalkin, with updates for delta
//  time by Gary Scavone, April 2011.
//
//  *********************************************************************//

#if defined(__UNIX_JACK__)

// JACK header files
#include <jack/jack.h>
#include <jack/midiport.h>
#include <jack/ringbuffer.h>
#ifdef HAVE_SEMAPHORE
  #include <semaphore.h>
#endif

#define JACK_RINGBUFFER_SIZE 16384 // Default size for ringbuffer

struct JackMidiData {
  jack_client_t *client;
  jack_port_t *port;
  jack_ringbuffer_t *buffSize;
  jack_ringbuffer_t *buffMessage;
  jack_time_t lastTime;
#ifdef HAVE_SEMAPHORE
  sem_t sem_cleanup;
  sem_t sem_needpost;
#endif
  MidiInApi :: RtMidiInData *rtMidiIn;
  };

//*********************************************************************//
//  API: JACK
//  Class Definitions: MidiInJack
//*********************************************************************//

static int jackProcessIn( jack_nframes_t nframes, void *arg )
{
  JackMidiData *jData = (JackMidiData *) arg;
  MidiInApi :: RtMidiInData *rtData = jData->rtMidiIn;
  jack_midi_event_t event;
  jack_time_t time;

  // Is port created?
  if ( jData->port == NULL ) return 0;
  void *buff = jack_port_get_buffer( jData->port, nframes );

  // We have midi events in buffer
  int evCount = jack_midi_get_event_count( buff );
  for (int j = 0; j < evCount; j++) {
    MidiInApi::MidiMessage message;
    message.bytes.clear();

    jack_midi_event_get( &event, buff, j );

    for ( unsigned int i = 0; i < event.size; i++ )
      message.bytes.push_back( event.buffer[i] );

    // Compute the delta time.
    time = jack_get_time();
    if ( rtData->firstMessage == true )
      rtData->firstMessage = false;
    else
      message.timeStamp = ( time - jData->lastTime ) * 0.000001;

    jData->lastTime = time;

    if ( !rtData->continueSysex ) {
      if ( rtData->usingCallback ) {
        RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) rtData->userCallback;
        callback( message.timeStamp, &message.bytes, rtData->userData );
      }
      else {
        // As long as we haven't reached our queue size limit, push the message.
        if (!rtData->queue.push(message))
          std::cerr << "\nMidiInJack: message queue limit reached!!\n\n";
      }
    }
  }

  return 0;
}

MidiInJack :: MidiInJack( const std::string &clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit )
{
  initialize( clientName );
}

void MidiInJack :: initialize( const std::string& clientName )
{
  JackMidiData *data = new JackMidiData;
  apiData_ = (void *) data;

  data->rtMidiIn = &inputData_;
  data->port = NULL;
  data->client = NULL;
  this->clientName = clientName;

  connect();
}

void MidiInJack :: connect()
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
  if ( data->client )
    return;

  // Initialize JACK client
  if (( data->client = jack_client_open( clientName.c_str(), JackNoStartServer, NULL )) == 0) {
    errorString_ = "MidiInJack::initialize: JACK server not running?";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  jack_set_process_callback( data->client, jackProcessIn, data );
  jack_activate( data->client );
}

MidiInJack :: ~MidiInJack()
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
  closePort();

  if ( data->client )
    jack_client_close( data->client );
  delete data;
}

void MidiInJack :: openPort( unsigned int portNumber, const std::string &portName )
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);

  connect();

  // Creating new port
  if ( data->port == NULL)
    data->port = jack_port_register( data->client, portName.c_str(),
                                     JACK_DEFAULT_MIDI_TYPE, JackPortIsInput, 0 );

  if ( data->port == NULL) {
    errorString_ = "MidiInJack::openPort: JACK error creating port";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Connecting to the output
  std::string name = getPortName( portNumber );
  jack_connect( data->client, name.c_str(), jack_port_name( data->port ) );
}

void MidiInJack :: openVirtualPort( const std::string &portName )
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);

  connect();
  if ( data->port == NULL )
    data->port = jack_port_register( data->client, portName.c_str(),
                                     JACK_DEFAULT_MIDI_TYPE, JackPortIsInput, 0 );

  if ( data->port == NULL ) {
    errorString_ = "MidiInJack::openVirtualPort: JACK error creating virtual port";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
  }
}

unsigned int MidiInJack :: getPortCount()
{
  int count = 0;
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
  connect();
  if ( !data->client )
    return 0;

  // List of available ports
  const char **ports = jack_get_ports( data->client, NULL, JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput );

  if ( ports == NULL ) return 0;
  while ( ports[count] != NULL )
    count++;

  free( ports );

  return count;
}

std::string MidiInJack :: getPortName( unsigned int portNumber )
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
  std::string retStr("");

  connect();

  // List of available ports
  const char **ports = jack_get_ports( data->client, NULL,
                                       JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput );

  // Check port validity
  if ( ports == NULL ) {
    errorString_ = "MidiInJack::getPortName: no ports available!";
    error( RtMidiError::WARNING, errorString_ );
    return retStr;
  }

  if ( ports[portNumber] == NULL ) {
    std::ostringstream ost;
    ost << "MidiInJack::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::WARNING, errorString_ );
  }
  else retStr.assign( ports[portNumber] );

  free( ports );
  return retStr;
}

void MidiInJack :: closePort()
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);

  if ( data->port == NULL ) return;
  jack_port_unregister( data->client, data->port );
  data->port = NULL;
}

//*********************************************************************//
//  API: JACK
//  Class Definitions: MidiOutJack
//*********************************************************************//

// Jack process callback
static int jackProcessOut( jack_nframes_t nframes, void *arg )
{
  JackMidiData *data = (JackMidiData *) arg;
  jack_midi_data_t *midiData;
  int space;

  // Is port created?
  if ( data->port == NULL ) return 0;

  void *buff = jack_port_get_buffer( data->port, nframes );
  jack_midi_clear_buffer( buff );

  while ( jack_ringbuffer_read_space( data->buffSize ) > 0 ) {
    jack_ringbuffer_read( data->buffSize, (char *) &space, (size_t) sizeof(space) );
    midiData = jack_midi_event_reserve( buff, 0, space );

    jack_ringbuffer_read( data->buffMessage, (char *) midiData, (size_t) space );
  }

#ifdef HAVE_SEMAPHORE
  if (!sem_trywait(&data->sem_needpost))
    sem_post(&data->sem_cleanup);
#endif

  return 0;
}

MidiOutJack :: MidiOutJack( const std::string &clientName ) : MidiOutApi()
{
  initialize( clientName );
}

void MidiOutJack :: initialize( const std::string& clientName )
{
  JackMidiData *data = new JackMidiData;
  apiData_ = (void *) data;

  data->port = NULL;
  data->client = NULL;
#ifdef HAVE_SEMAPHORE
  sem_init(&data->sem_cleanup, 0, 0);
  sem_init(&data->sem_needpost, 0, 0);
#endif
  this->clientName = clientName;

  connect();
}

void MidiOutJack :: connect()
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
  if ( data->client )
    return;
  
  // Initialize output ringbuffers  
  data->buffSize = jack_ringbuffer_create( JACK_RINGBUFFER_SIZE );
  data->buffMessage = jack_ringbuffer_create( JACK_RINGBUFFER_SIZE );

  // Initialize JACK client
  if (( data->client = jack_client_open( clientName.c_str(), JackNoStartServer, NULL )) == 0) {
    errorString_ = "MidiOutJack::initialize: JACK server not running?";
    error( RtMidiError::WARNING, errorString_ );
    return;
  }

  jack_set_process_callback( data->client, jackProcessOut, data );
  jack_activate( data->client );
}

MidiOutJack :: ~MidiOutJack()
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
  closePort();
  
  // Cleanup
  jack_ringbuffer_free( data->buffSize );
  jack_ringbuffer_free( data->buffMessage );
  if ( data->client ) {
    jack_client_close( data->client );
  }

#ifdef HAVE_SEMAPHORE
  sem_destroy(&data->sem_cleanup);
  sem_destroy(&data->sem_needpost);
#endif

  delete data;
}

void MidiOutJack :: openPort( unsigned int portNumber, const std::string &portName )
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);

  connect();

  // Creating new port
  if ( data->port == NULL )
    data->port = jack_port_register( data->client, portName.c_str(),
      JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput, 0 );

  if ( data->port == NULL ) {
    errorString_ = "MidiOutJack::openPort: JACK error creating port";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
    return;
  }

  // Connecting to the output
  std::string name = getPortName( portNumber );
  jack_connect( data->client, jack_port_name( data->port ), name.c_str() );
}

void MidiOutJack :: openVirtualPort( const std::string &portName )
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);

  connect();
  if ( data->port == NULL )
    data->port = jack_port_register( data->client, portName.c_str(),
      JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput, 0 );

  if ( data->port == NULL ) {
    errorString_ = "MidiOutJack::openVirtualPort: JACK error creating virtual port";
    error( RtMidiError::DRIVER_ERROR, errorString_ );
  }
}

unsigned int MidiOutJack :: getPortCount()
{
  int count = 0;
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
  connect();
  if ( !data->client )
    return 0;

  // List of available ports
  const char **ports = jack_get_ports( data->client, NULL,
    JACK_DEFAULT_MIDI_TYPE, JackPortIsInput );

  if ( ports == NULL ) return 0;
  while ( ports[count] != NULL )
    count++;

  free( ports );

  return count;
}

std::string MidiOutJack :: getPortName( unsigned int portNumber )
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
  std::string retStr("");

  connect();

  // List of available ports
  const char **ports = jack_get_ports( data->client, NULL,
    JACK_DEFAULT_MIDI_TYPE, JackPortIsInput );

  // Check port validity
  if ( ports == NULL) {
    errorString_ = "MidiOutJack::getPortName: no ports available!";
    error( RtMidiError::WARNING, errorString_ );
    return retStr;
  }

  if ( ports[portNumber] == NULL) {
    std::ostringstream ost;
    ost << "MidiOutJack::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
    errorString_ = ost.str();
    error( RtMidiError::WARNING, errorString_ );
  }
  else retStr.assign( ports[portNumber] );

  free( ports );
  return retStr;
}

void MidiOutJack :: closePort()
{
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);

  if ( data->port == NULL ) return;

#ifdef HAVE_SEMAPHORE
  struct timespec ts;
  if (clock_gettime(CLOCK_REALTIME, &ts) != -1)
  {
    ts.tv_sec += 1; // wait max one second
    sem_post(&data->sem_needpost);
    sem_timedwait(&data->sem_cleanup, &ts);
  }
#endif

  jack_port_unregister( data->client, data->port );
  data->port = NULL;
}

void MidiOutJack :: sendMessage( const unsigned char *message, size_t size )
{
  int nBytes = static_cast<int>(size);
  JackMidiData *data = static_cast<JackMidiData *> (apiData_);

  // Write full message to buffer
  jack_ringbuffer_write( data->buffMessage, ( const char * ) message,
                         nBytes );
  jack_ringbuffer_write( data->buffSize, ( char * ) &nBytes, sizeof( nBytes ) );
}

#endif  // __UNIX_JACK__
#endif

/******************************************************************************
 *******************************************************************************
 
 VECTOR INTRINSICS
 
 *******************************************************************************
 *******************************************************************************/


/********************END ARCHITECTURE SECTION (part 1/2)****************/

/**************************BEGIN USER SECTION **************************/

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

/* link with : "" */
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <math.h>

#ifndef FAUSTCLASS 
#define FAUSTCLASS mydsp
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif

static double mydsp_faustpower3_f(double value) {
	return value * value * value;
}

class mydsp : public dsp {
	
 private:
	
	int iVec0[2];
	int fSampleRate;
	double fConst0;
	double fConst1;
	double fConst2;
	FAUSTFLOAT fHslider0;
	double fConst3;
	double fRec1[2];
	FAUSTFLOAT fVslider0;
	FAUSTFLOAT fHslider1;
	double fRec13[2];
	FAUSTFLOAT fCheckbox0;
	double fRec18[2];
	int iVec1[2];
	int iVec2[2];
	int iRec19[2];
	double fRec17[2];
	int IOTA0;
	double fVec3[2048];
	double fRec16[2];
	double fConst4;
	double fRec14[2];
	double fRec15[2];
	FAUSTFLOAT fVbargraph0;
	FAUSTFLOAT fHslider2;
	double fRec21[2];
	double fRec26[2];
	int iVec4[2];
	int iRec27[2];
	double fRec25[2];
	double fRec24[2];
	double fRec22[2];
	double fRec23[2];
	FAUSTFLOAT fVbargraph1;
	double fRec20[2];
	FAUSTFLOAT fHslider3;
	double fRec28[2];
	double fRec33[2];
	int iVec5[2];
	int iRec34[2];
	double fRec32[2];
	double fRec31[2];
	double fRec29[2];
	double fRec30[2];
	FAUSTFLOAT fVbargraph2;
	double fVec6[2];
	double fRec11[2];
	double fConst5;
	FAUSTFLOAT fHslider4;
	double fRec38[2];
	double fRec43[2];
	int iVec7[2];
	int iRec44[2];
	double fRec42[2];
	double fRec41[2];
	double fRec39[2];
	double fRec40[2];
	FAUSTFLOAT fVbargraph3;
	FAUSTFLOAT fHslider5;
	double fRec45[2];
	double fRec50[2];
	int iVec8[2];
	int iRec51[2];
	double fRec49[2];
	double fRec48[2];
	double fRec46[2];
	double fRec47[2];
	FAUSTFLOAT fVbargraph4;
	double fRec52[2];
	FAUSTFLOAT fHslider6;
	double fRec53[2];
	double fRec58[2];
	int iVec9[2];
	int iRec59[2];
	double fRec57[2];
	double fRec56[2];
	double fRec54[2];
	double fRec55[2];
	FAUSTFLOAT fVbargraph5;
	FAUSTFLOAT fHslider7;
	double fRec60[2];
	double fRec65[2];
	int iVec10[2];
	int iRec66[2];
	double fRec64[2];
	double fRec63[2];
	double fRec61[2];
	double fRec62[2];
	FAUSTFLOAT fVbargraph6;
	double fRec35[2];
	double fRec36[2];
	double fRec67[2];
	double fRec68[2];
	double fRec70[2];
	double fRec71[2];
	double fRec73[2];
	double fRec74[2];
	double fRec76[2];
	double fRec77[2];
	double fRec79[2];
	double fRec80[2];
	double fRec82[2];
	double fRec83[2];
	double fRec85[2];
	double fRec86[2];
	double fRec88[2];
	double fRec89[2];
	double fRec91[2];
	double fRec92[2];
	double fRec94[2];
	double fRec95[2];
	double fRec97[2];
	double fRec98[2];
	double fRec100[2];
	double fRec101[2];
	double fRec103[2];
	double fRec104[2];
	double fRec106[2];
	double fRec107[2];
	double fRec109[2];
	double fRec110[2];
	double fRec112[2];
	double fRec113[2];
	double fRec115[2];
	double fRec116[2];
	double fRec118[2];
	double fRec119[2];
	double fRec121[2];
	double fRec122[2];
	double fRec124[2];
	double fRec125[2];
	double fRec127[2];
	double fRec128[2];
	double fRec130[2];
	double fRec131[2];
	double fRec133[2];
	double fRec134[2];
	double fRec136[2];
	double fRec137[2];
	double fRec139[2];
	double fRec140[2];
	double fRec142[2];
	double fRec143[2];
	double fRec145[2];
	double fRec146[2];
	double fRec148[2];
	double fRec149[2];
	double fRec151[2];
	double fRec152[2];
	double fRec154[2];
	double fRec155[2];
	double fRec157[2];
	double fRec158[2];
	double fRec12[2];
	double fRec3[2];
	double fRec166[2];
	int iVec11[2];
	int iRec167[2];
	double fRec165[2];
	double fRec164[2];
	double fRec162[2];
	double fRec163[2];
	FAUSTFLOAT fVbargraph7;
	double fRec173[2];
	int iVec12[2];
	int iRec174[2];
	double fRec172[2];
	double fRec171[2];
	double fRec169[2];
	double fRec170[2];
	FAUSTFLOAT fVbargraph8;
	double fRec168[2];
	double fRec179[2];
	int iVec13[2];
	int iRec180[2];
	double fRec178[2];
	double fRec177[2];
	double fRec175[2];
	double fRec176[2];
	FAUSTFLOAT fVbargraph9;
	double fVec14[2];
	double fRec160[2];
	double fRec188[2];
	int iVec15[2];
	int iRec189[2];
	double fRec187[2];
	double fRec186[2];
	double fRec184[2];
	double fRec185[2];
	FAUSTFLOAT fVbargraph10;
	double fRec194[2];
	int iVec16[2];
	int iRec195[2];
	double fRec193[2];
	double fRec192[2];
	double fRec190[2];
	double fRec191[2];
	FAUSTFLOAT fVbargraph11;
	double fRec196[2];
	double fRec201[2];
	int iRec202[2];
	double fRec200[2];
	double fRec199[2];
	double fRec197[2];
	double fRec198[2];
	FAUSTFLOAT fVbargraph12;
	double fRec207[2];
	int iVec17[2];
	int iRec208[2];
	double fRec206[2];
	double fRec205[2];
	double fRec203[2];
	double fRec204[2];
	FAUSTFLOAT fVbargraph13;
	double fRec181[2];
	double fRec182[2];
	double fRec209[2];
	double fRec210[2];
	double fRec212[2];
	double fRec213[2];
	double fRec215[2];
	double fRec216[2];
	double fRec218[2];
	double fRec219[2];
	double fRec221[2];
	double fRec222[2];
	double fRec224[2];
	double fRec225[2];
	double fRec227[2];
	double fRec228[2];
	double fRec230[2];
	double fRec231[2];
	double fRec233[2];
	double fRec234[2];
	double fRec236[2];
	double fRec237[2];
	double fRec239[2];
	double fRec240[2];
	double fRec242[2];
	double fRec243[2];
	double fRec245[2];
	double fRec246[2];
	double fRec248[2];
	double fRec249[2];
	double fRec251[2];
	double fRec252[2];
	double fRec254[2];
	double fRec255[2];
	double fRec257[2];
	double fRec258[2];
	double fRec260[2];
	double fRec261[2];
	double fRec263[2];
	double fRec264[2];
	double fRec266[2];
	double fRec267[2];
	double fRec269[2];
	double fRec270[2];
	double fRec272[2];
	double fRec273[2];
	double fRec275[2];
	double fRec276[2];
	double fRec278[2];
	double fRec279[2];
	double fRec281[2];
	double fRec282[2];
	double fRec284[2];
	double fRec285[2];
	double fRec287[2];
	double fRec288[2];
	double fRec290[2];
	double fRec291[2];
	double fRec293[2];
	double fRec294[2];
	double fRec296[2];
	double fRec297[2];
	double fRec299[2];
	double fRec300[2];
	double fRec161[2];
	double fRec4[2];
	double fRec308[2];
	int iVec18[2];
	int iRec309[2];
	double fRec307[2];
	double fRec306[2];
	double fRec304[2];
	double fRec305[2];
	FAUSTFLOAT fVbargraph14;
	double fRec315[2];
	int iVec19[2];
	int iRec316[2];
	double fRec314[2];
	double fRec313[2];
	double fRec311[2];
	double fRec312[2];
	FAUSTFLOAT fVbargraph15;
	double fRec310[2];
	double fRec321[2];
	int iVec20[2];
	int iRec322[2];
	double fRec320[2];
	double fRec319[2];
	double fRec317[2];
	double fRec318[2];
	FAUSTFLOAT fVbargraph16;
	double fVec21[2];
	double fRec302[2];
	double fRec330[2];
	int iVec22[2];
	int iRec331[2];
	double fRec329[2];
	double fRec328[2];
	double fRec326[2];
	double fRec327[2];
	FAUSTFLOAT fVbargraph17;
	double fRec336[2];
	int iVec23[2];
	int iRec337[2];
	double fRec335[2];
	double fRec334[2];
	double fRec332[2];
	double fRec333[2];
	FAUSTFLOAT fVbargraph18;
	double fRec338[2];
	double fRec343[2];
	int iVec24[2];
	int iRec344[2];
	double fRec342[2];
	double fRec341[2];
	double fRec339[2];
	double fRec340[2];
	FAUSTFLOAT fVbargraph19;
	double fRec349[2];
	int iVec25[2];
	int iRec350[2];
	double fRec348[2];
	double fRec347[2];
	double fRec345[2];
	double fRec346[2];
	FAUSTFLOAT fVbargraph20;
	double fRec323[2];
	double fRec324[2];
	double fRec351[2];
	double fRec352[2];
	double fRec354[2];
	double fRec355[2];
	double fRec357[2];
	double fRec358[2];
	double fRec360[2];
	double fRec361[2];
	double fRec363[2];
	double fRec364[2];
	double fRec366[2];
	double fRec367[2];
	double fRec369[2];
	double fRec370[2];
	double fRec372[2];
	double fRec373[2];
	double fRec375[2];
	double fRec376[2];
	double fRec378[2];
	double fRec379[2];
	double fRec381[2];
	double fRec382[2];
	double fRec384[2];
	double fRec385[2];
	double fRec387[2];
	double fRec388[2];
	double fRec390[2];
	double fRec391[2];
	double fRec393[2];
	double fRec394[2];
	double fRec396[2];
	double fRec397[2];
	double fRec399[2];
	double fRec400[2];
	double fRec402[2];
	double fRec403[2];
	double fRec405[2];
	double fRec406[2];
	double fRec408[2];
	double fRec409[2];
	double fRec411[2];
	double fRec412[2];
	double fRec414[2];
	double fRec415[2];
	double fRec417[2];
	double fRec418[2];
	double fRec420[2];
	double fRec421[2];
	double fRec423[2];
	double fRec424[2];
	double fRec426[2];
	double fRec427[2];
	double fRec429[2];
	double fRec430[2];
	double fRec432[2];
	double fRec433[2];
	double fRec435[2];
	double fRec436[2];
	double fRec438[2];
	double fRec439[2];
	double fRec441[2];
	double fRec442[2];
	double fRec303[2];
	double fRec5[2];
	double fRec450[2];
	int iVec26[2];
	int iRec451[2];
	double fRec449[2];
	double fRec448[2];
	double fRec446[2];
	double fRec447[2];
	FAUSTFLOAT fVbargraph21;
	double fRec457[2];
	int iVec27[2];
	int iRec458[2];
	double fRec456[2];
	double fRec455[2];
	double fRec453[2];
	double fRec454[2];
	FAUSTFLOAT fVbargraph22;
	double fRec452[2];
	double fRec463[2];
	int iVec28[2];
	int iRec464[2];
	double fRec462[2];
	double fRec461[2];
	double fRec459[2];
	double fRec460[2];
	FAUSTFLOAT fVbargraph23;
	double fVec29[2];
	double fRec444[2];
	double fRec472[2];
	int iVec30[2];
	int iRec473[2];
	double fRec471[2];
	double fRec470[2];
	double fRec468[2];
	double fRec469[2];
	FAUSTFLOAT fVbargraph24;
	double fRec478[2];
	int iVec31[2];
	int iRec479[2];
	double fRec477[2];
	double fRec476[2];
	double fRec474[2];
	double fRec475[2];
	FAUSTFLOAT fVbargraph25;
	double fRec480[2];
	double fRec485[2];
	int iVec32[2];
	int iRec486[2];
	double fRec484[2];
	double fRec483[2];
	double fRec481[2];
	double fRec482[2];
	FAUSTFLOAT fVbargraph26;
	double fRec491[2];
	int iVec33[2];
	int iRec492[2];
	double fRec490[2];
	double fRec489[2];
	double fRec487[2];
	double fRec488[2];
	FAUSTFLOAT fVbargraph27;
	double fRec465[2];
	double fRec466[2];
	double fRec493[2];
	double fRec494[2];
	double fRec496[2];
	double fRec497[2];
	double fRec499[2];
	double fRec500[2];
	double fRec502[2];
	double fRec503[2];
	double fRec505[2];
	double fRec506[2];
	double fRec508[2];
	double fRec509[2];
	double fRec511[2];
	double fRec512[2];
	double fRec514[2];
	double fRec515[2];
	double fRec517[2];
	double fRec518[2];
	double fRec520[2];
	double fRec521[2];
	double fRec523[2];
	double fRec524[2];
	double fRec526[2];
	double fRec527[2];
	double fRec529[2];
	double fRec530[2];
	double fRec532[2];
	double fRec533[2];
	double fRec535[2];
	double fRec536[2];
	double fRec538[2];
	double fRec539[2];
	double fRec541[2];
	double fRec542[2];
	double fRec544[2];
	double fRec545[2];
	double fRec547[2];
	double fRec548[2];
	double fRec550[2];
	double fRec551[2];
	double fRec553[2];
	double fRec554[2];
	double fRec556[2];
	double fRec557[2];
	double fRec559[2];
	double fRec560[2];
	double fRec562[2];
	double fRec563[2];
	double fRec565[2];
	double fRec566[2];
	double fRec568[2];
	double fRec569[2];
	double fRec571[2];
	double fRec572[2];
	double fRec574[2];
	double fRec575[2];
	double fRec577[2];
	double fRec578[2];
	double fRec580[2];
	double fRec581[2];
	double fRec583[2];
	double fRec584[2];
	double fRec445[2];
	double fRec6[2];
	double fRec592[2];
	int iVec34[2];
	int iRec593[2];
	double fRec591[2];
	double fRec590[2];
	double fRec588[2];
	double fRec589[2];
	FAUSTFLOAT fVbargraph28;
	double fRec599[2];
	int iVec35[2];
	int iRec600[2];
	double fRec598[2];
	double fRec597[2];
	double fRec595[2];
	double fRec596[2];
	FAUSTFLOAT fVbargraph29;
	double fRec594[2];
	double fRec605[2];
	int iVec36[2];
	int iRec606[2];
	double fRec604[2];
	double fRec603[2];
	double fRec601[2];
	double fRec602[2];
	FAUSTFLOAT fVbargraph30;
	double fVec37[2];
	double fRec586[2];
	double fRec614[2];
	int iVec38[2];
	int iRec615[2];
	double fRec613[2];
	double fRec612[2];
	double fRec610[2];
	double fRec611[2];
	FAUSTFLOAT fVbargraph31;
	double fRec620[2];
	int iVec39[2];
	int iRec621[2];
	double fRec619[2];
	double fRec618[2];
	double fRec616[2];
	double fRec617[2];
	FAUSTFLOAT fVbargraph32;
	double fRec622[2];
	double fRec627[2];
	int iVec40[2];
	int iRec628[2];
	double fRec626[2];
	double fRec625[2];
	double fRec623[2];
	double fRec624[2];
	FAUSTFLOAT fVbargraph33;
	double fRec633[2];
	int iVec41[2];
	int iRec634[2];
	double fRec632[2];
	double fRec631[2];
	double fRec629[2];
	double fRec630[2];
	FAUSTFLOAT fVbargraph34;
	double fRec607[2];
	double fRec608[2];
	double fRec635[2];
	double fRec636[2];
	double fRec638[2];
	double fRec639[2];
	double fRec641[2];
	double fRec642[2];
	double fRec644[2];
	double fRec645[2];
	double fRec647[2];
	double fRec648[2];
	double fRec650[2];
	double fRec651[2];
	double fRec653[2];
	double fRec654[2];
	double fRec656[2];
	double fRec657[2];
	double fRec659[2];
	double fRec660[2];
	double fRec662[2];
	double fRec663[2];
	double fRec665[2];
	double fRec666[2];
	double fRec668[2];
	double fRec669[2];
	double fRec671[2];
	double fRec672[2];
	double fRec674[2];
	double fRec675[2];
	double fRec677[2];
	double fRec678[2];
	double fRec680[2];
	double fRec681[2];
	double fRec683[2];
	double fRec684[2];
	double fRec686[2];
	double fRec687[2];
	double fRec689[2];
	double fRec690[2];
	double fRec692[2];
	double fRec693[2];
	double fRec695[2];
	double fRec696[2];
	double fRec698[2];
	double fRec699[2];
	double fRec701[2];
	double fRec702[2];
	double fRec704[2];
	double fRec705[2];
	double fRec707[2];
	double fRec708[2];
	double fRec710[2];
	double fRec711[2];
	double fRec713[2];
	double fRec714[2];
	double fRec716[2];
	double fRec717[2];
	double fRec719[2];
	double fRec720[2];
	double fRec722[2];
	double fRec723[2];
	double fRec725[2];
	double fRec726[2];
	double fRec587[2];
	double fRec7[2];
	double fRec734[2];
	int iVec42[2];
	int iRec735[2];
	double fRec733[2];
	double fRec732[2];
	double fRec730[2];
	double fRec731[2];
	FAUSTFLOAT fVbargraph35;
	double fRec741[2];
	int iVec43[2];
	int iRec742[2];
	double fRec740[2];
	double fRec739[2];
	double fRec737[2];
	double fRec738[2];
	FAUSTFLOAT fVbargraph36;
	double fRec736[2];
	double fRec747[2];
	int iVec44[2];
	int iRec748[2];
	double fRec746[2];
	double fRec745[2];
	double fRec743[2];
	double fRec744[2];
	FAUSTFLOAT fVbargraph37;
	double fVec45[2];
	double fRec728[2];
	double fRec756[2];
	int iVec46[2];
	int iRec757[2];
	double fRec755[2];
	double fRec754[2];
	double fRec752[2];
	double fRec753[2];
	FAUSTFLOAT fVbargraph38;
	double fRec762[2];
	int iVec47[2];
	int iRec763[2];
	double fRec761[2];
	double fRec760[2];
	double fRec758[2];
	double fRec759[2];
	FAUSTFLOAT fVbargraph39;
	double fRec764[2];
	double fRec769[2];
	int iVec48[2];
	int iRec770[2];
	double fRec768[2];
	double fRec767[2];
	double fRec765[2];
	double fRec766[2];
	FAUSTFLOAT fVbargraph40;
	double fRec775[2];
	int iVec49[2];
	int iRec776[2];
	double fRec774[2];
	double fRec773[2];
	double fRec771[2];
	double fRec772[2];
	FAUSTFLOAT fVbargraph41;
	double fRec749[2];
	double fRec750[2];
	double fRec777[2];
	double fRec778[2];
	double fRec780[2];
	double fRec781[2];
	double fRec783[2];
	double fRec784[2];
	double fRec786[2];
	double fRec787[2];
	double fRec789[2];
	double fRec790[2];
	double fRec792[2];
	double fRec793[2];
	double fRec795[2];
	double fRec796[2];
	double fRec798[2];
	double fRec799[2];
	double fRec801[2];
	double fRec802[2];
	double fRec804[2];
	double fRec805[2];
	double fRec807[2];
	double fRec808[2];
	double fRec810[2];
	double fRec811[2];
	double fRec813[2];
	double fRec814[2];
	double fRec816[2];
	double fRec817[2];
	double fRec819[2];
	double fRec820[2];
	double fRec822[2];
	double fRec823[2];
	double fRec825[2];
	double fRec826[2];
	double fRec828[2];
	double fRec829[2];
	double fRec831[2];
	double fRec832[2];
	double fRec834[2];
	double fRec835[2];
	double fRec837[2];
	double fRec838[2];
	double fRec840[2];
	double fRec841[2];
	double fRec843[2];
	double fRec844[2];
	double fRec846[2];
	double fRec847[2];
	double fRec849[2];
	double fRec850[2];
	double fRec852[2];
	double fRec853[2];
	double fRec855[2];
	double fRec856[2];
	double fRec858[2];
	double fRec859[2];
	double fRec861[2];
	double fRec862[2];
	double fRec864[2];
	double fRec865[2];
	double fRec867[2];
	double fRec868[2];
	double fRec729[2];
	double fRec8[2];
	double fRec876[2];
	int iVec50[2];
	int iRec877[2];
	double fRec875[2];
	double fRec874[2];
	double fRec872[2];
	double fRec873[2];
	FAUSTFLOAT fVbargraph42;
	double fRec883[2];
	int iVec51[2];
	int iRec884[2];
	double fRec882[2];
	double fRec881[2];
	double fRec879[2];
	double fRec880[2];
	FAUSTFLOAT fVbargraph43;
	double fRec878[2];
	double fRec889[2];
	int iVec52[2];
	int iRec890[2];
	double fRec888[2];
	double fRec887[2];
	double fRec885[2];
	double fRec886[2];
	FAUSTFLOAT fVbargraph44;
	double fVec53[2];
	double fRec870[2];
	double fRec898[2];
	int iVec54[2];
	int iRec899[2];
	double fRec897[2];
	double fRec896[2];
	double fRec894[2];
	double fRec895[2];
	FAUSTFLOAT fVbargraph45;
	double fRec904[2];
	int iVec55[2];
	int iRec905[2];
	double fRec903[2];
	double fRec902[2];
	double fRec900[2];
	double fRec901[2];
	FAUSTFLOAT fVbargraph46;
	double fRec906[2];
	double fRec911[2];
	int iVec56[2];
	int iRec912[2];
	double fRec910[2];
	double fRec909[2];
	double fRec907[2];
	double fRec908[2];
	FAUSTFLOAT fVbargraph47;
	double fRec917[2];
	int iVec57[2];
	int iRec918[2];
	double fRec916[2];
	double fRec915[2];
	double fRec913[2];
	double fRec914[2];
	FAUSTFLOAT fVbargraph48;
	double fRec891[2];
	double fRec892[2];
	double fRec919[2];
	double fRec920[2];
	double fRec922[2];
	double fRec923[2];
	double fRec925[2];
	double fRec926[2];
	double fRec928[2];
	double fRec929[2];
	double fRec931[2];
	double fRec932[2];
	double fRec934[2];
	double fRec935[2];
	double fRec937[2];
	double fRec938[2];
	double fRec940[2];
	double fRec941[2];
	double fRec943[2];
	double fRec944[2];
	double fRec946[2];
	double fRec947[2];
	double fRec949[2];
	double fRec950[2];
	double fRec952[2];
	double fRec953[2];
	double fRec955[2];
	double fRec956[2];
	double fRec958[2];
	double fRec959[2];
	double fRec961[2];
	double fRec962[2];
	double fRec964[2];
	double fRec965[2];
	double fRec967[2];
	double fRec968[2];
	double fRec970[2];
	double fRec971[2];
	double fRec973[2];
	double fRec974[2];
	double fRec976[2];
	double fRec977[2];
	double fRec979[2];
	double fRec980[2];
	double fRec982[2];
	double fRec983[2];
	double fRec985[2];
	double fRec986[2];
	double fRec988[2];
	double fRec989[2];
	double fRec991[2];
	double fRec992[2];
	double fRec994[2];
	double fRec995[2];
	double fRec997[2];
	double fRec998[2];
	double fRec1000[2];
	double fRec1001[2];
	double fRec1003[2];
	double fRec1004[2];
	double fRec1006[2];
	double fRec1007[2];
	double fRec1009[2];
	double fRec1010[2];
	double fRec871[2];
	double fRec9[2];
	double fRec1018[2];
	int iVec58[2];
	int iRec1019[2];
	double fRec1017[2];
	double fRec1016[2];
	double fRec1014[2];
	double fRec1015[2];
	FAUSTFLOAT fVbargraph49;
	double fRec1025[2];
	int iVec59[2];
	int iRec1026[2];
	double fRec1024[2];
	double fRec1023[2];
	double fRec1021[2];
	double fRec1022[2];
	FAUSTFLOAT fVbargraph50;
	double fRec1020[2];
	double fRec1031[2];
	int iVec60[2];
	int iRec1032[2];
	double fRec1030[2];
	double fRec1029[2];
	double fRec1027[2];
	double fRec1028[2];
	FAUSTFLOAT fVbargraph51;
	double fVec61[2];
	double fRec1012[2];
	double fRec1040[2];
	int iVec62[2];
	int iRec1041[2];
	double fRec1039[2];
	double fRec1038[2];
	double fRec1036[2];
	double fRec1037[2];
	FAUSTFLOAT fVbargraph52;
	double fRec1046[2];
	int iVec63[2];
	int iRec1047[2];
	double fRec1045[2];
	double fRec1044[2];
	double fRec1042[2];
	double fRec1043[2];
	FAUSTFLOAT fVbargraph53;
	double fRec1048[2];
	double fRec1053[2];
	int iVec64[2];
	int iRec1054[2];
	double fRec1052[2];
	double fRec1051[2];
	double fRec1049[2];
	double fRec1050[2];
	FAUSTFLOAT fVbargraph54;
	double fRec1059[2];
	int iVec65[2];
	int iRec1060[2];
	double fRec1058[2];
	double fRec1057[2];
	double fRec1055[2];
	double fRec1056[2];
	FAUSTFLOAT fVbargraph55;
	double fRec1033[2];
	double fRec1034[2];
	double fRec1061[2];
	double fRec1062[2];
	double fRec1064[2];
	double fRec1065[2];
	double fRec1067[2];
	double fRec1068[2];
	double fRec1070[2];
	double fRec1071[2];
	double fRec1073[2];
	double fRec1074[2];
	double fRec1076[2];
	double fRec1077[2];
	double fRec1079[2];
	double fRec1080[2];
	double fRec1082[2];
	double fRec1083[2];
	double fRec1085[2];
	double fRec1086[2];
	double fRec1088[2];
	double fRec1089[2];
	double fRec1091[2];
	double fRec1092[2];
	double fRec1094[2];
	double fRec1095[2];
	double fRec1097[2];
	double fRec1098[2];
	double fRec1100[2];
	double fRec1101[2];
	double fRec1103[2];
	double fRec1104[2];
	double fRec1106[2];
	double fRec1107[2];
	double fRec1109[2];
	double fRec1110[2];
	double fRec1112[2];
	double fRec1113[2];
	double fRec1115[2];
	double fRec1116[2];
	double fRec1118[2];
	double fRec1119[2];
	double fRec1121[2];
	double fRec1122[2];
	double fRec1124[2];
	double fRec1125[2];
	double fRec1127[2];
	double fRec1128[2];
	double fRec1130[2];
	double fRec1131[2];
	double fRec1133[2];
	double fRec1134[2];
	double fRec1136[2];
	double fRec1137[2];
	double fRec1139[2];
	double fRec1140[2];
	double fRec1142[2];
	double fRec1143[2];
	double fRec1145[2];
	double fRec1146[2];
	double fRec1148[2];
	double fRec1149[2];
	double fRec1151[2];
	double fRec1152[2];
	double fRec1013[2];
	double fRec10[2];
	double fRec2[32768];
	int iConst7;
	double fConst9;
	double fConst10;
	double fConst11;
	int iRec1157[2];
	double fRec1158[2];
	double fRec1155[2];
	double fConst12;
	double fRec1154[2];
	double fRec1159[32768];
	int iRec1163[2];
	double fRec1164[2];
	double fRec1161[2];
	double fRec1160[2];
	double fRec1165[32768];
	int iRec1169[2];
	double fRec1170[2];
	double fRec1167[2];
	double fRec1166[2];
	double fRec1171[32768];
	int iRec1175[2];
	double fRec1176[2];
	double fRec1173[2];
	double fRec1172[2];
	double fRec0[2];
	FAUSTFLOAT fVbargraph56;
	double fRec1178[32768];
	int iRec1182[2];
	double fRec1183[2];
	double fRec1180[2];
	double fRec1179[2];
	double fRec1184[32768];
	int iRec1188[2];
	double fRec1189[2];
	double fRec1186[2];
	double fRec1185[2];
	double fRec1190[32768];
	int iRec1194[2];
	double fRec1195[2];
	double fRec1192[2];
	double fRec1191[2];
	double fRec1196[32768];
	int iRec1200[2];
	double fRec1201[2];
	double fRec1198[2];
	double fRec1197[2];
	double fRec1177[2];
	FAUSTFLOAT fVbargraph57;
	double fRec1202[2];
	FAUSTFLOAT fVbargraph58;
	double fRec1203[2];
	FAUSTFLOAT fVbargraph59;
	double fRec1204[2];
	FAUSTFLOAT fVbargraph60;
	double fRec1205[2];
	FAUSTFLOAT fVbargraph61;
	double fRec1206[2];
	FAUSTFLOAT fVbargraph62;
	double fRec1207[2];
	FAUSTFLOAT fVbargraph63;
	
 public:
	mydsp() {}

	void metadata(Meta* m) { 
		m->declare("RITI_lists.lib/author", "Luca Spanedda");
		m->declare("RITI_lists.lib/copyright", "Copyright (C) 2023 Luca Spanedda <lucaspanedda1995@gmail dot com>");
		m->declare("RITI_lists.lib/description", "2023");
		m->declare("RITI_lists.lib/license", "MIT license");
		m->declare("RITI_lists.lib/name", "Room Is The Instrument");
		m->declare("RITI_lists.lib/version", "1.4");
		m->declare("author", "Luca Spanedda");
		m->declare("basics.lib/name", "Faust Basic Element Library");
		m->declare("basics.lib/tabulateNd", "Copyright (C) 2023 Bart Brouns <bart@magnetophon.nl>");
		m->declare("basics.lib/version", "1.11.1");
		m->declare("compile_options", "-a /usr/local/share/faust/ca-gtk.cpp -lang cpp -i -ct 1 -es 1 -mcd 16 -double -ftz 0");
		m->declare("copyright", "Copyright (C) 2023 Luca Spanedda <lucaspanedda1995@gmail dot com>");
		m->declare("description", "2023");
		m->declare("filename", "RITI_network.dsp");
		m->declare("license", "MIT license");
		m->declare("maths.lib/author", "GRAME");
		m->declare("maths.lib/copyright", "GRAME");
		m->declare("maths.lib/license", "LGPL with exception");
		m->declare("maths.lib/name", "Faust Math Library");
		m->declare("maths.lib/version", "2.6.0");
		m->declare("name", "Room Is The Instrument");
		m->declare("platform.lib/name", "Generic Platform Library");
		m->declare("platform.lib/version", "1.3.0");
		m->declare("routes.lib/name", "Faust Signal Routing Library");
		m->declare("routes.lib/version", "1.2.0");
		m->declare("signals.lib/name", "Faust Signal Routing Library");
		m->declare("signals.lib/version", "1.3.0");
		m->declare("version", "1.4");
	}

	virtual int getNumInputs() {
		return 0;
	}
	virtual int getNumOutputs() {
		return 8;
	}
	
	static void classInit(int sample_rate) {
	}
	
	virtual void instanceConstants(int sample_rate) {
		fSampleRate = sample_rate;
		fConst0 = std::min<double>(1.92e+05, std::max<double>(1.0, double(fSampleRate)));
		fConst1 = 1.0 / fConst0;
		fConst2 = 44.1 / fConst0;
		fConst3 = 1.0 - fConst2;
		fConst4 = 1e+01 * fConst0;
		fConst5 = 3.141592653589793 / fConst0;
		double fConst6 = 0.1 * fConst0;
		iConst7 = int(fConst6);
		double fConst8 = std::tan(31.41592653589793 / fConst0);
		fConst9 = fConst8 / (fConst8 + 1.0);
		fConst10 = 2.0 * fConst9;
		fConst11 = fConst6 + -1.0;
		fConst12 = std::exp(0.0 - 0.6283185307179586 / fConst0);
	}
	
	virtual void instanceResetUserInterface() {
		fHslider0 = FAUSTFLOAT(1.0);
		fVslider0 = FAUSTFLOAT(2.0);
		fHslider1 = FAUSTFLOAT(0.0);
		fCheckbox0 = FAUSTFLOAT(0.0);
		fHslider2 = FAUSTFLOAT(0.0);
		fHslider3 = FAUSTFLOAT(0.0);
		fHslider4 = FAUSTFLOAT(0.0);
		fHslider5 = FAUSTFLOAT(0.0);
		fHslider6 = FAUSTFLOAT(0.0);
		fHslider7 = FAUSTFLOAT(0.0);
	}
	
	virtual void instanceClear() {
		for (int l0 = 0; l0 < 2; l0 = l0 + 1) {
			iVec0[l0] = 0;
		}
		for (int l1 = 0; l1 < 2; l1 = l1 + 1) {
			fRec1[l1] = 0.0;
		}
		for (int l2 = 0; l2 < 2; l2 = l2 + 1) {
			fRec13[l2] = 0.0;
		}
		for (int l3 = 0; l3 < 2; l3 = l3 + 1) {
			fRec18[l3] = 0.0;
		}
		for (int l4 = 0; l4 < 2; l4 = l4 + 1) {
			iVec1[l4] = 0;
		}
		for (int l5 = 0; l5 < 2; l5 = l5 + 1) {
			iVec2[l5] = 0;
		}
		for (int l6 = 0; l6 < 2; l6 = l6 + 1) {
			iRec19[l6] = 0;
		}
		for (int l7 = 0; l7 < 2; l7 = l7 + 1) {
			fRec17[l7] = 0.0;
		}
		IOTA0 = 0;
		for (int l8 = 0; l8 < 2048; l8 = l8 + 1) {
			fVec3[l8] = 0.0;
		}
		for (int l9 = 0; l9 < 2; l9 = l9 + 1) {
			fRec16[l9] = 0.0;
		}
		for (int l10 = 0; l10 < 2; l10 = l10 + 1) {
			fRec14[l10] = 0.0;
		}
		for (int l11 = 0; l11 < 2; l11 = l11 + 1) {
			fRec15[l11] = 0.0;
		}
		for (int l12 = 0; l12 < 2; l12 = l12 + 1) {
			fRec21[l12] = 0.0;
		}
		for (int l13 = 0; l13 < 2; l13 = l13 + 1) {
			fRec26[l13] = 0.0;
		}
		for (int l14 = 0; l14 < 2; l14 = l14 + 1) {
			iVec4[l14] = 0;
		}
		for (int l15 = 0; l15 < 2; l15 = l15 + 1) {
			iRec27[l15] = 0;
		}
		for (int l16 = 0; l16 < 2; l16 = l16 + 1) {
			fRec25[l16] = 0.0;
		}
		for (int l17 = 0; l17 < 2; l17 = l17 + 1) {
			fRec24[l17] = 0.0;
		}
		for (int l18 = 0; l18 < 2; l18 = l18 + 1) {
			fRec22[l18] = 0.0;
		}
		for (int l19 = 0; l19 < 2; l19 = l19 + 1) {
			fRec23[l19] = 0.0;
		}
		for (int l20 = 0; l20 < 2; l20 = l20 + 1) {
			fRec20[l20] = 0.0;
		}
		for (int l21 = 0; l21 < 2; l21 = l21 + 1) {
			fRec28[l21] = 0.0;
		}
		for (int l22 = 0; l22 < 2; l22 = l22 + 1) {
			fRec33[l22] = 0.0;
		}
		for (int l23 = 0; l23 < 2; l23 = l23 + 1) {
			iVec5[l23] = 0;
		}
		for (int l24 = 0; l24 < 2; l24 = l24 + 1) {
			iRec34[l24] = 0;
		}
		for (int l25 = 0; l25 < 2; l25 = l25 + 1) {
			fRec32[l25] = 0.0;
		}
		for (int l26 = 0; l26 < 2; l26 = l26 + 1) {
			fRec31[l26] = 0.0;
		}
		for (int l27 = 0; l27 < 2; l27 = l27 + 1) {
			fRec29[l27] = 0.0;
		}
		for (int l28 = 0; l28 < 2; l28 = l28 + 1) {
			fRec30[l28] = 0.0;
		}
		for (int l29 = 0; l29 < 2; l29 = l29 + 1) {
			fVec6[l29] = 0.0;
		}
		for (int l30 = 0; l30 < 2; l30 = l30 + 1) {
			fRec11[l30] = 0.0;
		}
		for (int l31 = 0; l31 < 2; l31 = l31 + 1) {
			fRec38[l31] = 0.0;
		}
		for (int l32 = 0; l32 < 2; l32 = l32 + 1) {
			fRec43[l32] = 0.0;
		}
		for (int l33 = 0; l33 < 2; l33 = l33 + 1) {
			iVec7[l33] = 0;
		}
		for (int l34 = 0; l34 < 2; l34 = l34 + 1) {
			iRec44[l34] = 0;
		}
		for (int l35 = 0; l35 < 2; l35 = l35 + 1) {
			fRec42[l35] = 0.0;
		}
		for (int l36 = 0; l36 < 2; l36 = l36 + 1) {
			fRec41[l36] = 0.0;
		}
		for (int l37 = 0; l37 < 2; l37 = l37 + 1) {
			fRec39[l37] = 0.0;
		}
		for (int l38 = 0; l38 < 2; l38 = l38 + 1) {
			fRec40[l38] = 0.0;
		}
		for (int l39 = 0; l39 < 2; l39 = l39 + 1) {
			fRec45[l39] = 0.0;
		}
		for (int l40 = 0; l40 < 2; l40 = l40 + 1) {
			fRec50[l40] = 0.0;
		}
		for (int l41 = 0; l41 < 2; l41 = l41 + 1) {
			iVec8[l41] = 0;
		}
		for (int l42 = 0; l42 < 2; l42 = l42 + 1) {
			iRec51[l42] = 0;
		}
		for (int l43 = 0; l43 < 2; l43 = l43 + 1) {
			fRec49[l43] = 0.0;
		}
		for (int l44 = 0; l44 < 2; l44 = l44 + 1) {
			fRec48[l44] = 0.0;
		}
		for (int l45 = 0; l45 < 2; l45 = l45 + 1) {
			fRec46[l45] = 0.0;
		}
		for (int l46 = 0; l46 < 2; l46 = l46 + 1) {
			fRec47[l46] = 0.0;
		}
		for (int l47 = 0; l47 < 2; l47 = l47 + 1) {
			fRec52[l47] = 0.0;
		}
		for (int l48 = 0; l48 < 2; l48 = l48 + 1) {
			fRec53[l48] = 0.0;
		}
		for (int l49 = 0; l49 < 2; l49 = l49 + 1) {
			fRec58[l49] = 0.0;
		}
		for (int l50 = 0; l50 < 2; l50 = l50 + 1) {
			iVec9[l50] = 0;
		}
		for (int l51 = 0; l51 < 2; l51 = l51 + 1) {
			iRec59[l51] = 0;
		}
		for (int l52 = 0; l52 < 2; l52 = l52 + 1) {
			fRec57[l52] = 0.0;
		}
		for (int l53 = 0; l53 < 2; l53 = l53 + 1) {
			fRec56[l53] = 0.0;
		}
		for (int l54 = 0; l54 < 2; l54 = l54 + 1) {
			fRec54[l54] = 0.0;
		}
		for (int l55 = 0; l55 < 2; l55 = l55 + 1) {
			fRec55[l55] = 0.0;
		}
		for (int l56 = 0; l56 < 2; l56 = l56 + 1) {
			fRec60[l56] = 0.0;
		}
		for (int l57 = 0; l57 < 2; l57 = l57 + 1) {
			fRec65[l57] = 0.0;
		}
		for (int l58 = 0; l58 < 2; l58 = l58 + 1) {
			iVec10[l58] = 0;
		}
		for (int l59 = 0; l59 < 2; l59 = l59 + 1) {
			iRec66[l59] = 0;
		}
		for (int l60 = 0; l60 < 2; l60 = l60 + 1) {
			fRec64[l60] = 0.0;
		}
		for (int l61 = 0; l61 < 2; l61 = l61 + 1) {
			fRec63[l61] = 0.0;
		}
		for (int l62 = 0; l62 < 2; l62 = l62 + 1) {
			fRec61[l62] = 0.0;
		}
		for (int l63 = 0; l63 < 2; l63 = l63 + 1) {
			fRec62[l63] = 0.0;
		}
		for (int l64 = 0; l64 < 2; l64 = l64 + 1) {
			fRec35[l64] = 0.0;
		}
		for (int l65 = 0; l65 < 2; l65 = l65 + 1) {
			fRec36[l65] = 0.0;
		}
		for (int l66 = 0; l66 < 2; l66 = l66 + 1) {
			fRec67[l66] = 0.0;
		}
		for (int l67 = 0; l67 < 2; l67 = l67 + 1) {
			fRec68[l67] = 0.0;
		}
		for (int l68 = 0; l68 < 2; l68 = l68 + 1) {
			fRec70[l68] = 0.0;
		}
		for (int l69 = 0; l69 < 2; l69 = l69 + 1) {
			fRec71[l69] = 0.0;
		}
		for (int l70 = 0; l70 < 2; l70 = l70 + 1) {
			fRec73[l70] = 0.0;
		}
		for (int l71 = 0; l71 < 2; l71 = l71 + 1) {
			fRec74[l71] = 0.0;
		}
		for (int l72 = 0; l72 < 2; l72 = l72 + 1) {
			fRec76[l72] = 0.0;
		}
		for (int l73 = 0; l73 < 2; l73 = l73 + 1) {
			fRec77[l73] = 0.0;
		}
		for (int l74 = 0; l74 < 2; l74 = l74 + 1) {
			fRec79[l74] = 0.0;
		}
		for (int l75 = 0; l75 < 2; l75 = l75 + 1) {
			fRec80[l75] = 0.0;
		}
		for (int l76 = 0; l76 < 2; l76 = l76 + 1) {
			fRec82[l76] = 0.0;
		}
		for (int l77 = 0; l77 < 2; l77 = l77 + 1) {
			fRec83[l77] = 0.0;
		}
		for (int l78 = 0; l78 < 2; l78 = l78 + 1) {
			fRec85[l78] = 0.0;
		}
		for (int l79 = 0; l79 < 2; l79 = l79 + 1) {
			fRec86[l79] = 0.0;
		}
		for (int l80 = 0; l80 < 2; l80 = l80 + 1) {
			fRec88[l80] = 0.0;
		}
		for (int l81 = 0; l81 < 2; l81 = l81 + 1) {
			fRec89[l81] = 0.0;
		}
		for (int l82 = 0; l82 < 2; l82 = l82 + 1) {
			fRec91[l82] = 0.0;
		}
		for (int l83 = 0; l83 < 2; l83 = l83 + 1) {
			fRec92[l83] = 0.0;
		}
		for (int l84 = 0; l84 < 2; l84 = l84 + 1) {
			fRec94[l84] = 0.0;
		}
		for (int l85 = 0; l85 < 2; l85 = l85 + 1) {
			fRec95[l85] = 0.0;
		}
		for (int l86 = 0; l86 < 2; l86 = l86 + 1) {
			fRec97[l86] = 0.0;
		}
		for (int l87 = 0; l87 < 2; l87 = l87 + 1) {
			fRec98[l87] = 0.0;
		}
		for (int l88 = 0; l88 < 2; l88 = l88 + 1) {
			fRec100[l88] = 0.0;
		}
		for (int l89 = 0; l89 < 2; l89 = l89 + 1) {
			fRec101[l89] = 0.0;
		}
		for (int l90 = 0; l90 < 2; l90 = l90 + 1) {
			fRec103[l90] = 0.0;
		}
		for (int l91 = 0; l91 < 2; l91 = l91 + 1) {
			fRec104[l91] = 0.0;
		}
		for (int l92 = 0; l92 < 2; l92 = l92 + 1) {
			fRec106[l92] = 0.0;
		}
		for (int l93 = 0; l93 < 2; l93 = l93 + 1) {
			fRec107[l93] = 0.0;
		}
		for (int l94 = 0; l94 < 2; l94 = l94 + 1) {
			fRec109[l94] = 0.0;
		}
		for (int l95 = 0; l95 < 2; l95 = l95 + 1) {
			fRec110[l95] = 0.0;
		}
		for (int l96 = 0; l96 < 2; l96 = l96 + 1) {
			fRec112[l96] = 0.0;
		}
		for (int l97 = 0; l97 < 2; l97 = l97 + 1) {
			fRec113[l97] = 0.0;
		}
		for (int l98 = 0; l98 < 2; l98 = l98 + 1) {
			fRec115[l98] = 0.0;
		}
		for (int l99 = 0; l99 < 2; l99 = l99 + 1) {
			fRec116[l99] = 0.0;
		}
		for (int l100 = 0; l100 < 2; l100 = l100 + 1) {
			fRec118[l100] = 0.0;
		}
		for (int l101 = 0; l101 < 2; l101 = l101 + 1) {
			fRec119[l101] = 0.0;
		}
		for (int l102 = 0; l102 < 2; l102 = l102 + 1) {
			fRec121[l102] = 0.0;
		}
		for (int l103 = 0; l103 < 2; l103 = l103 + 1) {
			fRec122[l103] = 0.0;
		}
		for (int l104 = 0; l104 < 2; l104 = l104 + 1) {
			fRec124[l104] = 0.0;
		}
		for (int l105 = 0; l105 < 2; l105 = l105 + 1) {
			fRec125[l105] = 0.0;
		}
		for (int l106 = 0; l106 < 2; l106 = l106 + 1) {
			fRec127[l106] = 0.0;
		}
		for (int l107 = 0; l107 < 2; l107 = l107 + 1) {
			fRec128[l107] = 0.0;
		}
		for (int l108 = 0; l108 < 2; l108 = l108 + 1) {
			fRec130[l108] = 0.0;
		}
		for (int l109 = 0; l109 < 2; l109 = l109 + 1) {
			fRec131[l109] = 0.0;
		}
		for (int l110 = 0; l110 < 2; l110 = l110 + 1) {
			fRec133[l110] = 0.0;
		}
		for (int l111 = 0; l111 < 2; l111 = l111 + 1) {
			fRec134[l111] = 0.0;
		}
		for (int l112 = 0; l112 < 2; l112 = l112 + 1) {
			fRec136[l112] = 0.0;
		}
		for (int l113 = 0; l113 < 2; l113 = l113 + 1) {
			fRec137[l113] = 0.0;
		}
		for (int l114 = 0; l114 < 2; l114 = l114 + 1) {
			fRec139[l114] = 0.0;
		}
		for (int l115 = 0; l115 < 2; l115 = l115 + 1) {
			fRec140[l115] = 0.0;
		}
		for (int l116 = 0; l116 < 2; l116 = l116 + 1) {
			fRec142[l116] = 0.0;
		}
		for (int l117 = 0; l117 < 2; l117 = l117 + 1) {
			fRec143[l117] = 0.0;
		}
		for (int l118 = 0; l118 < 2; l118 = l118 + 1) {
			fRec145[l118] = 0.0;
		}
		for (int l119 = 0; l119 < 2; l119 = l119 + 1) {
			fRec146[l119] = 0.0;
		}
		for (int l120 = 0; l120 < 2; l120 = l120 + 1) {
			fRec148[l120] = 0.0;
		}
		for (int l121 = 0; l121 < 2; l121 = l121 + 1) {
			fRec149[l121] = 0.0;
		}
		for (int l122 = 0; l122 < 2; l122 = l122 + 1) {
			fRec151[l122] = 0.0;
		}
		for (int l123 = 0; l123 < 2; l123 = l123 + 1) {
			fRec152[l123] = 0.0;
		}
		for (int l124 = 0; l124 < 2; l124 = l124 + 1) {
			fRec154[l124] = 0.0;
		}
		for (int l125 = 0; l125 < 2; l125 = l125 + 1) {
			fRec155[l125] = 0.0;
		}
		for (int l126 = 0; l126 < 2; l126 = l126 + 1) {
			fRec157[l126] = 0.0;
		}
		for (int l127 = 0; l127 < 2; l127 = l127 + 1) {
			fRec158[l127] = 0.0;
		}
		for (int l128 = 0; l128 < 2; l128 = l128 + 1) {
			fRec12[l128] = 0.0;
		}
		for (int l129 = 0; l129 < 2; l129 = l129 + 1) {
			fRec3[l129] = 0.0;
		}
		for (int l130 = 0; l130 < 2; l130 = l130 + 1) {
			fRec166[l130] = 0.0;
		}
		for (int l131 = 0; l131 < 2; l131 = l131 + 1) {
			iVec11[l131] = 0;
		}
		for (int l132 = 0; l132 < 2; l132 = l132 + 1) {
			iRec167[l132] = 0;
		}
		for (int l133 = 0; l133 < 2; l133 = l133 + 1) {
			fRec165[l133] = 0.0;
		}
		for (int l134 = 0; l134 < 2; l134 = l134 + 1) {
			fRec164[l134] = 0.0;
		}
		for (int l135 = 0; l135 < 2; l135 = l135 + 1) {
			fRec162[l135] = 0.0;
		}
		for (int l136 = 0; l136 < 2; l136 = l136 + 1) {
			fRec163[l136] = 0.0;
		}
		for (int l137 = 0; l137 < 2; l137 = l137 + 1) {
			fRec173[l137] = 0.0;
		}
		for (int l138 = 0; l138 < 2; l138 = l138 + 1) {
			iVec12[l138] = 0;
		}
		for (int l139 = 0; l139 < 2; l139 = l139 + 1) {
			iRec174[l139] = 0;
		}
		for (int l140 = 0; l140 < 2; l140 = l140 + 1) {
			fRec172[l140] = 0.0;
		}
		for (int l141 = 0; l141 < 2; l141 = l141 + 1) {
			fRec171[l141] = 0.0;
		}
		for (int l142 = 0; l142 < 2; l142 = l142 + 1) {
			fRec169[l142] = 0.0;
		}
		for (int l143 = 0; l143 < 2; l143 = l143 + 1) {
			fRec170[l143] = 0.0;
		}
		for (int l144 = 0; l144 < 2; l144 = l144 + 1) {
			fRec168[l144] = 0.0;
		}
		for (int l145 = 0; l145 < 2; l145 = l145 + 1) {
			fRec179[l145] = 0.0;
		}
		for (int l146 = 0; l146 < 2; l146 = l146 + 1) {
			iVec13[l146] = 0;
		}
		for (int l147 = 0; l147 < 2; l147 = l147 + 1) {
			iRec180[l147] = 0;
		}
		for (int l148 = 0; l148 < 2; l148 = l148 + 1) {
			fRec178[l148] = 0.0;
		}
		for (int l149 = 0; l149 < 2; l149 = l149 + 1) {
			fRec177[l149] = 0.0;
		}
		for (int l150 = 0; l150 < 2; l150 = l150 + 1) {
			fRec175[l150] = 0.0;
		}
		for (int l151 = 0; l151 < 2; l151 = l151 + 1) {
			fRec176[l151] = 0.0;
		}
		for (int l152 = 0; l152 < 2; l152 = l152 + 1) {
			fVec14[l152] = 0.0;
		}
		for (int l153 = 0; l153 < 2; l153 = l153 + 1) {
			fRec160[l153] = 0.0;
		}
		for (int l154 = 0; l154 < 2; l154 = l154 + 1) {
			fRec188[l154] = 0.0;
		}
		for (int l155 = 0; l155 < 2; l155 = l155 + 1) {
			iVec15[l155] = 0;
		}
		for (int l156 = 0; l156 < 2; l156 = l156 + 1) {
			iRec189[l156] = 0;
		}
		for (int l157 = 0; l157 < 2; l157 = l157 + 1) {
			fRec187[l157] = 0.0;
		}
		for (int l158 = 0; l158 < 2; l158 = l158 + 1) {
			fRec186[l158] = 0.0;
		}
		for (int l159 = 0; l159 < 2; l159 = l159 + 1) {
			fRec184[l159] = 0.0;
		}
		for (int l160 = 0; l160 < 2; l160 = l160 + 1) {
			fRec185[l160] = 0.0;
		}
		for (int l161 = 0; l161 < 2; l161 = l161 + 1) {
			fRec194[l161] = 0.0;
		}
		for (int l162 = 0; l162 < 2; l162 = l162 + 1) {
			iVec16[l162] = 0;
		}
		for (int l163 = 0; l163 < 2; l163 = l163 + 1) {
			iRec195[l163] = 0;
		}
		for (int l164 = 0; l164 < 2; l164 = l164 + 1) {
			fRec193[l164] = 0.0;
		}
		for (int l165 = 0; l165 < 2; l165 = l165 + 1) {
			fRec192[l165] = 0.0;
		}
		for (int l166 = 0; l166 < 2; l166 = l166 + 1) {
			fRec190[l166] = 0.0;
		}
		for (int l167 = 0; l167 < 2; l167 = l167 + 1) {
			fRec191[l167] = 0.0;
		}
		for (int l168 = 0; l168 < 2; l168 = l168 + 1) {
			fRec196[l168] = 0.0;
		}
		for (int l169 = 0; l169 < 2; l169 = l169 + 1) {
			fRec201[l169] = 0.0;
		}
		for (int l170 = 0; l170 < 2; l170 = l170 + 1) {
			iRec202[l170] = 0;
		}
		for (int l171 = 0; l171 < 2; l171 = l171 + 1) {
			fRec200[l171] = 0.0;
		}
		for (int l172 = 0; l172 < 2; l172 = l172 + 1) {
			fRec199[l172] = 0.0;
		}
		for (int l173 = 0; l173 < 2; l173 = l173 + 1) {
			fRec197[l173] = 0.0;
		}
		for (int l174 = 0; l174 < 2; l174 = l174 + 1) {
			fRec198[l174] = 0.0;
		}
		for (int l175 = 0; l175 < 2; l175 = l175 + 1) {
			fRec207[l175] = 0.0;
		}
		for (int l176 = 0; l176 < 2; l176 = l176 + 1) {
			iVec17[l176] = 0;
		}
		for (int l177 = 0; l177 < 2; l177 = l177 + 1) {
			iRec208[l177] = 0;
		}
		for (int l178 = 0; l178 < 2; l178 = l178 + 1) {
			fRec206[l178] = 0.0;
		}
		for (int l179 = 0; l179 < 2; l179 = l179 + 1) {
			fRec205[l179] = 0.0;
		}
		for (int l180 = 0; l180 < 2; l180 = l180 + 1) {
			fRec203[l180] = 0.0;
		}
		for (int l181 = 0; l181 < 2; l181 = l181 + 1) {
			fRec204[l181] = 0.0;
		}
		for (int l182 = 0; l182 < 2; l182 = l182 + 1) {
			fRec181[l182] = 0.0;
		}
		for (int l183 = 0; l183 < 2; l183 = l183 + 1) {
			fRec182[l183] = 0.0;
		}
		for (int l184 = 0; l184 < 2; l184 = l184 + 1) {
			fRec209[l184] = 0.0;
		}
		for (int l185 = 0; l185 < 2; l185 = l185 + 1) {
			fRec210[l185] = 0.0;
		}
		for (int l186 = 0; l186 < 2; l186 = l186 + 1) {
			fRec212[l186] = 0.0;
		}
		for (int l187 = 0; l187 < 2; l187 = l187 + 1) {
			fRec213[l187] = 0.0;
		}
		for (int l188 = 0; l188 < 2; l188 = l188 + 1) {
			fRec215[l188] = 0.0;
		}
		for (int l189 = 0; l189 < 2; l189 = l189 + 1) {
			fRec216[l189] = 0.0;
		}
		for (int l190 = 0; l190 < 2; l190 = l190 + 1) {
			fRec218[l190] = 0.0;
		}
		for (int l191 = 0; l191 < 2; l191 = l191 + 1) {
			fRec219[l191] = 0.0;
		}
		for (int l192 = 0; l192 < 2; l192 = l192 + 1) {
			fRec221[l192] = 0.0;
		}
		for (int l193 = 0; l193 < 2; l193 = l193 + 1) {
			fRec222[l193] = 0.0;
		}
		for (int l194 = 0; l194 < 2; l194 = l194 + 1) {
			fRec224[l194] = 0.0;
		}
		for (int l195 = 0; l195 < 2; l195 = l195 + 1) {
			fRec225[l195] = 0.0;
		}
		for (int l196 = 0; l196 < 2; l196 = l196 + 1) {
			fRec227[l196] = 0.0;
		}
		for (int l197 = 0; l197 < 2; l197 = l197 + 1) {
			fRec228[l197] = 0.0;
		}
		for (int l198 = 0; l198 < 2; l198 = l198 + 1) {
			fRec230[l198] = 0.0;
		}
		for (int l199 = 0; l199 < 2; l199 = l199 + 1) {
			fRec231[l199] = 0.0;
		}
		for (int l200 = 0; l200 < 2; l200 = l200 + 1) {
			fRec233[l200] = 0.0;
		}
		for (int l201 = 0; l201 < 2; l201 = l201 + 1) {
			fRec234[l201] = 0.0;
		}
		for (int l202 = 0; l202 < 2; l202 = l202 + 1) {
			fRec236[l202] = 0.0;
		}
		for (int l203 = 0; l203 < 2; l203 = l203 + 1) {
			fRec237[l203] = 0.0;
		}
		for (int l204 = 0; l204 < 2; l204 = l204 + 1) {
			fRec239[l204] = 0.0;
		}
		for (int l205 = 0; l205 < 2; l205 = l205 + 1) {
			fRec240[l205] = 0.0;
		}
		for (int l206 = 0; l206 < 2; l206 = l206 + 1) {
			fRec242[l206] = 0.0;
		}
		for (int l207 = 0; l207 < 2; l207 = l207 + 1) {
			fRec243[l207] = 0.0;
		}
		for (int l208 = 0; l208 < 2; l208 = l208 + 1) {
			fRec245[l208] = 0.0;
		}
		for (int l209 = 0; l209 < 2; l209 = l209 + 1) {
			fRec246[l209] = 0.0;
		}
		for (int l210 = 0; l210 < 2; l210 = l210 + 1) {
			fRec248[l210] = 0.0;
		}
		for (int l211 = 0; l211 < 2; l211 = l211 + 1) {
			fRec249[l211] = 0.0;
		}
		for (int l212 = 0; l212 < 2; l212 = l212 + 1) {
			fRec251[l212] = 0.0;
		}
		for (int l213 = 0; l213 < 2; l213 = l213 + 1) {
			fRec252[l213] = 0.0;
		}
		for (int l214 = 0; l214 < 2; l214 = l214 + 1) {
			fRec254[l214] = 0.0;
		}
		for (int l215 = 0; l215 < 2; l215 = l215 + 1) {
			fRec255[l215] = 0.0;
		}
		for (int l216 = 0; l216 < 2; l216 = l216 + 1) {
			fRec257[l216] = 0.0;
		}
		for (int l217 = 0; l217 < 2; l217 = l217 + 1) {
			fRec258[l217] = 0.0;
		}
		for (int l218 = 0; l218 < 2; l218 = l218 + 1) {
			fRec260[l218] = 0.0;
		}
		for (int l219 = 0; l219 < 2; l219 = l219 + 1) {
			fRec261[l219] = 0.0;
		}
		for (int l220 = 0; l220 < 2; l220 = l220 + 1) {
			fRec263[l220] = 0.0;
		}
		for (int l221 = 0; l221 < 2; l221 = l221 + 1) {
			fRec264[l221] = 0.0;
		}
		for (int l222 = 0; l222 < 2; l222 = l222 + 1) {
			fRec266[l222] = 0.0;
		}
		for (int l223 = 0; l223 < 2; l223 = l223 + 1) {
			fRec267[l223] = 0.0;
		}
		for (int l224 = 0; l224 < 2; l224 = l224 + 1) {
			fRec269[l224] = 0.0;
		}
		for (int l225 = 0; l225 < 2; l225 = l225 + 1) {
			fRec270[l225] = 0.0;
		}
		for (int l226 = 0; l226 < 2; l226 = l226 + 1) {
			fRec272[l226] = 0.0;
		}
		for (int l227 = 0; l227 < 2; l227 = l227 + 1) {
			fRec273[l227] = 0.0;
		}
		for (int l228 = 0; l228 < 2; l228 = l228 + 1) {
			fRec275[l228] = 0.0;
		}
		for (int l229 = 0; l229 < 2; l229 = l229 + 1) {
			fRec276[l229] = 0.0;
		}
		for (int l230 = 0; l230 < 2; l230 = l230 + 1) {
			fRec278[l230] = 0.0;
		}
		for (int l231 = 0; l231 < 2; l231 = l231 + 1) {
			fRec279[l231] = 0.0;
		}
		for (int l232 = 0; l232 < 2; l232 = l232 + 1) {
			fRec281[l232] = 0.0;
		}
		for (int l233 = 0; l233 < 2; l233 = l233 + 1) {
			fRec282[l233] = 0.0;
		}
		for (int l234 = 0; l234 < 2; l234 = l234 + 1) {
			fRec284[l234] = 0.0;
		}
		for (int l235 = 0; l235 < 2; l235 = l235 + 1) {
			fRec285[l235] = 0.0;
		}
		for (int l236 = 0; l236 < 2; l236 = l236 + 1) {
			fRec287[l236] = 0.0;
		}
		for (int l237 = 0; l237 < 2; l237 = l237 + 1) {
			fRec288[l237] = 0.0;
		}
		for (int l238 = 0; l238 < 2; l238 = l238 + 1) {
			fRec290[l238] = 0.0;
		}
		for (int l239 = 0; l239 < 2; l239 = l239 + 1) {
			fRec291[l239] = 0.0;
		}
		for (int l240 = 0; l240 < 2; l240 = l240 + 1) {
			fRec293[l240] = 0.0;
		}
		for (int l241 = 0; l241 < 2; l241 = l241 + 1) {
			fRec294[l241] = 0.0;
		}
		for (int l242 = 0; l242 < 2; l242 = l242 + 1) {
			fRec296[l242] = 0.0;
		}
		for (int l243 = 0; l243 < 2; l243 = l243 + 1) {
			fRec297[l243] = 0.0;
		}
		for (int l244 = 0; l244 < 2; l244 = l244 + 1) {
			fRec299[l244] = 0.0;
		}
		for (int l245 = 0; l245 < 2; l245 = l245 + 1) {
			fRec300[l245] = 0.0;
		}
		for (int l246 = 0; l246 < 2; l246 = l246 + 1) {
			fRec161[l246] = 0.0;
		}
		for (int l247 = 0; l247 < 2; l247 = l247 + 1) {
			fRec4[l247] = 0.0;
		}
		for (int l248 = 0; l248 < 2; l248 = l248 + 1) {
			fRec308[l248] = 0.0;
		}
		for (int l249 = 0; l249 < 2; l249 = l249 + 1) {
			iVec18[l249] = 0;
		}
		for (int l250 = 0; l250 < 2; l250 = l250 + 1) {
			iRec309[l250] = 0;
		}
		for (int l251 = 0; l251 < 2; l251 = l251 + 1) {
			fRec307[l251] = 0.0;
		}
		for (int l252 = 0; l252 < 2; l252 = l252 + 1) {
			fRec306[l252] = 0.0;
		}
		for (int l253 = 0; l253 < 2; l253 = l253 + 1) {
			fRec304[l253] = 0.0;
		}
		for (int l254 = 0; l254 < 2; l254 = l254 + 1) {
			fRec305[l254] = 0.0;
		}
		for (int l255 = 0; l255 < 2; l255 = l255 + 1) {
			fRec315[l255] = 0.0;
		}
		for (int l256 = 0; l256 < 2; l256 = l256 + 1) {
			iVec19[l256] = 0;
		}
		for (int l257 = 0; l257 < 2; l257 = l257 + 1) {
			iRec316[l257] = 0;
		}
		for (int l258 = 0; l258 < 2; l258 = l258 + 1) {
			fRec314[l258] = 0.0;
		}
		for (int l259 = 0; l259 < 2; l259 = l259 + 1) {
			fRec313[l259] = 0.0;
		}
		for (int l260 = 0; l260 < 2; l260 = l260 + 1) {
			fRec311[l260] = 0.0;
		}
		for (int l261 = 0; l261 < 2; l261 = l261 + 1) {
			fRec312[l261] = 0.0;
		}
		for (int l262 = 0; l262 < 2; l262 = l262 + 1) {
			fRec310[l262] = 0.0;
		}
		for (int l263 = 0; l263 < 2; l263 = l263 + 1) {
			fRec321[l263] = 0.0;
		}
		for (int l264 = 0; l264 < 2; l264 = l264 + 1) {
			iVec20[l264] = 0;
		}
		for (int l265 = 0; l265 < 2; l265 = l265 + 1) {
			iRec322[l265] = 0;
		}
		for (int l266 = 0; l266 < 2; l266 = l266 + 1) {
			fRec320[l266] = 0.0;
		}
		for (int l267 = 0; l267 < 2; l267 = l267 + 1) {
			fRec319[l267] = 0.0;
		}
		for (int l268 = 0; l268 < 2; l268 = l268 + 1) {
			fRec317[l268] = 0.0;
		}
		for (int l269 = 0; l269 < 2; l269 = l269 + 1) {
			fRec318[l269] = 0.0;
		}
		for (int l270 = 0; l270 < 2; l270 = l270 + 1) {
			fVec21[l270] = 0.0;
		}
		for (int l271 = 0; l271 < 2; l271 = l271 + 1) {
			fRec302[l271] = 0.0;
		}
		for (int l272 = 0; l272 < 2; l272 = l272 + 1) {
			fRec330[l272] = 0.0;
		}
		for (int l273 = 0; l273 < 2; l273 = l273 + 1) {
			iVec22[l273] = 0;
		}
		for (int l274 = 0; l274 < 2; l274 = l274 + 1) {
			iRec331[l274] = 0;
		}
		for (int l275 = 0; l275 < 2; l275 = l275 + 1) {
			fRec329[l275] = 0.0;
		}
		for (int l276 = 0; l276 < 2; l276 = l276 + 1) {
			fRec328[l276] = 0.0;
		}
		for (int l277 = 0; l277 < 2; l277 = l277 + 1) {
			fRec326[l277] = 0.0;
		}
		for (int l278 = 0; l278 < 2; l278 = l278 + 1) {
			fRec327[l278] = 0.0;
		}
		for (int l279 = 0; l279 < 2; l279 = l279 + 1) {
			fRec336[l279] = 0.0;
		}
		for (int l280 = 0; l280 < 2; l280 = l280 + 1) {
			iVec23[l280] = 0;
		}
		for (int l281 = 0; l281 < 2; l281 = l281 + 1) {
			iRec337[l281] = 0;
		}
		for (int l282 = 0; l282 < 2; l282 = l282 + 1) {
			fRec335[l282] = 0.0;
		}
		for (int l283 = 0; l283 < 2; l283 = l283 + 1) {
			fRec334[l283] = 0.0;
		}
		for (int l284 = 0; l284 < 2; l284 = l284 + 1) {
			fRec332[l284] = 0.0;
		}
		for (int l285 = 0; l285 < 2; l285 = l285 + 1) {
			fRec333[l285] = 0.0;
		}
		for (int l286 = 0; l286 < 2; l286 = l286 + 1) {
			fRec338[l286] = 0.0;
		}
		for (int l287 = 0; l287 < 2; l287 = l287 + 1) {
			fRec343[l287] = 0.0;
		}
		for (int l288 = 0; l288 < 2; l288 = l288 + 1) {
			iVec24[l288] = 0;
		}
		for (int l289 = 0; l289 < 2; l289 = l289 + 1) {
			iRec344[l289] = 0;
		}
		for (int l290 = 0; l290 < 2; l290 = l290 + 1) {
			fRec342[l290] = 0.0;
		}
		for (int l291 = 0; l291 < 2; l291 = l291 + 1) {
			fRec341[l291] = 0.0;
		}
		for (int l292 = 0; l292 < 2; l292 = l292 + 1) {
			fRec339[l292] = 0.0;
		}
		for (int l293 = 0; l293 < 2; l293 = l293 + 1) {
			fRec340[l293] = 0.0;
		}
		for (int l294 = 0; l294 < 2; l294 = l294 + 1) {
			fRec349[l294] = 0.0;
		}
		for (int l295 = 0; l295 < 2; l295 = l295 + 1) {
			iVec25[l295] = 0;
		}
		for (int l296 = 0; l296 < 2; l296 = l296 + 1) {
			iRec350[l296] = 0;
		}
		for (int l297 = 0; l297 < 2; l297 = l297 + 1) {
			fRec348[l297] = 0.0;
		}
		for (int l298 = 0; l298 < 2; l298 = l298 + 1) {
			fRec347[l298] = 0.0;
		}
		for (int l299 = 0; l299 < 2; l299 = l299 + 1) {
			fRec345[l299] = 0.0;
		}
		for (int l300 = 0; l300 < 2; l300 = l300 + 1) {
			fRec346[l300] = 0.0;
		}
		for (int l301 = 0; l301 < 2; l301 = l301 + 1) {
			fRec323[l301] = 0.0;
		}
		for (int l302 = 0; l302 < 2; l302 = l302 + 1) {
			fRec324[l302] = 0.0;
		}
		for (int l303 = 0; l303 < 2; l303 = l303 + 1) {
			fRec351[l303] = 0.0;
		}
		for (int l304 = 0; l304 < 2; l304 = l304 + 1) {
			fRec352[l304] = 0.0;
		}
		for (int l305 = 0; l305 < 2; l305 = l305 + 1) {
			fRec354[l305] = 0.0;
		}
		for (int l306 = 0; l306 < 2; l306 = l306 + 1) {
			fRec355[l306] = 0.0;
		}
		for (int l307 = 0; l307 < 2; l307 = l307 + 1) {
			fRec357[l307] = 0.0;
		}
		for (int l308 = 0; l308 < 2; l308 = l308 + 1) {
			fRec358[l308] = 0.0;
		}
		for (int l309 = 0; l309 < 2; l309 = l309 + 1) {
			fRec360[l309] = 0.0;
		}
		for (int l310 = 0; l310 < 2; l310 = l310 + 1) {
			fRec361[l310] = 0.0;
		}
		for (int l311 = 0; l311 < 2; l311 = l311 + 1) {
			fRec363[l311] = 0.0;
		}
		for (int l312 = 0; l312 < 2; l312 = l312 + 1) {
			fRec364[l312] = 0.0;
		}
		for (int l313 = 0; l313 < 2; l313 = l313 + 1) {
			fRec366[l313] = 0.0;
		}
		for (int l314 = 0; l314 < 2; l314 = l314 + 1) {
			fRec367[l314] = 0.0;
		}
		for (int l315 = 0; l315 < 2; l315 = l315 + 1) {
			fRec369[l315] = 0.0;
		}
		for (int l316 = 0; l316 < 2; l316 = l316 + 1) {
			fRec370[l316] = 0.0;
		}
		for (int l317 = 0; l317 < 2; l317 = l317 + 1) {
			fRec372[l317] = 0.0;
		}
		for (int l318 = 0; l318 < 2; l318 = l318 + 1) {
			fRec373[l318] = 0.0;
		}
		for (int l319 = 0; l319 < 2; l319 = l319 + 1) {
			fRec375[l319] = 0.0;
		}
		for (int l320 = 0; l320 < 2; l320 = l320 + 1) {
			fRec376[l320] = 0.0;
		}
		for (int l321 = 0; l321 < 2; l321 = l321 + 1) {
			fRec378[l321] = 0.0;
		}
		for (int l322 = 0; l322 < 2; l322 = l322 + 1) {
			fRec379[l322] = 0.0;
		}
		for (int l323 = 0; l323 < 2; l323 = l323 + 1) {
			fRec381[l323] = 0.0;
		}
		for (int l324 = 0; l324 < 2; l324 = l324 + 1) {
			fRec382[l324] = 0.0;
		}
		for (int l325 = 0; l325 < 2; l325 = l325 + 1) {
			fRec384[l325] = 0.0;
		}
		for (int l326 = 0; l326 < 2; l326 = l326 + 1) {
			fRec385[l326] = 0.0;
		}
		for (int l327 = 0; l327 < 2; l327 = l327 + 1) {
			fRec387[l327] = 0.0;
		}
		for (int l328 = 0; l328 < 2; l328 = l328 + 1) {
			fRec388[l328] = 0.0;
		}
		for (int l329 = 0; l329 < 2; l329 = l329 + 1) {
			fRec390[l329] = 0.0;
		}
		for (int l330 = 0; l330 < 2; l330 = l330 + 1) {
			fRec391[l330] = 0.0;
		}
		for (int l331 = 0; l331 < 2; l331 = l331 + 1) {
			fRec393[l331] = 0.0;
		}
		for (int l332 = 0; l332 < 2; l332 = l332 + 1) {
			fRec394[l332] = 0.0;
		}
		for (int l333 = 0; l333 < 2; l333 = l333 + 1) {
			fRec396[l333] = 0.0;
		}
		for (int l334 = 0; l334 < 2; l334 = l334 + 1) {
			fRec397[l334] = 0.0;
		}
		for (int l335 = 0; l335 < 2; l335 = l335 + 1) {
			fRec399[l335] = 0.0;
		}
		for (int l336 = 0; l336 < 2; l336 = l336 + 1) {
			fRec400[l336] = 0.0;
		}
		for (int l337 = 0; l337 < 2; l337 = l337 + 1) {
			fRec402[l337] = 0.0;
		}
		for (int l338 = 0; l338 < 2; l338 = l338 + 1) {
			fRec403[l338] = 0.0;
		}
		for (int l339 = 0; l339 < 2; l339 = l339 + 1) {
			fRec405[l339] = 0.0;
		}
		for (int l340 = 0; l340 < 2; l340 = l340 + 1) {
			fRec406[l340] = 0.0;
		}
		for (int l341 = 0; l341 < 2; l341 = l341 + 1) {
			fRec408[l341] = 0.0;
		}
		for (int l342 = 0; l342 < 2; l342 = l342 + 1) {
			fRec409[l342] = 0.0;
		}
		for (int l343 = 0; l343 < 2; l343 = l343 + 1) {
			fRec411[l343] = 0.0;
		}
		for (int l344 = 0; l344 < 2; l344 = l344 + 1) {
			fRec412[l344] = 0.0;
		}
		for (int l345 = 0; l345 < 2; l345 = l345 + 1) {
			fRec414[l345] = 0.0;
		}
		for (int l346 = 0; l346 < 2; l346 = l346 + 1) {
			fRec415[l346] = 0.0;
		}
		for (int l347 = 0; l347 < 2; l347 = l347 + 1) {
			fRec417[l347] = 0.0;
		}
		for (int l348 = 0; l348 < 2; l348 = l348 + 1) {
			fRec418[l348] = 0.0;
		}
		for (int l349 = 0; l349 < 2; l349 = l349 + 1) {
			fRec420[l349] = 0.0;
		}
		for (int l350 = 0; l350 < 2; l350 = l350 + 1) {
			fRec421[l350] = 0.0;
		}
		for (int l351 = 0; l351 < 2; l351 = l351 + 1) {
			fRec423[l351] = 0.0;
		}
		for (int l352 = 0; l352 < 2; l352 = l352 + 1) {
			fRec424[l352] = 0.0;
		}
		for (int l353 = 0; l353 < 2; l353 = l353 + 1) {
			fRec426[l353] = 0.0;
		}
		for (int l354 = 0; l354 < 2; l354 = l354 + 1) {
			fRec427[l354] = 0.0;
		}
		for (int l355 = 0; l355 < 2; l355 = l355 + 1) {
			fRec429[l355] = 0.0;
		}
		for (int l356 = 0; l356 < 2; l356 = l356 + 1) {
			fRec430[l356] = 0.0;
		}
		for (int l357 = 0; l357 < 2; l357 = l357 + 1) {
			fRec432[l357] = 0.0;
		}
		for (int l358 = 0; l358 < 2; l358 = l358 + 1) {
			fRec433[l358] = 0.0;
		}
		for (int l359 = 0; l359 < 2; l359 = l359 + 1) {
			fRec435[l359] = 0.0;
		}
		for (int l360 = 0; l360 < 2; l360 = l360 + 1) {
			fRec436[l360] = 0.0;
		}
		for (int l361 = 0; l361 < 2; l361 = l361 + 1) {
			fRec438[l361] = 0.0;
		}
		for (int l362 = 0; l362 < 2; l362 = l362 + 1) {
			fRec439[l362] = 0.0;
		}
		for (int l363 = 0; l363 < 2; l363 = l363 + 1) {
			fRec441[l363] = 0.0;
		}
		for (int l364 = 0; l364 < 2; l364 = l364 + 1) {
			fRec442[l364] = 0.0;
		}
		for (int l365 = 0; l365 < 2; l365 = l365 + 1) {
			fRec303[l365] = 0.0;
		}
		for (int l366 = 0; l366 < 2; l366 = l366 + 1) {
			fRec5[l366] = 0.0;
		}
		for (int l367 = 0; l367 < 2; l367 = l367 + 1) {
			fRec450[l367] = 0.0;
		}
		for (int l368 = 0; l368 < 2; l368 = l368 + 1) {
			iVec26[l368] = 0;
		}
		for (int l369 = 0; l369 < 2; l369 = l369 + 1) {
			iRec451[l369] = 0;
		}
		for (int l370 = 0; l370 < 2; l370 = l370 + 1) {
			fRec449[l370] = 0.0;
		}
		for (int l371 = 0; l371 < 2; l371 = l371 + 1) {
			fRec448[l371] = 0.0;
		}
		for (int l372 = 0; l372 < 2; l372 = l372 + 1) {
			fRec446[l372] = 0.0;
		}
		for (int l373 = 0; l373 < 2; l373 = l373 + 1) {
			fRec447[l373] = 0.0;
		}
		for (int l374 = 0; l374 < 2; l374 = l374 + 1) {
			fRec457[l374] = 0.0;
		}
		for (int l375 = 0; l375 < 2; l375 = l375 + 1) {
			iVec27[l375] = 0;
		}
		for (int l376 = 0; l376 < 2; l376 = l376 + 1) {
			iRec458[l376] = 0;
		}
		for (int l377 = 0; l377 < 2; l377 = l377 + 1) {
			fRec456[l377] = 0.0;
		}
		for (int l378 = 0; l378 < 2; l378 = l378 + 1) {
			fRec455[l378] = 0.0;
		}
		for (int l379 = 0; l379 < 2; l379 = l379 + 1) {
			fRec453[l379] = 0.0;
		}
		for (int l380 = 0; l380 < 2; l380 = l380 + 1) {
			fRec454[l380] = 0.0;
		}
		for (int l381 = 0; l381 < 2; l381 = l381 + 1) {
			fRec452[l381] = 0.0;
		}
		for (int l382 = 0; l382 < 2; l382 = l382 + 1) {
			fRec463[l382] = 0.0;
		}
		for (int l383 = 0; l383 < 2; l383 = l383 + 1) {
			iVec28[l383] = 0;
		}
		for (int l384 = 0; l384 < 2; l384 = l384 + 1) {
			iRec464[l384] = 0;
		}
		for (int l385 = 0; l385 < 2; l385 = l385 + 1) {
			fRec462[l385] = 0.0;
		}
		for (int l386 = 0; l386 < 2; l386 = l386 + 1) {
			fRec461[l386] = 0.0;
		}
		for (int l387 = 0; l387 < 2; l387 = l387 + 1) {
			fRec459[l387] = 0.0;
		}
		for (int l388 = 0; l388 < 2; l388 = l388 + 1) {
			fRec460[l388] = 0.0;
		}
		for (int l389 = 0; l389 < 2; l389 = l389 + 1) {
			fVec29[l389] = 0.0;
		}
		for (int l390 = 0; l390 < 2; l390 = l390 + 1) {
			fRec444[l390] = 0.0;
		}
		for (int l391 = 0; l391 < 2; l391 = l391 + 1) {
			fRec472[l391] = 0.0;
		}
		for (int l392 = 0; l392 < 2; l392 = l392 + 1) {
			iVec30[l392] = 0;
		}
		for (int l393 = 0; l393 < 2; l393 = l393 + 1) {
			iRec473[l393] = 0;
		}
		for (int l394 = 0; l394 < 2; l394 = l394 + 1) {
			fRec471[l394] = 0.0;
		}
		for (int l395 = 0; l395 < 2; l395 = l395 + 1) {
			fRec470[l395] = 0.0;
		}
		for (int l396 = 0; l396 < 2; l396 = l396 + 1) {
			fRec468[l396] = 0.0;
		}
		for (int l397 = 0; l397 < 2; l397 = l397 + 1) {
			fRec469[l397] = 0.0;
		}
		for (int l398 = 0; l398 < 2; l398 = l398 + 1) {
			fRec478[l398] = 0.0;
		}
		for (int l399 = 0; l399 < 2; l399 = l399 + 1) {
			iVec31[l399] = 0;
		}
		for (int l400 = 0; l400 < 2; l400 = l400 + 1) {
			iRec479[l400] = 0;
		}
		for (int l401 = 0; l401 < 2; l401 = l401 + 1) {
			fRec477[l401] = 0.0;
		}
		for (int l402 = 0; l402 < 2; l402 = l402 + 1) {
			fRec476[l402] = 0.0;
		}
		for (int l403 = 0; l403 < 2; l403 = l403 + 1) {
			fRec474[l403] = 0.0;
		}
		for (int l404 = 0; l404 < 2; l404 = l404 + 1) {
			fRec475[l404] = 0.0;
		}
		for (int l405 = 0; l405 < 2; l405 = l405 + 1) {
			fRec480[l405] = 0.0;
		}
		for (int l406 = 0; l406 < 2; l406 = l406 + 1) {
			fRec485[l406] = 0.0;
		}
		for (int l407 = 0; l407 < 2; l407 = l407 + 1) {
			iVec32[l407] = 0;
		}
		for (int l408 = 0; l408 < 2; l408 = l408 + 1) {
			iRec486[l408] = 0;
		}
		for (int l409 = 0; l409 < 2; l409 = l409 + 1) {
			fRec484[l409] = 0.0;
		}
		for (int l410 = 0; l410 < 2; l410 = l410 + 1) {
			fRec483[l410] = 0.0;
		}
		for (int l411 = 0; l411 < 2; l411 = l411 + 1) {
			fRec481[l411] = 0.0;
		}
		for (int l412 = 0; l412 < 2; l412 = l412 + 1) {
			fRec482[l412] = 0.0;
		}
		for (int l413 = 0; l413 < 2; l413 = l413 + 1) {
			fRec491[l413] = 0.0;
		}
		for (int l414 = 0; l414 < 2; l414 = l414 + 1) {
			iVec33[l414] = 0;
		}
		for (int l415 = 0; l415 < 2; l415 = l415 + 1) {
			iRec492[l415] = 0;
		}
		for (int l416 = 0; l416 < 2; l416 = l416 + 1) {
			fRec490[l416] = 0.0;
		}
		for (int l417 = 0; l417 < 2; l417 = l417 + 1) {
			fRec489[l417] = 0.0;
		}
		for (int l418 = 0; l418 < 2; l418 = l418 + 1) {
			fRec487[l418] = 0.0;
		}
		for (int l419 = 0; l419 < 2; l419 = l419 + 1) {
			fRec488[l419] = 0.0;
		}
		for (int l420 = 0; l420 < 2; l420 = l420 + 1) {
			fRec465[l420] = 0.0;
		}
		for (int l421 = 0; l421 < 2; l421 = l421 + 1) {
			fRec466[l421] = 0.0;
		}
		for (int l422 = 0; l422 < 2; l422 = l422 + 1) {
			fRec493[l422] = 0.0;
		}
		for (int l423 = 0; l423 < 2; l423 = l423 + 1) {
			fRec494[l423] = 0.0;
		}
		for (int l424 = 0; l424 < 2; l424 = l424 + 1) {
			fRec496[l424] = 0.0;
		}
		for (int l425 = 0; l425 < 2; l425 = l425 + 1) {
			fRec497[l425] = 0.0;
		}
		for (int l426 = 0; l426 < 2; l426 = l426 + 1) {
			fRec499[l426] = 0.0;
		}
		for (int l427 = 0; l427 < 2; l427 = l427 + 1) {
			fRec500[l427] = 0.0;
		}
		for (int l428 = 0; l428 < 2; l428 = l428 + 1) {
			fRec502[l428] = 0.0;
		}
		for (int l429 = 0; l429 < 2; l429 = l429 + 1) {
			fRec503[l429] = 0.0;
		}
		for (int l430 = 0; l430 < 2; l430 = l430 + 1) {
			fRec505[l430] = 0.0;
		}
		for (int l431 = 0; l431 < 2; l431 = l431 + 1) {
			fRec506[l431] = 0.0;
		}
		for (int l432 = 0; l432 < 2; l432 = l432 + 1) {
			fRec508[l432] = 0.0;
		}
		for (int l433 = 0; l433 < 2; l433 = l433 + 1) {
			fRec509[l433] = 0.0;
		}
		for (int l434 = 0; l434 < 2; l434 = l434 + 1) {
			fRec511[l434] = 0.0;
		}
		for (int l435 = 0; l435 < 2; l435 = l435 + 1) {
			fRec512[l435] = 0.0;
		}
		for (int l436 = 0; l436 < 2; l436 = l436 + 1) {
			fRec514[l436] = 0.0;
		}
		for (int l437 = 0; l437 < 2; l437 = l437 + 1) {
			fRec515[l437] = 0.0;
		}
		for (int l438 = 0; l438 < 2; l438 = l438 + 1) {
			fRec517[l438] = 0.0;
		}
		for (int l439 = 0; l439 < 2; l439 = l439 + 1) {
			fRec518[l439] = 0.0;
		}
		for (int l440 = 0; l440 < 2; l440 = l440 + 1) {
			fRec520[l440] = 0.0;
		}
		for (int l441 = 0; l441 < 2; l441 = l441 + 1) {
			fRec521[l441] = 0.0;
		}
		for (int l442 = 0; l442 < 2; l442 = l442 + 1) {
			fRec523[l442] = 0.0;
		}
		for (int l443 = 0; l443 < 2; l443 = l443 + 1) {
			fRec524[l443] = 0.0;
		}
		for (int l444 = 0; l444 < 2; l444 = l444 + 1) {
			fRec526[l444] = 0.0;
		}
		for (int l445 = 0; l445 < 2; l445 = l445 + 1) {
			fRec527[l445] = 0.0;
		}
		for (int l446 = 0; l446 < 2; l446 = l446 + 1) {
			fRec529[l446] = 0.0;
		}
		for (int l447 = 0; l447 < 2; l447 = l447 + 1) {
			fRec530[l447] = 0.0;
		}
		for (int l448 = 0; l448 < 2; l448 = l448 + 1) {
			fRec532[l448] = 0.0;
		}
		for (int l449 = 0; l449 < 2; l449 = l449 + 1) {
			fRec533[l449] = 0.0;
		}
		for (int l450 = 0; l450 < 2; l450 = l450 + 1) {
			fRec535[l450] = 0.0;
		}
		for (int l451 = 0; l451 < 2; l451 = l451 + 1) {
			fRec536[l451] = 0.0;
		}
		for (int l452 = 0; l452 < 2; l452 = l452 + 1) {
			fRec538[l452] = 0.0;
		}
		for (int l453 = 0; l453 < 2; l453 = l453 + 1) {
			fRec539[l453] = 0.0;
		}
		for (int l454 = 0; l454 < 2; l454 = l454 + 1) {
			fRec541[l454] = 0.0;
		}
		for (int l455 = 0; l455 < 2; l455 = l455 + 1) {
			fRec542[l455] = 0.0;
		}
		for (int l456 = 0; l456 < 2; l456 = l456 + 1) {
			fRec544[l456] = 0.0;
		}
		for (int l457 = 0; l457 < 2; l457 = l457 + 1) {
			fRec545[l457] = 0.0;
		}
		for (int l458 = 0; l458 < 2; l458 = l458 + 1) {
			fRec547[l458] = 0.0;
		}
		for (int l459 = 0; l459 < 2; l459 = l459 + 1) {
			fRec548[l459] = 0.0;
		}
		for (int l460 = 0; l460 < 2; l460 = l460 + 1) {
			fRec550[l460] = 0.0;
		}
		for (int l461 = 0; l461 < 2; l461 = l461 + 1) {
			fRec551[l461] = 0.0;
		}
		for (int l462 = 0; l462 < 2; l462 = l462 + 1) {
			fRec553[l462] = 0.0;
		}
		for (int l463 = 0; l463 < 2; l463 = l463 + 1) {
			fRec554[l463] = 0.0;
		}
		for (int l464 = 0; l464 < 2; l464 = l464 + 1) {
			fRec556[l464] = 0.0;
		}
		for (int l465 = 0; l465 < 2; l465 = l465 + 1) {
			fRec557[l465] = 0.0;
		}
		for (int l466 = 0; l466 < 2; l466 = l466 + 1) {
			fRec559[l466] = 0.0;
		}
		for (int l467 = 0; l467 < 2; l467 = l467 + 1) {
			fRec560[l467] = 0.0;
		}
		for (int l468 = 0; l468 < 2; l468 = l468 + 1) {
			fRec562[l468] = 0.0;
		}
		for (int l469 = 0; l469 < 2; l469 = l469 + 1) {
			fRec563[l469] = 0.0;
		}
		for (int l470 = 0; l470 < 2; l470 = l470 + 1) {
			fRec565[l470] = 0.0;
		}
		for (int l471 = 0; l471 < 2; l471 = l471 + 1) {
			fRec566[l471] = 0.0;
		}
		for (int l472 = 0; l472 < 2; l472 = l472 + 1) {
			fRec568[l472] = 0.0;
		}
		for (int l473 = 0; l473 < 2; l473 = l473 + 1) {
			fRec569[l473] = 0.0;
		}
		for (int l474 = 0; l474 < 2; l474 = l474 + 1) {
			fRec571[l474] = 0.0;
		}
		for (int l475 = 0; l475 < 2; l475 = l475 + 1) {
			fRec572[l475] = 0.0;
		}
		for (int l476 = 0; l476 < 2; l476 = l476 + 1) {
			fRec574[l476] = 0.0;
		}
		for (int l477 = 0; l477 < 2; l477 = l477 + 1) {
			fRec575[l477] = 0.0;
		}
		for (int l478 = 0; l478 < 2; l478 = l478 + 1) {
			fRec577[l478] = 0.0;
		}
		for (int l479 = 0; l479 < 2; l479 = l479 + 1) {
			fRec578[l479] = 0.0;
		}
		for (int l480 = 0; l480 < 2; l480 = l480 + 1) {
			fRec580[l480] = 0.0;
		}
		for (int l481 = 0; l481 < 2; l481 = l481 + 1) {
			fRec581[l481] = 0.0;
		}
		for (int l482 = 0; l482 < 2; l482 = l482 + 1) {
			fRec583[l482] = 0.0;
		}
		for (int l483 = 0; l483 < 2; l483 = l483 + 1) {
			fRec584[l483] = 0.0;
		}
		for (int l484 = 0; l484 < 2; l484 = l484 + 1) {
			fRec445[l484] = 0.0;
		}
		for (int l485 = 0; l485 < 2; l485 = l485 + 1) {
			fRec6[l485] = 0.0;
		}
		for (int l486 = 0; l486 < 2; l486 = l486 + 1) {
			fRec592[l486] = 0.0;
		}
		for (int l487 = 0; l487 < 2; l487 = l487 + 1) {
			iVec34[l487] = 0;
		}
		for (int l488 = 0; l488 < 2; l488 = l488 + 1) {
			iRec593[l488] = 0;
		}
		for (int l489 = 0; l489 < 2; l489 = l489 + 1) {
			fRec591[l489] = 0.0;
		}
		for (int l490 = 0; l490 < 2; l490 = l490 + 1) {
			fRec590[l490] = 0.0;
		}
		for (int l491 = 0; l491 < 2; l491 = l491 + 1) {
			fRec588[l491] = 0.0;
		}
		for (int l492 = 0; l492 < 2; l492 = l492 + 1) {
			fRec589[l492] = 0.0;
		}
		for (int l493 = 0; l493 < 2; l493 = l493 + 1) {
			fRec599[l493] = 0.0;
		}
		for (int l494 = 0; l494 < 2; l494 = l494 + 1) {
			iVec35[l494] = 0;
		}
		for (int l495 = 0; l495 < 2; l495 = l495 + 1) {
			iRec600[l495] = 0;
		}
		for (int l496 = 0; l496 < 2; l496 = l496 + 1) {
			fRec598[l496] = 0.0;
		}
		for (int l497 = 0; l497 < 2; l497 = l497 + 1) {
			fRec597[l497] = 0.0;
		}
		for (int l498 = 0; l498 < 2; l498 = l498 + 1) {
			fRec595[l498] = 0.0;
		}
		for (int l499 = 0; l499 < 2; l499 = l499 + 1) {
			fRec596[l499] = 0.0;
		}
		for (int l500 = 0; l500 < 2; l500 = l500 + 1) {
			fRec594[l500] = 0.0;
		}
		for (int l501 = 0; l501 < 2; l501 = l501 + 1) {
			fRec605[l501] = 0.0;
		}
		for (int l502 = 0; l502 < 2; l502 = l502 + 1) {
			iVec36[l502] = 0;
		}
		for (int l503 = 0; l503 < 2; l503 = l503 + 1) {
			iRec606[l503] = 0;
		}
		for (int l504 = 0; l504 < 2; l504 = l504 + 1) {
			fRec604[l504] = 0.0;
		}
		for (int l505 = 0; l505 < 2; l505 = l505 + 1) {
			fRec603[l505] = 0.0;
		}
		for (int l506 = 0; l506 < 2; l506 = l506 + 1) {
			fRec601[l506] = 0.0;
		}
		for (int l507 = 0; l507 < 2; l507 = l507 + 1) {
			fRec602[l507] = 0.0;
		}
		for (int l508 = 0; l508 < 2; l508 = l508 + 1) {
			fVec37[l508] = 0.0;
		}
		for (int l509 = 0; l509 < 2; l509 = l509 + 1) {
			fRec586[l509] = 0.0;
		}
		for (int l510 = 0; l510 < 2; l510 = l510 + 1) {
			fRec614[l510] = 0.0;
		}
		for (int l511 = 0; l511 < 2; l511 = l511 + 1) {
			iVec38[l511] = 0;
		}
		for (int l512 = 0; l512 < 2; l512 = l512 + 1) {
			iRec615[l512] = 0;
		}
		for (int l513 = 0; l513 < 2; l513 = l513 + 1) {
			fRec613[l513] = 0.0;
		}
		for (int l514 = 0; l514 < 2; l514 = l514 + 1) {
			fRec612[l514] = 0.0;
		}
		for (int l515 = 0; l515 < 2; l515 = l515 + 1) {
			fRec610[l515] = 0.0;
		}
		for (int l516 = 0; l516 < 2; l516 = l516 + 1) {
			fRec611[l516] = 0.0;
		}
		for (int l517 = 0; l517 < 2; l517 = l517 + 1) {
			fRec620[l517] = 0.0;
		}
		for (int l518 = 0; l518 < 2; l518 = l518 + 1) {
			iVec39[l518] = 0;
		}
		for (int l519 = 0; l519 < 2; l519 = l519 + 1) {
			iRec621[l519] = 0;
		}
		for (int l520 = 0; l520 < 2; l520 = l520 + 1) {
			fRec619[l520] = 0.0;
		}
		for (int l521 = 0; l521 < 2; l521 = l521 + 1) {
			fRec618[l521] = 0.0;
		}
		for (int l522 = 0; l522 < 2; l522 = l522 + 1) {
			fRec616[l522] = 0.0;
		}
		for (int l523 = 0; l523 < 2; l523 = l523 + 1) {
			fRec617[l523] = 0.0;
		}
		for (int l524 = 0; l524 < 2; l524 = l524 + 1) {
			fRec622[l524] = 0.0;
		}
		for (int l525 = 0; l525 < 2; l525 = l525 + 1) {
			fRec627[l525] = 0.0;
		}
		for (int l526 = 0; l526 < 2; l526 = l526 + 1) {
			iVec40[l526] = 0;
		}
		for (int l527 = 0; l527 < 2; l527 = l527 + 1) {
			iRec628[l527] = 0;
		}
		for (int l528 = 0; l528 < 2; l528 = l528 + 1) {
			fRec626[l528] = 0.0;
		}
		for (int l529 = 0; l529 < 2; l529 = l529 + 1) {
			fRec625[l529] = 0.0;
		}
		for (int l530 = 0; l530 < 2; l530 = l530 + 1) {
			fRec623[l530] = 0.0;
		}
		for (int l531 = 0; l531 < 2; l531 = l531 + 1) {
			fRec624[l531] = 0.0;
		}
		for (int l532 = 0; l532 < 2; l532 = l532 + 1) {
			fRec633[l532] = 0.0;
		}
		for (int l533 = 0; l533 < 2; l533 = l533 + 1) {
			iVec41[l533] = 0;
		}
		for (int l534 = 0; l534 < 2; l534 = l534 + 1) {
			iRec634[l534] = 0;
		}
		for (int l535 = 0; l535 < 2; l535 = l535 + 1) {
			fRec632[l535] = 0.0;
		}
		for (int l536 = 0; l536 < 2; l536 = l536 + 1) {
			fRec631[l536] = 0.0;
		}
		for (int l537 = 0; l537 < 2; l537 = l537 + 1) {
			fRec629[l537] = 0.0;
		}
		for (int l538 = 0; l538 < 2; l538 = l538 + 1) {
			fRec630[l538] = 0.0;
		}
		for (int l539 = 0; l539 < 2; l539 = l539 + 1) {
			fRec607[l539] = 0.0;
		}
		for (int l540 = 0; l540 < 2; l540 = l540 + 1) {
			fRec608[l540] = 0.0;
		}
		for (int l541 = 0; l541 < 2; l541 = l541 + 1) {
			fRec635[l541] = 0.0;
		}
		for (int l542 = 0; l542 < 2; l542 = l542 + 1) {
			fRec636[l542] = 0.0;
		}
		for (int l543 = 0; l543 < 2; l543 = l543 + 1) {
			fRec638[l543] = 0.0;
		}
		for (int l544 = 0; l544 < 2; l544 = l544 + 1) {
			fRec639[l544] = 0.0;
		}
		for (int l545 = 0; l545 < 2; l545 = l545 + 1) {
			fRec641[l545] = 0.0;
		}
		for (int l546 = 0; l546 < 2; l546 = l546 + 1) {
			fRec642[l546] = 0.0;
		}
		for (int l547 = 0; l547 < 2; l547 = l547 + 1) {
			fRec644[l547] = 0.0;
		}
		for (int l548 = 0; l548 < 2; l548 = l548 + 1) {
			fRec645[l548] = 0.0;
		}
		for (int l549 = 0; l549 < 2; l549 = l549 + 1) {
			fRec647[l549] = 0.0;
		}
		for (int l550 = 0; l550 < 2; l550 = l550 + 1) {
			fRec648[l550] = 0.0;
		}
		for (int l551 = 0; l551 < 2; l551 = l551 + 1) {
			fRec650[l551] = 0.0;
		}
		for (int l552 = 0; l552 < 2; l552 = l552 + 1) {
			fRec651[l552] = 0.0;
		}
		for (int l553 = 0; l553 < 2; l553 = l553 + 1) {
			fRec653[l553] = 0.0;
		}
		for (int l554 = 0; l554 < 2; l554 = l554 + 1) {
			fRec654[l554] = 0.0;
		}
		for (int l555 = 0; l555 < 2; l555 = l555 + 1) {
			fRec656[l555] = 0.0;
		}
		for (int l556 = 0; l556 < 2; l556 = l556 + 1) {
			fRec657[l556] = 0.0;
		}
		for (int l557 = 0; l557 < 2; l557 = l557 + 1) {
			fRec659[l557] = 0.0;
		}
		for (int l558 = 0; l558 < 2; l558 = l558 + 1) {
			fRec660[l558] = 0.0;
		}
		for (int l559 = 0; l559 < 2; l559 = l559 + 1) {
			fRec662[l559] = 0.0;
		}
		for (int l560 = 0; l560 < 2; l560 = l560 + 1) {
			fRec663[l560] = 0.0;
		}
		for (int l561 = 0; l561 < 2; l561 = l561 + 1) {
			fRec665[l561] = 0.0;
		}
		for (int l562 = 0; l562 < 2; l562 = l562 + 1) {
			fRec666[l562] = 0.0;
		}
		for (int l563 = 0; l563 < 2; l563 = l563 + 1) {
			fRec668[l563] = 0.0;
		}
		for (int l564 = 0; l564 < 2; l564 = l564 + 1) {
			fRec669[l564] = 0.0;
		}
		for (int l565 = 0; l565 < 2; l565 = l565 + 1) {
			fRec671[l565] = 0.0;
		}
		for (int l566 = 0; l566 < 2; l566 = l566 + 1) {
			fRec672[l566] = 0.0;
		}
		for (int l567 = 0; l567 < 2; l567 = l567 + 1) {
			fRec674[l567] = 0.0;
		}
		for (int l568 = 0; l568 < 2; l568 = l568 + 1) {
			fRec675[l568] = 0.0;
		}
		for (int l569 = 0; l569 < 2; l569 = l569 + 1) {
			fRec677[l569] = 0.0;
		}
		for (int l570 = 0; l570 < 2; l570 = l570 + 1) {
			fRec678[l570] = 0.0;
		}
		for (int l571 = 0; l571 < 2; l571 = l571 + 1) {
			fRec680[l571] = 0.0;
		}
		for (int l572 = 0; l572 < 2; l572 = l572 + 1) {
			fRec681[l572] = 0.0;
		}
		for (int l573 = 0; l573 < 2; l573 = l573 + 1) {
			fRec683[l573] = 0.0;
		}
		for (int l574 = 0; l574 < 2; l574 = l574 + 1) {
			fRec684[l574] = 0.0;
		}
		for (int l575 = 0; l575 < 2; l575 = l575 + 1) {
			fRec686[l575] = 0.0;
		}
		for (int l576 = 0; l576 < 2; l576 = l576 + 1) {
			fRec687[l576] = 0.0;
		}
		for (int l577 = 0; l577 < 2; l577 = l577 + 1) {
			fRec689[l577] = 0.0;
		}
		for (int l578 = 0; l578 < 2; l578 = l578 + 1) {
			fRec690[l578] = 0.0;
		}
		for (int l579 = 0; l579 < 2; l579 = l579 + 1) {
			fRec692[l579] = 0.0;
		}
		for (int l580 = 0; l580 < 2; l580 = l580 + 1) {
			fRec693[l580] = 0.0;
		}
		for (int l581 = 0; l581 < 2; l581 = l581 + 1) {
			fRec695[l581] = 0.0;
		}
		for (int l582 = 0; l582 < 2; l582 = l582 + 1) {
			fRec696[l582] = 0.0;
		}
		for (int l583 = 0; l583 < 2; l583 = l583 + 1) {
			fRec698[l583] = 0.0;
		}
		for (int l584 = 0; l584 < 2; l584 = l584 + 1) {
			fRec699[l584] = 0.0;
		}
		for (int l585 = 0; l585 < 2; l585 = l585 + 1) {
			fRec701[l585] = 0.0;
		}
		for (int l586 = 0; l586 < 2; l586 = l586 + 1) {
			fRec702[l586] = 0.0;
		}
		for (int l587 = 0; l587 < 2; l587 = l587 + 1) {
			fRec704[l587] = 0.0;
		}
		for (int l588 = 0; l588 < 2; l588 = l588 + 1) {
			fRec705[l588] = 0.0;
		}
		for (int l589 = 0; l589 < 2; l589 = l589 + 1) {
			fRec707[l589] = 0.0;
		}
		for (int l590 = 0; l590 < 2; l590 = l590 + 1) {
			fRec708[l590] = 0.0;
		}
		for (int l591 = 0; l591 < 2; l591 = l591 + 1) {
			fRec710[l591] = 0.0;
		}
		for (int l592 = 0; l592 < 2; l592 = l592 + 1) {
			fRec711[l592] = 0.0;
		}
		for (int l593 = 0; l593 < 2; l593 = l593 + 1) {
			fRec713[l593] = 0.0;
		}
		for (int l594 = 0; l594 < 2; l594 = l594 + 1) {
			fRec714[l594] = 0.0;
		}
		for (int l595 = 0; l595 < 2; l595 = l595 + 1) {
			fRec716[l595] = 0.0;
		}
		for (int l596 = 0; l596 < 2; l596 = l596 + 1) {
			fRec717[l596] = 0.0;
		}
		for (int l597 = 0; l597 < 2; l597 = l597 + 1) {
			fRec719[l597] = 0.0;
		}
		for (int l598 = 0; l598 < 2; l598 = l598 + 1) {
			fRec720[l598] = 0.0;
		}
		for (int l599 = 0; l599 < 2; l599 = l599 + 1) {
			fRec722[l599] = 0.0;
		}
		for (int l600 = 0; l600 < 2; l600 = l600 + 1) {
			fRec723[l600] = 0.0;
		}
		for (int l601 = 0; l601 < 2; l601 = l601 + 1) {
			fRec725[l601] = 0.0;
		}
		for (int l602 = 0; l602 < 2; l602 = l602 + 1) {
			fRec726[l602] = 0.0;
		}
		for (int l603 = 0; l603 < 2; l603 = l603 + 1) {
			fRec587[l603] = 0.0;
		}
		for (int l604 = 0; l604 < 2; l604 = l604 + 1) {
			fRec7[l604] = 0.0;
		}
		for (int l605 = 0; l605 < 2; l605 = l605 + 1) {
			fRec734[l605] = 0.0;
		}
		for (int l606 = 0; l606 < 2; l606 = l606 + 1) {
			iVec42[l606] = 0;
		}
		for (int l607 = 0; l607 < 2; l607 = l607 + 1) {
			iRec735[l607] = 0;
		}
		for (int l608 = 0; l608 < 2; l608 = l608 + 1) {
			fRec733[l608] = 0.0;
		}
		for (int l609 = 0; l609 < 2; l609 = l609 + 1) {
			fRec732[l609] = 0.0;
		}
		for (int l610 = 0; l610 < 2; l610 = l610 + 1) {
			fRec730[l610] = 0.0;
		}
		for (int l611 = 0; l611 < 2; l611 = l611 + 1) {
			fRec731[l611] = 0.0;
		}
		for (int l612 = 0; l612 < 2; l612 = l612 + 1) {
			fRec741[l612] = 0.0;
		}
		for (int l613 = 0; l613 < 2; l613 = l613 + 1) {
			iVec43[l613] = 0;
		}
		for (int l614 = 0; l614 < 2; l614 = l614 + 1) {
			iRec742[l614] = 0;
		}
		for (int l615 = 0; l615 < 2; l615 = l615 + 1) {
			fRec740[l615] = 0.0;
		}
		for (int l616 = 0; l616 < 2; l616 = l616 + 1) {
			fRec739[l616] = 0.0;
		}
		for (int l617 = 0; l617 < 2; l617 = l617 + 1) {
			fRec737[l617] = 0.0;
		}
		for (int l618 = 0; l618 < 2; l618 = l618 + 1) {
			fRec738[l618] = 0.0;
		}
		for (int l619 = 0; l619 < 2; l619 = l619 + 1) {
			fRec736[l619] = 0.0;
		}
		for (int l620 = 0; l620 < 2; l620 = l620 + 1) {
			fRec747[l620] = 0.0;
		}
		for (int l621 = 0; l621 < 2; l621 = l621 + 1) {
			iVec44[l621] = 0;
		}
		for (int l622 = 0; l622 < 2; l622 = l622 + 1) {
			iRec748[l622] = 0;
		}
		for (int l623 = 0; l623 < 2; l623 = l623 + 1) {
			fRec746[l623] = 0.0;
		}
		for (int l624 = 0; l624 < 2; l624 = l624 + 1) {
			fRec745[l624] = 0.0;
		}
		for (int l625 = 0; l625 < 2; l625 = l625 + 1) {
			fRec743[l625] = 0.0;
		}
		for (int l626 = 0; l626 < 2; l626 = l626 + 1) {
			fRec744[l626] = 0.0;
		}
		for (int l627 = 0; l627 < 2; l627 = l627 + 1) {
			fVec45[l627] = 0.0;
		}
		for (int l628 = 0; l628 < 2; l628 = l628 + 1) {
			fRec728[l628] = 0.0;
		}
		for (int l629 = 0; l629 < 2; l629 = l629 + 1) {
			fRec756[l629] = 0.0;
		}
		for (int l630 = 0; l630 < 2; l630 = l630 + 1) {
			iVec46[l630] = 0;
		}
		for (int l631 = 0; l631 < 2; l631 = l631 + 1) {
			iRec757[l631] = 0;
		}
		for (int l632 = 0; l632 < 2; l632 = l632 + 1) {
			fRec755[l632] = 0.0;
		}
		for (int l633 = 0; l633 < 2; l633 = l633 + 1) {
			fRec754[l633] = 0.0;
		}
		for (int l634 = 0; l634 < 2; l634 = l634 + 1) {
			fRec752[l634] = 0.0;
		}
		for (int l635 = 0; l635 < 2; l635 = l635 + 1) {
			fRec753[l635] = 0.0;
		}
		for (int l636 = 0; l636 < 2; l636 = l636 + 1) {
			fRec762[l636] = 0.0;
		}
		for (int l637 = 0; l637 < 2; l637 = l637 + 1) {
			iVec47[l637] = 0;
		}
		for (int l638 = 0; l638 < 2; l638 = l638 + 1) {
			iRec763[l638] = 0;
		}
		for (int l639 = 0; l639 < 2; l639 = l639 + 1) {
			fRec761[l639] = 0.0;
		}
		for (int l640 = 0; l640 < 2; l640 = l640 + 1) {
			fRec760[l640] = 0.0;
		}
		for (int l641 = 0; l641 < 2; l641 = l641 + 1) {
			fRec758[l641] = 0.0;
		}
		for (int l642 = 0; l642 < 2; l642 = l642 + 1) {
			fRec759[l642] = 0.0;
		}
		for (int l643 = 0; l643 < 2; l643 = l643 + 1) {
			fRec764[l643] = 0.0;
		}
		for (int l644 = 0; l644 < 2; l644 = l644 + 1) {
			fRec769[l644] = 0.0;
		}
		for (int l645 = 0; l645 < 2; l645 = l645 + 1) {
			iVec48[l645] = 0;
		}
		for (int l646 = 0; l646 < 2; l646 = l646 + 1) {
			iRec770[l646] = 0;
		}
		for (int l647 = 0; l647 < 2; l647 = l647 + 1) {
			fRec768[l647] = 0.0;
		}
		for (int l648 = 0; l648 < 2; l648 = l648 + 1) {
			fRec767[l648] = 0.0;
		}
		for (int l649 = 0; l649 < 2; l649 = l649 + 1) {
			fRec765[l649] = 0.0;
		}
		for (int l650 = 0; l650 < 2; l650 = l650 + 1) {
			fRec766[l650] = 0.0;
		}
		for (int l651 = 0; l651 < 2; l651 = l651 + 1) {
			fRec775[l651] = 0.0;
		}
		for (int l652 = 0; l652 < 2; l652 = l652 + 1) {
			iVec49[l652] = 0;
		}
		for (int l653 = 0; l653 < 2; l653 = l653 + 1) {
			iRec776[l653] = 0;
		}
		for (int l654 = 0; l654 < 2; l654 = l654 + 1) {
			fRec774[l654] = 0.0;
		}
		for (int l655 = 0; l655 < 2; l655 = l655 + 1) {
			fRec773[l655] = 0.0;
		}
		for (int l656 = 0; l656 < 2; l656 = l656 + 1) {
			fRec771[l656] = 0.0;
		}
		for (int l657 = 0; l657 < 2; l657 = l657 + 1) {
			fRec772[l657] = 0.0;
		}
		for (int l658 = 0; l658 < 2; l658 = l658 + 1) {
			fRec749[l658] = 0.0;
		}
		for (int l659 = 0; l659 < 2; l659 = l659 + 1) {
			fRec750[l659] = 0.0;
		}
		for (int l660 = 0; l660 < 2; l660 = l660 + 1) {
			fRec777[l660] = 0.0;
		}
		for (int l661 = 0; l661 < 2; l661 = l661 + 1) {
			fRec778[l661] = 0.0;
		}
		for (int l662 = 0; l662 < 2; l662 = l662 + 1) {
			fRec780[l662] = 0.0;
		}
		for (int l663 = 0; l663 < 2; l663 = l663 + 1) {
			fRec781[l663] = 0.0;
		}
		for (int l664 = 0; l664 < 2; l664 = l664 + 1) {
			fRec783[l664] = 0.0;
		}
		for (int l665 = 0; l665 < 2; l665 = l665 + 1) {
			fRec784[l665] = 0.0;
		}
		for (int l666 = 0; l666 < 2; l666 = l666 + 1) {
			fRec786[l666] = 0.0;
		}
		for (int l667 = 0; l667 < 2; l667 = l667 + 1) {
			fRec787[l667] = 0.0;
		}
		for (int l668 = 0; l668 < 2; l668 = l668 + 1) {
			fRec789[l668] = 0.0;
		}
		for (int l669 = 0; l669 < 2; l669 = l669 + 1) {
			fRec790[l669] = 0.0;
		}
		for (int l670 = 0; l670 < 2; l670 = l670 + 1) {
			fRec792[l670] = 0.0;
		}
		for (int l671 = 0; l671 < 2; l671 = l671 + 1) {
			fRec793[l671] = 0.0;
		}
		for (int l672 = 0; l672 < 2; l672 = l672 + 1) {
			fRec795[l672] = 0.0;
		}
		for (int l673 = 0; l673 < 2; l673 = l673 + 1) {
			fRec796[l673] = 0.0;
		}
		for (int l674 = 0; l674 < 2; l674 = l674 + 1) {
			fRec798[l674] = 0.0;
		}
		for (int l675 = 0; l675 < 2; l675 = l675 + 1) {
			fRec799[l675] = 0.0;
		}
		for (int l676 = 0; l676 < 2; l676 = l676 + 1) {
			fRec801[l676] = 0.0;
		}
		for (int l677 = 0; l677 < 2; l677 = l677 + 1) {
			fRec802[l677] = 0.0;
		}
		for (int l678 = 0; l678 < 2; l678 = l678 + 1) {
			fRec804[l678] = 0.0;
		}
		for (int l679 = 0; l679 < 2; l679 = l679 + 1) {
			fRec805[l679] = 0.0;
		}
		for (int l680 = 0; l680 < 2; l680 = l680 + 1) {
			fRec807[l680] = 0.0;
		}
		for (int l681 = 0; l681 < 2; l681 = l681 + 1) {
			fRec808[l681] = 0.0;
		}
		for (int l682 = 0; l682 < 2; l682 = l682 + 1) {
			fRec810[l682] = 0.0;
		}
		for (int l683 = 0; l683 < 2; l683 = l683 + 1) {
			fRec811[l683] = 0.0;
		}
		for (int l684 = 0; l684 < 2; l684 = l684 + 1) {
			fRec813[l684] = 0.0;
		}
		for (int l685 = 0; l685 < 2; l685 = l685 + 1) {
			fRec814[l685] = 0.0;
		}
		for (int l686 = 0; l686 < 2; l686 = l686 + 1) {
			fRec816[l686] = 0.0;
		}
		for (int l687 = 0; l687 < 2; l687 = l687 + 1) {
			fRec817[l687] = 0.0;
		}
		for (int l688 = 0; l688 < 2; l688 = l688 + 1) {
			fRec819[l688] = 0.0;
		}
		for (int l689 = 0; l689 < 2; l689 = l689 + 1) {
			fRec820[l689] = 0.0;
		}
		for (int l690 = 0; l690 < 2; l690 = l690 + 1) {
			fRec822[l690] = 0.0;
		}
		for (int l691 = 0; l691 < 2; l691 = l691 + 1) {
			fRec823[l691] = 0.0;
		}
		for (int l692 = 0; l692 < 2; l692 = l692 + 1) {
			fRec825[l692] = 0.0;
		}
		for (int l693 = 0; l693 < 2; l693 = l693 + 1) {
			fRec826[l693] = 0.0;
		}
		for (int l694 = 0; l694 < 2; l694 = l694 + 1) {
			fRec828[l694] = 0.0;
		}
		for (int l695 = 0; l695 < 2; l695 = l695 + 1) {
			fRec829[l695] = 0.0;
		}
		for (int l696 = 0; l696 < 2; l696 = l696 + 1) {
			fRec831[l696] = 0.0;
		}
		for (int l697 = 0; l697 < 2; l697 = l697 + 1) {
			fRec832[l697] = 0.0;
		}
		for (int l698 = 0; l698 < 2; l698 = l698 + 1) {
			fRec834[l698] = 0.0;
		}
		for (int l699 = 0; l699 < 2; l699 = l699 + 1) {
			fRec835[l699] = 0.0;
		}
		for (int l700 = 0; l700 < 2; l700 = l700 + 1) {
			fRec837[l700] = 0.0;
		}
		for (int l701 = 0; l701 < 2; l701 = l701 + 1) {
			fRec838[l701] = 0.0;
		}
		for (int l702 = 0; l702 < 2; l702 = l702 + 1) {
			fRec840[l702] = 0.0;
		}
		for (int l703 = 0; l703 < 2; l703 = l703 + 1) {
			fRec841[l703] = 0.0;
		}
		for (int l704 = 0; l704 < 2; l704 = l704 + 1) {
			fRec843[l704] = 0.0;
		}
		for (int l705 = 0; l705 < 2; l705 = l705 + 1) {
			fRec844[l705] = 0.0;
		}
		for (int l706 = 0; l706 < 2; l706 = l706 + 1) {
			fRec846[l706] = 0.0;
		}
		for (int l707 = 0; l707 < 2; l707 = l707 + 1) {
			fRec847[l707] = 0.0;
		}
		for (int l708 = 0; l708 < 2; l708 = l708 + 1) {
			fRec849[l708] = 0.0;
		}
		for (int l709 = 0; l709 < 2; l709 = l709 + 1) {
			fRec850[l709] = 0.0;
		}
		for (int l710 = 0; l710 < 2; l710 = l710 + 1) {
			fRec852[l710] = 0.0;
		}
		for (int l711 = 0; l711 < 2; l711 = l711 + 1) {
			fRec853[l711] = 0.0;
		}
		for (int l712 = 0; l712 < 2; l712 = l712 + 1) {
			fRec855[l712] = 0.0;
		}
		for (int l713 = 0; l713 < 2; l713 = l713 + 1) {
			fRec856[l713] = 0.0;
		}
		for (int l714 = 0; l714 < 2; l714 = l714 + 1) {
			fRec858[l714] = 0.0;
		}
		for (int l715 = 0; l715 < 2; l715 = l715 + 1) {
			fRec859[l715] = 0.0;
		}
		for (int l716 = 0; l716 < 2; l716 = l716 + 1) {
			fRec861[l716] = 0.0;
		}
		for (int l717 = 0; l717 < 2; l717 = l717 + 1) {
			fRec862[l717] = 0.0;
		}
		for (int l718 = 0; l718 < 2; l718 = l718 + 1) {
			fRec864[l718] = 0.0;
		}
		for (int l719 = 0; l719 < 2; l719 = l719 + 1) {
			fRec865[l719] = 0.0;
		}
		for (int l720 = 0; l720 < 2; l720 = l720 + 1) {
			fRec867[l720] = 0.0;
		}
		for (int l721 = 0; l721 < 2; l721 = l721 + 1) {
			fRec868[l721] = 0.0;
		}
		for (int l722 = 0; l722 < 2; l722 = l722 + 1) {
			fRec729[l722] = 0.0;
		}
		for (int l723 = 0; l723 < 2; l723 = l723 + 1) {
			fRec8[l723] = 0.0;
		}
		for (int l724 = 0; l724 < 2; l724 = l724 + 1) {
			fRec876[l724] = 0.0;
		}
		for (int l725 = 0; l725 < 2; l725 = l725 + 1) {
			iVec50[l725] = 0;
		}
		for (int l726 = 0; l726 < 2; l726 = l726 + 1) {
			iRec877[l726] = 0;
		}
		for (int l727 = 0; l727 < 2; l727 = l727 + 1) {
			fRec875[l727] = 0.0;
		}
		for (int l728 = 0; l728 < 2; l728 = l728 + 1) {
			fRec874[l728] = 0.0;
		}
		for (int l729 = 0; l729 < 2; l729 = l729 + 1) {
			fRec872[l729] = 0.0;
		}
		for (int l730 = 0; l730 < 2; l730 = l730 + 1) {
			fRec873[l730] = 0.0;
		}
		for (int l731 = 0; l731 < 2; l731 = l731 + 1) {
			fRec883[l731] = 0.0;
		}
		for (int l732 = 0; l732 < 2; l732 = l732 + 1) {
			iVec51[l732] = 0;
		}
		for (int l733 = 0; l733 < 2; l733 = l733 + 1) {
			iRec884[l733] = 0;
		}
		for (int l734 = 0; l734 < 2; l734 = l734 + 1) {
			fRec882[l734] = 0.0;
		}
		for (int l735 = 0; l735 < 2; l735 = l735 + 1) {
			fRec881[l735] = 0.0;
		}
		for (int l736 = 0; l736 < 2; l736 = l736 + 1) {
			fRec879[l736] = 0.0;
		}
		for (int l737 = 0; l737 < 2; l737 = l737 + 1) {
			fRec880[l737] = 0.0;
		}
		for (int l738 = 0; l738 < 2; l738 = l738 + 1) {
			fRec878[l738] = 0.0;
		}
		for (int l739 = 0; l739 < 2; l739 = l739 + 1) {
			fRec889[l739] = 0.0;
		}
		for (int l740 = 0; l740 < 2; l740 = l740 + 1) {
			iVec52[l740] = 0;
		}
		for (int l741 = 0; l741 < 2; l741 = l741 + 1) {
			iRec890[l741] = 0;
		}
		for (int l742 = 0; l742 < 2; l742 = l742 + 1) {
			fRec888[l742] = 0.0;
		}
		for (int l743 = 0; l743 < 2; l743 = l743 + 1) {
			fRec887[l743] = 0.0;
		}
		for (int l744 = 0; l744 < 2; l744 = l744 + 1) {
			fRec885[l744] = 0.0;
		}
		for (int l745 = 0; l745 < 2; l745 = l745 + 1) {
			fRec886[l745] = 0.0;
		}
		for (int l746 = 0; l746 < 2; l746 = l746 + 1) {
			fVec53[l746] = 0.0;
		}
		for (int l747 = 0; l747 < 2; l747 = l747 + 1) {
			fRec870[l747] = 0.0;
		}
		for (int l748 = 0; l748 < 2; l748 = l748 + 1) {
			fRec898[l748] = 0.0;
		}
		for (int l749 = 0; l749 < 2; l749 = l749 + 1) {
			iVec54[l749] = 0;
		}
		for (int l750 = 0; l750 < 2; l750 = l750 + 1) {
			iRec899[l750] = 0;
		}
		for (int l751 = 0; l751 < 2; l751 = l751 + 1) {
			fRec897[l751] = 0.0;
		}
		for (int l752 = 0; l752 < 2; l752 = l752 + 1) {
			fRec896[l752] = 0.0;
		}
		for (int l753 = 0; l753 < 2; l753 = l753 + 1) {
			fRec894[l753] = 0.0;
		}
		for (int l754 = 0; l754 < 2; l754 = l754 + 1) {
			fRec895[l754] = 0.0;
		}
		for (int l755 = 0; l755 < 2; l755 = l755 + 1) {
			fRec904[l755] = 0.0;
		}
		for (int l756 = 0; l756 < 2; l756 = l756 + 1) {
			iVec55[l756] = 0;
		}
		for (int l757 = 0; l757 < 2; l757 = l757 + 1) {
			iRec905[l757] = 0;
		}
		for (int l758 = 0; l758 < 2; l758 = l758 + 1) {
			fRec903[l758] = 0.0;
		}
		for (int l759 = 0; l759 < 2; l759 = l759 + 1) {
			fRec902[l759] = 0.0;
		}
		for (int l760 = 0; l760 < 2; l760 = l760 + 1) {
			fRec900[l760] = 0.0;
		}
		for (int l761 = 0; l761 < 2; l761 = l761 + 1) {
			fRec901[l761] = 0.0;
		}
		for (int l762 = 0; l762 < 2; l762 = l762 + 1) {
			fRec906[l762] = 0.0;
		}
		for (int l763 = 0; l763 < 2; l763 = l763 + 1) {
			fRec911[l763] = 0.0;
		}
		for (int l764 = 0; l764 < 2; l764 = l764 + 1) {
			iVec56[l764] = 0;
		}
		for (int l765 = 0; l765 < 2; l765 = l765 + 1) {
			iRec912[l765] = 0;
		}
		for (int l766 = 0; l766 < 2; l766 = l766 + 1) {
			fRec910[l766] = 0.0;
		}
		for (int l767 = 0; l767 < 2; l767 = l767 + 1) {
			fRec909[l767] = 0.0;
		}
		for (int l768 = 0; l768 < 2; l768 = l768 + 1) {
			fRec907[l768] = 0.0;
		}
		for (int l769 = 0; l769 < 2; l769 = l769 + 1) {
			fRec908[l769] = 0.0;
		}
		for (int l770 = 0; l770 < 2; l770 = l770 + 1) {
			fRec917[l770] = 0.0;
		}
		for (int l771 = 0; l771 < 2; l771 = l771 + 1) {
			iVec57[l771] = 0;
		}
		for (int l772 = 0; l772 < 2; l772 = l772 + 1) {
			iRec918[l772] = 0;
		}
		for (int l773 = 0; l773 < 2; l773 = l773 + 1) {
			fRec916[l773] = 0.0;
		}
		for (int l774 = 0; l774 < 2; l774 = l774 + 1) {
			fRec915[l774] = 0.0;
		}
		for (int l775 = 0; l775 < 2; l775 = l775 + 1) {
			fRec913[l775] = 0.0;
		}
		for (int l776 = 0; l776 < 2; l776 = l776 + 1) {
			fRec914[l776] = 0.0;
		}
		for (int l777 = 0; l777 < 2; l777 = l777 + 1) {
			fRec891[l777] = 0.0;
		}
		for (int l778 = 0; l778 < 2; l778 = l778 + 1) {
			fRec892[l778] = 0.0;
		}
		for (int l779 = 0; l779 < 2; l779 = l779 + 1) {
			fRec919[l779] = 0.0;
		}
		for (int l780 = 0; l780 < 2; l780 = l780 + 1) {
			fRec920[l780] = 0.0;
		}
		for (int l781 = 0; l781 < 2; l781 = l781 + 1) {
			fRec922[l781] = 0.0;
		}
		for (int l782 = 0; l782 < 2; l782 = l782 + 1) {
			fRec923[l782] = 0.0;
		}
		for (int l783 = 0; l783 < 2; l783 = l783 + 1) {
			fRec925[l783] = 0.0;
		}
		for (int l784 = 0; l784 < 2; l784 = l784 + 1) {
			fRec926[l784] = 0.0;
		}
		for (int l785 = 0; l785 < 2; l785 = l785 + 1) {
			fRec928[l785] = 0.0;
		}
		for (int l786 = 0; l786 < 2; l786 = l786 + 1) {
			fRec929[l786] = 0.0;
		}
		for (int l787 = 0; l787 < 2; l787 = l787 + 1) {
			fRec931[l787] = 0.0;
		}
		for (int l788 = 0; l788 < 2; l788 = l788 + 1) {
			fRec932[l788] = 0.0;
		}
		for (int l789 = 0; l789 < 2; l789 = l789 + 1) {
			fRec934[l789] = 0.0;
		}
		for (int l790 = 0; l790 < 2; l790 = l790 + 1) {
			fRec935[l790] = 0.0;
		}
		for (int l791 = 0; l791 < 2; l791 = l791 + 1) {
			fRec937[l791] = 0.0;
		}
		for (int l792 = 0; l792 < 2; l792 = l792 + 1) {
			fRec938[l792] = 0.0;
		}
		for (int l793 = 0; l793 < 2; l793 = l793 + 1) {
			fRec940[l793] = 0.0;
		}
		for (int l794 = 0; l794 < 2; l794 = l794 + 1) {
			fRec941[l794] = 0.0;
		}
		for (int l795 = 0; l795 < 2; l795 = l795 + 1) {
			fRec943[l795] = 0.0;
		}
		for (int l796 = 0; l796 < 2; l796 = l796 + 1) {
			fRec944[l796] = 0.0;
		}
		for (int l797 = 0; l797 < 2; l797 = l797 + 1) {
			fRec946[l797] = 0.0;
		}
		for (int l798 = 0; l798 < 2; l798 = l798 + 1) {
			fRec947[l798] = 0.0;
		}
		for (int l799 = 0; l799 < 2; l799 = l799 + 1) {
			fRec949[l799] = 0.0;
		}
		for (int l800 = 0; l800 < 2; l800 = l800 + 1) {
			fRec950[l800] = 0.0;
		}
		for (int l801 = 0; l801 < 2; l801 = l801 + 1) {
			fRec952[l801] = 0.0;
		}
		for (int l802 = 0; l802 < 2; l802 = l802 + 1) {
			fRec953[l802] = 0.0;
		}
		for (int l803 = 0; l803 < 2; l803 = l803 + 1) {
			fRec955[l803] = 0.0;
		}
		for (int l804 = 0; l804 < 2; l804 = l804 + 1) {
			fRec956[l804] = 0.0;
		}
		for (int l805 = 0; l805 < 2; l805 = l805 + 1) {
			fRec958[l805] = 0.0;
		}
		for (int l806 = 0; l806 < 2; l806 = l806 + 1) {
			fRec959[l806] = 0.0;
		}
		for (int l807 = 0; l807 < 2; l807 = l807 + 1) {
			fRec961[l807] = 0.0;
		}
		for (int l808 = 0; l808 < 2; l808 = l808 + 1) {
			fRec962[l808] = 0.0;
		}
		for (int l809 = 0; l809 < 2; l809 = l809 + 1) {
			fRec964[l809] = 0.0;
		}
		for (int l810 = 0; l810 < 2; l810 = l810 + 1) {
			fRec965[l810] = 0.0;
		}
		for (int l811 = 0; l811 < 2; l811 = l811 + 1) {
			fRec967[l811] = 0.0;
		}
		for (int l812 = 0; l812 < 2; l812 = l812 + 1) {
			fRec968[l812] = 0.0;
		}
		for (int l813 = 0; l813 < 2; l813 = l813 + 1) {
			fRec970[l813] = 0.0;
		}
		for (int l814 = 0; l814 < 2; l814 = l814 + 1) {
			fRec971[l814] = 0.0;
		}
		for (int l815 = 0; l815 < 2; l815 = l815 + 1) {
			fRec973[l815] = 0.0;
		}
		for (int l816 = 0; l816 < 2; l816 = l816 + 1) {
			fRec974[l816] = 0.0;
		}
		for (int l817 = 0; l817 < 2; l817 = l817 + 1) {
			fRec976[l817] = 0.0;
		}
		for (int l818 = 0; l818 < 2; l818 = l818 + 1) {
			fRec977[l818] = 0.0;
		}
		for (int l819 = 0; l819 < 2; l819 = l819 + 1) {
			fRec979[l819] = 0.0;
		}
		for (int l820 = 0; l820 < 2; l820 = l820 + 1) {
			fRec980[l820] = 0.0;
		}
		for (int l821 = 0; l821 < 2; l821 = l821 + 1) {
			fRec982[l821] = 0.0;
		}
		for (int l822 = 0; l822 < 2; l822 = l822 + 1) {
			fRec983[l822] = 0.0;
		}
		for (int l823 = 0; l823 < 2; l823 = l823 + 1) {
			fRec985[l823] = 0.0;
		}
		for (int l824 = 0; l824 < 2; l824 = l824 + 1) {
			fRec986[l824] = 0.0;
		}
		for (int l825 = 0; l825 < 2; l825 = l825 + 1) {
			fRec988[l825] = 0.0;
		}
		for (int l826 = 0; l826 < 2; l826 = l826 + 1) {
			fRec989[l826] = 0.0;
		}
		for (int l827 = 0; l827 < 2; l827 = l827 + 1) {
			fRec991[l827] = 0.0;
		}
		for (int l828 = 0; l828 < 2; l828 = l828 + 1) {
			fRec992[l828] = 0.0;
		}
		for (int l829 = 0; l829 < 2; l829 = l829 + 1) {
			fRec994[l829] = 0.0;
		}
		for (int l830 = 0; l830 < 2; l830 = l830 + 1) {
			fRec995[l830] = 0.0;
		}
		for (int l831 = 0; l831 < 2; l831 = l831 + 1) {
			fRec997[l831] = 0.0;
		}
		for (int l832 = 0; l832 < 2; l832 = l832 + 1) {
			fRec998[l832] = 0.0;
		}
		for (int l833 = 0; l833 < 2; l833 = l833 + 1) {
			fRec1000[l833] = 0.0;
		}
		for (int l834 = 0; l834 < 2; l834 = l834 + 1) {
			fRec1001[l834] = 0.0;
		}
		for (int l835 = 0; l835 < 2; l835 = l835 + 1) {
			fRec1003[l835] = 0.0;
		}
		for (int l836 = 0; l836 < 2; l836 = l836 + 1) {
			fRec1004[l836] = 0.0;
		}
		for (int l837 = 0; l837 < 2; l837 = l837 + 1) {
			fRec1006[l837] = 0.0;
		}
		for (int l838 = 0; l838 < 2; l838 = l838 + 1) {
			fRec1007[l838] = 0.0;
		}
		for (int l839 = 0; l839 < 2; l839 = l839 + 1) {
			fRec1009[l839] = 0.0;
		}
		for (int l840 = 0; l840 < 2; l840 = l840 + 1) {
			fRec1010[l840] = 0.0;
		}
		for (int l841 = 0; l841 < 2; l841 = l841 + 1) {
			fRec871[l841] = 0.0;
		}
		for (int l842 = 0; l842 < 2; l842 = l842 + 1) {
			fRec9[l842] = 0.0;
		}
		for (int l843 = 0; l843 < 2; l843 = l843 + 1) {
			fRec1018[l843] = 0.0;
		}
		for (int l844 = 0; l844 < 2; l844 = l844 + 1) {
			iVec58[l844] = 0;
		}
		for (int l845 = 0; l845 < 2; l845 = l845 + 1) {
			iRec1019[l845] = 0;
		}
		for (int l846 = 0; l846 < 2; l846 = l846 + 1) {
			fRec1017[l846] = 0.0;
		}
		for (int l847 = 0; l847 < 2; l847 = l847 + 1) {
			fRec1016[l847] = 0.0;
		}
		for (int l848 = 0; l848 < 2; l848 = l848 + 1) {
			fRec1014[l848] = 0.0;
		}
		for (int l849 = 0; l849 < 2; l849 = l849 + 1) {
			fRec1015[l849] = 0.0;
		}
		for (int l850 = 0; l850 < 2; l850 = l850 + 1) {
			fRec1025[l850] = 0.0;
		}
		for (int l851 = 0; l851 < 2; l851 = l851 + 1) {
			iVec59[l851] = 0;
		}
		for (int l852 = 0; l852 < 2; l852 = l852 + 1) {
			iRec1026[l852] = 0;
		}
		for (int l853 = 0; l853 < 2; l853 = l853 + 1) {
			fRec1024[l853] = 0.0;
		}
		for (int l854 = 0; l854 < 2; l854 = l854 + 1) {
			fRec1023[l854] = 0.0;
		}
		for (int l855 = 0; l855 < 2; l855 = l855 + 1) {
			fRec1021[l855] = 0.0;
		}
		for (int l856 = 0; l856 < 2; l856 = l856 + 1) {
			fRec1022[l856] = 0.0;
		}
		for (int l857 = 0; l857 < 2; l857 = l857 + 1) {
			fRec1020[l857] = 0.0;
		}
		for (int l858 = 0; l858 < 2; l858 = l858 + 1) {
			fRec1031[l858] = 0.0;
		}
		for (int l859 = 0; l859 < 2; l859 = l859 + 1) {
			iVec60[l859] = 0;
		}
		for (int l860 = 0; l860 < 2; l860 = l860 + 1) {
			iRec1032[l860] = 0;
		}
		for (int l861 = 0; l861 < 2; l861 = l861 + 1) {
			fRec1030[l861] = 0.0;
		}
		for (int l862 = 0; l862 < 2; l862 = l862 + 1) {
			fRec1029[l862] = 0.0;
		}
		for (int l863 = 0; l863 < 2; l863 = l863 + 1) {
			fRec1027[l863] = 0.0;
		}
		for (int l864 = 0; l864 < 2; l864 = l864 + 1) {
			fRec1028[l864] = 0.0;
		}
		for (int l865 = 0; l865 < 2; l865 = l865 + 1) {
			fVec61[l865] = 0.0;
		}
		for (int l866 = 0; l866 < 2; l866 = l866 + 1) {
			fRec1012[l866] = 0.0;
		}
		for (int l867 = 0; l867 < 2; l867 = l867 + 1) {
			fRec1040[l867] = 0.0;
		}
		for (int l868 = 0; l868 < 2; l868 = l868 + 1) {
			iVec62[l868] = 0;
		}
		for (int l869 = 0; l869 < 2; l869 = l869 + 1) {
			iRec1041[l869] = 0;
		}
		for (int l870 = 0; l870 < 2; l870 = l870 + 1) {
			fRec1039[l870] = 0.0;
		}
		for (int l871 = 0; l871 < 2; l871 = l871 + 1) {
			fRec1038[l871] = 0.0;
		}
		for (int l872 = 0; l872 < 2; l872 = l872 + 1) {
			fRec1036[l872] = 0.0;
		}
		for (int l873 = 0; l873 < 2; l873 = l873 + 1) {
			fRec1037[l873] = 0.0;
		}
		for (int l874 = 0; l874 < 2; l874 = l874 + 1) {
			fRec1046[l874] = 0.0;
		}
		for (int l875 = 0; l875 < 2; l875 = l875 + 1) {
			iVec63[l875] = 0;
		}
		for (int l876 = 0; l876 < 2; l876 = l876 + 1) {
			iRec1047[l876] = 0;
		}
		for (int l877 = 0; l877 < 2; l877 = l877 + 1) {
			fRec1045[l877] = 0.0;
		}
		for (int l878 = 0; l878 < 2; l878 = l878 + 1) {
			fRec1044[l878] = 0.0;
		}
		for (int l879 = 0; l879 < 2; l879 = l879 + 1) {
			fRec1042[l879] = 0.0;
		}
		for (int l880 = 0; l880 < 2; l880 = l880 + 1) {
			fRec1043[l880] = 0.0;
		}
		for (int l881 = 0; l881 < 2; l881 = l881 + 1) {
			fRec1048[l881] = 0.0;
		}
		for (int l882 = 0; l882 < 2; l882 = l882 + 1) {
			fRec1053[l882] = 0.0;
		}
		for (int l883 = 0; l883 < 2; l883 = l883 + 1) {
			iVec64[l883] = 0;
		}
		for (int l884 = 0; l884 < 2; l884 = l884 + 1) {
			iRec1054[l884] = 0;
		}
		for (int l885 = 0; l885 < 2; l885 = l885 + 1) {
			fRec1052[l885] = 0.0;
		}
		for (int l886 = 0; l886 < 2; l886 = l886 + 1) {
			fRec1051[l886] = 0.0;
		}
		for (int l887 = 0; l887 < 2; l887 = l887 + 1) {
			fRec1049[l887] = 0.0;
		}
		for (int l888 = 0; l888 < 2; l888 = l888 + 1) {
			fRec1050[l888] = 0.0;
		}
		for (int l889 = 0; l889 < 2; l889 = l889 + 1) {
			fRec1059[l889] = 0.0;
		}
		for (int l890 = 0; l890 < 2; l890 = l890 + 1) {
			iVec65[l890] = 0;
		}
		for (int l891 = 0; l891 < 2; l891 = l891 + 1) {
			iRec1060[l891] = 0;
		}
		for (int l892 = 0; l892 < 2; l892 = l892 + 1) {
			fRec1058[l892] = 0.0;
		}
		for (int l893 = 0; l893 < 2; l893 = l893 + 1) {
			fRec1057[l893] = 0.0;
		}
		for (int l894 = 0; l894 < 2; l894 = l894 + 1) {
			fRec1055[l894] = 0.0;
		}
		for (int l895 = 0; l895 < 2; l895 = l895 + 1) {
			fRec1056[l895] = 0.0;
		}
		for (int l896 = 0; l896 < 2; l896 = l896 + 1) {
			fRec1033[l896] = 0.0;
		}
		for (int l897 = 0; l897 < 2; l897 = l897 + 1) {
			fRec1034[l897] = 0.0;
		}
		for (int l898 = 0; l898 < 2; l898 = l898 + 1) {
			fRec1061[l898] = 0.0;
		}
		for (int l899 = 0; l899 < 2; l899 = l899 + 1) {
			fRec1062[l899] = 0.0;
		}
		for (int l900 = 0; l900 < 2; l900 = l900 + 1) {
			fRec1064[l900] = 0.0;
		}
		for (int l901 = 0; l901 < 2; l901 = l901 + 1) {
			fRec1065[l901] = 0.0;
		}
		for (int l902 = 0; l902 < 2; l902 = l902 + 1) {
			fRec1067[l902] = 0.0;
		}
		for (int l903 = 0; l903 < 2; l903 = l903 + 1) {
			fRec1068[l903] = 0.0;
		}
		for (int l904 = 0; l904 < 2; l904 = l904 + 1) {
			fRec1070[l904] = 0.0;
		}
		for (int l905 = 0; l905 < 2; l905 = l905 + 1) {
			fRec1071[l905] = 0.0;
		}
		for (int l906 = 0; l906 < 2; l906 = l906 + 1) {
			fRec1073[l906] = 0.0;
		}
		for (int l907 = 0; l907 < 2; l907 = l907 + 1) {
			fRec1074[l907] = 0.0;
		}
		for (int l908 = 0; l908 < 2; l908 = l908 + 1) {
			fRec1076[l908] = 0.0;
		}
		for (int l909 = 0; l909 < 2; l909 = l909 + 1) {
			fRec1077[l909] = 0.0;
		}
		for (int l910 = 0; l910 < 2; l910 = l910 + 1) {
			fRec1079[l910] = 0.0;
		}
		for (int l911 = 0; l911 < 2; l911 = l911 + 1) {
			fRec1080[l911] = 0.0;
		}
		for (int l912 = 0; l912 < 2; l912 = l912 + 1) {
			fRec1082[l912] = 0.0;
		}
		for (int l913 = 0; l913 < 2; l913 = l913 + 1) {
			fRec1083[l913] = 0.0;
		}
		for (int l914 = 0; l914 < 2; l914 = l914 + 1) {
			fRec1085[l914] = 0.0;
		}
		for (int l915 = 0; l915 < 2; l915 = l915 + 1) {
			fRec1086[l915] = 0.0;
		}
		for (int l916 = 0; l916 < 2; l916 = l916 + 1) {
			fRec1088[l916] = 0.0;
		}
		for (int l917 = 0; l917 < 2; l917 = l917 + 1) {
			fRec1089[l917] = 0.0;
		}
		for (int l918 = 0; l918 < 2; l918 = l918 + 1) {
			fRec1091[l918] = 0.0;
		}
		for (int l919 = 0; l919 < 2; l919 = l919 + 1) {
			fRec1092[l919] = 0.0;
		}
		for (int l920 = 0; l920 < 2; l920 = l920 + 1) {
			fRec1094[l920] = 0.0;
		}
		for (int l921 = 0; l921 < 2; l921 = l921 + 1) {
			fRec1095[l921] = 0.0;
		}
		for (int l922 = 0; l922 < 2; l922 = l922 + 1) {
			fRec1097[l922] = 0.0;
		}
		for (int l923 = 0; l923 < 2; l923 = l923 + 1) {
			fRec1098[l923] = 0.0;
		}
		for (int l924 = 0; l924 < 2; l924 = l924 + 1) {
			fRec1100[l924] = 0.0;
		}
		for (int l925 = 0; l925 < 2; l925 = l925 + 1) {
			fRec1101[l925] = 0.0;
		}
		for (int l926 = 0; l926 < 2; l926 = l926 + 1) {
			fRec1103[l926] = 0.0;
		}
		for (int l927 = 0; l927 < 2; l927 = l927 + 1) {
			fRec1104[l927] = 0.0;
		}
		for (int l928 = 0; l928 < 2; l928 = l928 + 1) {
			fRec1106[l928] = 0.0;
		}
		for (int l929 = 0; l929 < 2; l929 = l929 + 1) {
			fRec1107[l929] = 0.0;
		}
		for (int l930 = 0; l930 < 2; l930 = l930 + 1) {
			fRec1109[l930] = 0.0;
		}
		for (int l931 = 0; l931 < 2; l931 = l931 + 1) {
			fRec1110[l931] = 0.0;
		}
		for (int l932 = 0; l932 < 2; l932 = l932 + 1) {
			fRec1112[l932] = 0.0;
		}
		for (int l933 = 0; l933 < 2; l933 = l933 + 1) {
			fRec1113[l933] = 0.0;
		}
		for (int l934 = 0; l934 < 2; l934 = l934 + 1) {
			fRec1115[l934] = 0.0;
		}
		for (int l935 = 0; l935 < 2; l935 = l935 + 1) {
			fRec1116[l935] = 0.0;
		}
		for (int l936 = 0; l936 < 2; l936 = l936 + 1) {
			fRec1118[l936] = 0.0;
		}
		for (int l937 = 0; l937 < 2; l937 = l937 + 1) {
			fRec1119[l937] = 0.0;
		}
		for (int l938 = 0; l938 < 2; l938 = l938 + 1) {
			fRec1121[l938] = 0.0;
		}
		for (int l939 = 0; l939 < 2; l939 = l939 + 1) {
			fRec1122[l939] = 0.0;
		}
		for (int l940 = 0; l940 < 2; l940 = l940 + 1) {
			fRec1124[l940] = 0.0;
		}
		for (int l941 = 0; l941 < 2; l941 = l941 + 1) {
			fRec1125[l941] = 0.0;
		}
		for (int l942 = 0; l942 < 2; l942 = l942 + 1) {
			fRec1127[l942] = 0.0;
		}
		for (int l943 = 0; l943 < 2; l943 = l943 + 1) {
			fRec1128[l943] = 0.0;
		}
		for (int l944 = 0; l944 < 2; l944 = l944 + 1) {
			fRec1130[l944] = 0.0;
		}
		for (int l945 = 0; l945 < 2; l945 = l945 + 1) {
			fRec1131[l945] = 0.0;
		}
		for (int l946 = 0; l946 < 2; l946 = l946 + 1) {
			fRec1133[l946] = 0.0;
		}
		for (int l947 = 0; l947 < 2; l947 = l947 + 1) {
			fRec1134[l947] = 0.0;
		}
		for (int l948 = 0; l948 < 2; l948 = l948 + 1) {
			fRec1136[l948] = 0.0;
		}
		for (int l949 = 0; l949 < 2; l949 = l949 + 1) {
			fRec1137[l949] = 0.0;
		}
		for (int l950 = 0; l950 < 2; l950 = l950 + 1) {
			fRec1139[l950] = 0.0;
		}
		for (int l951 = 0; l951 < 2; l951 = l951 + 1) {
			fRec1140[l951] = 0.0;
		}
		for (int l952 = 0; l952 < 2; l952 = l952 + 1) {
			fRec1142[l952] = 0.0;
		}
		for (int l953 = 0; l953 < 2; l953 = l953 + 1) {
			fRec1143[l953] = 0.0;
		}
		for (int l954 = 0; l954 < 2; l954 = l954 + 1) {
			fRec1145[l954] = 0.0;
		}
		for (int l955 = 0; l955 < 2; l955 = l955 + 1) {
			fRec1146[l955] = 0.0;
		}
		for (int l956 = 0; l956 < 2; l956 = l956 + 1) {
			fRec1148[l956] = 0.0;
		}
		for (int l957 = 0; l957 < 2; l957 = l957 + 1) {
			fRec1149[l957] = 0.0;
		}
		for (int l958 = 0; l958 < 2; l958 = l958 + 1) {
			fRec1151[l958] = 0.0;
		}
		for (int l959 = 0; l959 < 2; l959 = l959 + 1) {
			fRec1152[l959] = 0.0;
		}
		for (int l960 = 0; l960 < 2; l960 = l960 + 1) {
			fRec1013[l960] = 0.0;
		}
		for (int l961 = 0; l961 < 2; l961 = l961 + 1) {
			fRec10[l961] = 0.0;
		}
		for (int l962 = 0; l962 < 32768; l962 = l962 + 1) {
			fRec2[l962] = 0.0;
		}
		for (int l963 = 0; l963 < 2; l963 = l963 + 1) {
			iRec1157[l963] = 0;
		}
		for (int l964 = 0; l964 < 2; l964 = l964 + 1) {
			fRec1158[l964] = 0.0;
		}
		for (int l965 = 0; l965 < 2; l965 = l965 + 1) {
			fRec1155[l965] = 0.0;
		}
		for (int l966 = 0; l966 < 2; l966 = l966 + 1) {
			fRec1154[l966] = 0.0;
		}
		for (int l967 = 0; l967 < 32768; l967 = l967 + 1) {
			fRec1159[l967] = 0.0;
		}
		for (int l968 = 0; l968 < 2; l968 = l968 + 1) {
			iRec1163[l968] = 0;
		}
		for (int l969 = 0; l969 < 2; l969 = l969 + 1) {
			fRec1164[l969] = 0.0;
		}
		for (int l970 = 0; l970 < 2; l970 = l970 + 1) {
			fRec1161[l970] = 0.0;
		}
		for (int l971 = 0; l971 < 2; l971 = l971 + 1) {
			fRec1160[l971] = 0.0;
		}
		for (int l972 = 0; l972 < 32768; l972 = l972 + 1) {
			fRec1165[l972] = 0.0;
		}
		for (int l973 = 0; l973 < 2; l973 = l973 + 1) {
			iRec1169[l973] = 0;
		}
		for (int l974 = 0; l974 < 2; l974 = l974 + 1) {
			fRec1170[l974] = 0.0;
		}
		for (int l975 = 0; l975 < 2; l975 = l975 + 1) {
			fRec1167[l975] = 0.0;
		}
		for (int l976 = 0; l976 < 2; l976 = l976 + 1) {
			fRec1166[l976] = 0.0;
		}
		for (int l977 = 0; l977 < 32768; l977 = l977 + 1) {
			fRec1171[l977] = 0.0;
		}
		for (int l978 = 0; l978 < 2; l978 = l978 + 1) {
			iRec1175[l978] = 0;
		}
		for (int l979 = 0; l979 < 2; l979 = l979 + 1) {
			fRec1176[l979] = 0.0;
		}
		for (int l980 = 0; l980 < 2; l980 = l980 + 1) {
			fRec1173[l980] = 0.0;
		}
		for (int l981 = 0; l981 < 2; l981 = l981 + 1) {
			fRec1172[l981] = 0.0;
		}
		for (int l982 = 0; l982 < 2; l982 = l982 + 1) {
			fRec0[l982] = 0.0;
		}
		for (int l983 = 0; l983 < 32768; l983 = l983 + 1) {
			fRec1178[l983] = 0.0;
		}
		for (int l984 = 0; l984 < 2; l984 = l984 + 1) {
			iRec1182[l984] = 0;
		}
		for (int l985 = 0; l985 < 2; l985 = l985 + 1) {
			fRec1183[l985] = 0.0;
		}
		for (int l986 = 0; l986 < 2; l986 = l986 + 1) {
			fRec1180[l986] = 0.0;
		}
		for (int l987 = 0; l987 < 2; l987 = l987 + 1) {
			fRec1179[l987] = 0.0;
		}
		for (int l988 = 0; l988 < 32768; l988 = l988 + 1) {
			fRec1184[l988] = 0.0;
		}
		for (int l989 = 0; l989 < 2; l989 = l989 + 1) {
			iRec1188[l989] = 0;
		}
		for (int l990 = 0; l990 < 2; l990 = l990 + 1) {
			fRec1189[l990] = 0.0;
		}
		for (int l991 = 0; l991 < 2; l991 = l991 + 1) {
			fRec1186[l991] = 0.0;
		}
		for (int l992 = 0; l992 < 2; l992 = l992 + 1) {
			fRec1185[l992] = 0.0;
		}
		for (int l993 = 0; l993 < 32768; l993 = l993 + 1) {
			fRec1190[l993] = 0.0;
		}
		for (int l994 = 0; l994 < 2; l994 = l994 + 1) {
			iRec1194[l994] = 0;
		}
		for (int l995 = 0; l995 < 2; l995 = l995 + 1) {
			fRec1195[l995] = 0.0;
		}
		for (int l996 = 0; l996 < 2; l996 = l996 + 1) {
			fRec1192[l996] = 0.0;
		}
		for (int l997 = 0; l997 < 2; l997 = l997 + 1) {
			fRec1191[l997] = 0.0;
		}
		for (int l998 = 0; l998 < 32768; l998 = l998 + 1) {
			fRec1196[l998] = 0.0;
		}
		for (int l999 = 0; l999 < 2; l999 = l999 + 1) {
			iRec1200[l999] = 0;
		}
		for (int l1000 = 0; l1000 < 2; l1000 = l1000 + 1) {
			fRec1201[l1000] = 0.0;
		}
		for (int l1001 = 0; l1001 < 2; l1001 = l1001 + 1) {
			fRec1198[l1001] = 0.0;
		}
		for (int l1002 = 0; l1002 < 2; l1002 = l1002 + 1) {
			fRec1197[l1002] = 0.0;
		}
		for (int l1003 = 0; l1003 < 2; l1003 = l1003 + 1) {
			fRec1177[l1003] = 0.0;
		}
		for (int l1004 = 0; l1004 < 2; l1004 = l1004 + 1) {
			fRec1202[l1004] = 0.0;
		}
		for (int l1005 = 0; l1005 < 2; l1005 = l1005 + 1) {
			fRec1203[l1005] = 0.0;
		}
		for (int l1006 = 0; l1006 < 2; l1006 = l1006 + 1) {
			fRec1204[l1006] = 0.0;
		}
		for (int l1007 = 0; l1007 < 2; l1007 = l1007 + 1) {
			fRec1205[l1007] = 0.0;
		}
		for (int l1008 = 0; l1008 < 2; l1008 = l1008 + 1) {
			fRec1206[l1008] = 0.0;
		}
		for (int l1009 = 0; l1009 < 2; l1009 = l1009 + 1) {
			fRec1207[l1009] = 0.0;
		}
	}
	
	virtual void init(int sample_rate) {
		classInit(sample_rate);
		instanceInit(sample_rate);
	}
	
	virtual void instanceInit(int sample_rate) {
		instanceConstants(sample_rate);
		instanceResetUserInterface();
		instanceClear();
	}
	
	virtual mydsp* clone() {
		return new mydsp();
	}
	
	virtual int getSampleRate() {
		return fSampleRate;
	}
	
	virtual void buildUserInterface(UI* ui_interface) {
		ui_interface->openTabBox("RITI");
		ui_interface->openVerticalBox("Controls");
		ui_interface->openHorizontalBox("Oscillators");
		ui_interface->openHorizontalBox("Output");
		ui_interface->declare(&fHslider0, "style", "knob");
		ui_interface->addHorizontalSlider("Gain", &fHslider0, FAUSTFLOAT(1.0), FAUSTFLOAT(0.0), FAUSTFLOAT(1.0), FAUSTFLOAT(0.001));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("System Bias");
		ui_interface->addCheckButton("Autonomous Control", &fCheckbox0);
		ui_interface->declare(&fHslider7, "style", "knob");
		ui_interface->addHorizontalSlider("bandwidth", &fHslider7, FAUSTFLOAT(0.0), FAUSTFLOAT(-1e+01), FAUSTFLOAT(1e+01), FAUSTFLOAT(0.001));
		ui_interface->declare(&fHslider4, "style", "knob");
		ui_interface->addHorizontalSlider("frequency", &fHslider4, FAUSTFLOAT(0.0), FAUSTFLOAT(-1e+01), FAUSTFLOAT(1e+01), FAUSTFLOAT(0.001));
		ui_interface->declare(&fHslider6, "style", "knob");
		ui_interface->addHorizontalSlider("gains", &fHslider6, FAUSTFLOAT(0.0), FAUSTFLOAT(-1e+01), FAUSTFLOAT(1e+01), FAUSTFLOAT(0.001));
		ui_interface->declare(&fHslider1, "style", "knob");
		ui_interface->addHorizontalSlider("interactions", &fHslider1, FAUSTFLOAT(0.0), FAUSTFLOAT(-1e+01), FAUSTFLOAT(1e+01), FAUSTFLOAT(0.001));
		ui_interface->declare(&fHslider5, "style", "knob");
		ui_interface->addHorizontalSlider("interpolation", &fHslider5, FAUSTFLOAT(0.0), FAUSTFLOAT(-1e+01), FAUSTFLOAT(1e+01), FAUSTFLOAT(0.001));
		ui_interface->declare(&fHslider3, "style", "knob");
		ui_interface->addHorizontalSlider("modulation", &fHslider3, FAUSTFLOAT(0.0), FAUSTFLOAT(-1e+01), FAUSTFLOAT(1e+01), FAUSTFLOAT(0.001));
		ui_interface->declare(&fHslider2, "style", "knob");
		ui_interface->addHorizontalSlider("rate", &fHslider2, FAUSTFLOAT(0.0), FAUSTFLOAT(-1e+01), FAUSTFLOAT(1e+01), FAUSTFLOAT(0.001));
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("Inspectors");
		ui_interface->openVerticalBox("Duffing 0");
		ui_interface->openHorizontalBox("Bandwidth");
		ui_interface->declare(&fVbargraph6, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph6, FAUSTFLOAT(-1e+02), FAUSTFLOAT(1e+02));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("frequency");
		ui_interface->declare(&fVbargraph3, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph3, FAUSTFLOAT(-2e+03), FAUSTFLOAT(2e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("gains");
		ui_interface->declare(&fVbargraph5, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph5, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interactions");
		ui_interface->declare(&fVbargraph0, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph0, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interpolation");
		ui_interface->declare(&fVbargraph4, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph4, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("modulation");
		ui_interface->declare(&fVbargraph2, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph2, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("rate");
		ui_interface->declare(&fVbargraph1, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph1, FAUSTFLOAT(-5e+05), FAUSTFLOAT(5e+05));
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->openVerticalBox("Duffing 1");
		ui_interface->openHorizontalBox("Bandwidth");
		ui_interface->declare(&fVbargraph13, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph13, FAUSTFLOAT(-1e+02), FAUSTFLOAT(1e+02));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("frequency");
		ui_interface->declare(&fVbargraph10, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph10, FAUSTFLOAT(-2e+03), FAUSTFLOAT(2e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("gains");
		ui_interface->declare(&fVbargraph12, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph12, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interactions");
		ui_interface->declare(&fVbargraph7, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph7, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interpolation");
		ui_interface->declare(&fVbargraph11, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph11, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("modulation");
		ui_interface->declare(&fVbargraph9, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph9, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("rate");
		ui_interface->declare(&fVbargraph8, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph8, FAUSTFLOAT(-5e+05), FAUSTFLOAT(5e+05));
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->openVerticalBox("Duffing 2");
		ui_interface->openHorizontalBox("Bandwidth");
		ui_interface->declare(&fVbargraph20, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph20, FAUSTFLOAT(-1e+02), FAUSTFLOAT(1e+02));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("frequency");
		ui_interface->declare(&fVbargraph17, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph17, FAUSTFLOAT(-2e+03), FAUSTFLOAT(2e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("gains");
		ui_interface->declare(&fVbargraph19, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph19, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interactions");
		ui_interface->declare(&fVbargraph14, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph14, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interpolation");
		ui_interface->declare(&fVbargraph18, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph18, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("modulation");
		ui_interface->declare(&fVbargraph16, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph16, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("rate");
		ui_interface->declare(&fVbargraph15, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph15, FAUSTFLOAT(-5e+05), FAUSTFLOAT(5e+05));
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->openVerticalBox("Duffing 3");
		ui_interface->openHorizontalBox("Bandwidth");
		ui_interface->declare(&fVbargraph27, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph27, FAUSTFLOAT(-1e+02), FAUSTFLOAT(1e+02));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("frequency");
		ui_interface->declare(&fVbargraph24, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph24, FAUSTFLOAT(-2e+03), FAUSTFLOAT(2e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("gains");
		ui_interface->declare(&fVbargraph26, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph26, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interactions");
		ui_interface->declare(&fVbargraph21, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph21, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interpolation");
		ui_interface->declare(&fVbargraph25, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph25, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("modulation");
		ui_interface->declare(&fVbargraph23, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph23, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("rate");
		ui_interface->declare(&fVbargraph22, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph22, FAUSTFLOAT(-5e+05), FAUSTFLOAT(5e+05));
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->openVerticalBox("Duffing 4");
		ui_interface->openHorizontalBox("Bandwidth");
		ui_interface->declare(&fVbargraph34, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph34, FAUSTFLOAT(-1e+02), FAUSTFLOAT(1e+02));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("frequency");
		ui_interface->declare(&fVbargraph31, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph31, FAUSTFLOAT(-2e+03), FAUSTFLOAT(2e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("gains");
		ui_interface->declare(&fVbargraph33, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph33, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interactions");
		ui_interface->declare(&fVbargraph28, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph28, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interpolation");
		ui_interface->declare(&fVbargraph32, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph32, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("modulation");
		ui_interface->declare(&fVbargraph30, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph30, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("rate");
		ui_interface->declare(&fVbargraph29, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph29, FAUSTFLOAT(-5e+05), FAUSTFLOAT(5e+05));
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->openVerticalBox("Duffing 5");
		ui_interface->openHorizontalBox("Bandwidth");
		ui_interface->declare(&fVbargraph41, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph41, FAUSTFLOAT(-1e+02), FAUSTFLOAT(1e+02));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("frequency");
		ui_interface->declare(&fVbargraph38, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph38, FAUSTFLOAT(-2e+03), FAUSTFLOAT(2e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("gains");
		ui_interface->declare(&fVbargraph40, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph40, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interactions");
		ui_interface->declare(&fVbargraph35, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph35, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interpolation");
		ui_interface->declare(&fVbargraph39, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph39, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("modulation");
		ui_interface->declare(&fVbargraph37, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph37, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("rate");
		ui_interface->declare(&fVbargraph36, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph36, FAUSTFLOAT(-5e+05), FAUSTFLOAT(5e+05));
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->openVerticalBox("Duffing 6");
		ui_interface->openHorizontalBox("Bandwidth");
		ui_interface->declare(&fVbargraph48, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph48, FAUSTFLOAT(-1e+02), FAUSTFLOAT(1e+02));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("frequency");
		ui_interface->declare(&fVbargraph45, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph45, FAUSTFLOAT(-2e+03), FAUSTFLOAT(2e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("gains");
		ui_interface->declare(&fVbargraph47, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph47, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interactions");
		ui_interface->declare(&fVbargraph42, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph42, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interpolation");
		ui_interface->declare(&fVbargraph46, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph46, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("modulation");
		ui_interface->declare(&fVbargraph44, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph44, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("rate");
		ui_interface->declare(&fVbargraph43, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph43, FAUSTFLOAT(-5e+05), FAUSTFLOAT(5e+05));
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->openVerticalBox("Duffing 7");
		ui_interface->openHorizontalBox("Bandwidth");
		ui_interface->declare(&fVbargraph55, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph55, FAUSTFLOAT(-1e+02), FAUSTFLOAT(1e+02));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("frequency");
		ui_interface->declare(&fVbargraph52, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph52, FAUSTFLOAT(-2e+03), FAUSTFLOAT(2e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("gains");
		ui_interface->declare(&fVbargraph54, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph54, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interactions");
		ui_interface->declare(&fVbargraph49, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph49, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("interpolation");
		ui_interface->declare(&fVbargraph53, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph53, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("modulation");
		ui_interface->declare(&fVbargraph51, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph51, FAUSTFLOAT(-1e+03), FAUSTFLOAT(1e+03));
		ui_interface->closeBox();
		ui_interface->openHorizontalBox("rate");
		ui_interface->declare(&fVbargraph50, "style", "numerical");
		ui_interface->addVerticalBargraph("1", &fVbargraph50, FAUSTFLOAT(-5e+05), FAUSTFLOAT(5e+05));
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->closeBox();
		ui_interface->openVerticalBox("Outputs");
		ui_interface->openHorizontalBox("Output Channels");
		ui_interface->declare(&fVbargraph56, "2", "");
		ui_interface->declare(&fVbargraph56, "unit", "dB");
		ui_interface->addVerticalBargraph("chan 0", &fVbargraph56, FAUSTFLOAT(-7e+01), FAUSTFLOAT(5.0));
		ui_interface->declare(&fVbargraph57, "2", "");
		ui_interface->declare(&fVbargraph57, "unit", "dB");
		ui_interface->addVerticalBargraph("chan 1", &fVbargraph57, FAUSTFLOAT(-7e+01), FAUSTFLOAT(5.0));
		ui_interface->declare(&fVbargraph58, "2", "");
		ui_interface->declare(&fVbargraph58, "unit", "dB");
		ui_interface->addVerticalBargraph("chan 2", &fVbargraph58, FAUSTFLOAT(-7e+01), FAUSTFLOAT(5.0));
		ui_interface->declare(&fVbargraph59, "2", "");
		ui_interface->declare(&fVbargraph59, "unit", "dB");
		ui_interface->addVerticalBargraph("chan 3", &fVbargraph59, FAUSTFLOAT(-7e+01), FAUSTFLOAT(5.0));
		ui_interface->declare(&fVbargraph60, "2", "");
		ui_interface->declare(&fVbargraph60, "unit", "dB");
		ui_interface->addVerticalBargraph("chan 4", &fVbargraph60, FAUSTFLOAT(-7e+01), FAUSTFLOAT(5.0));
		ui_interface->declare(&fVbargraph61, "2", "");
		ui_interface->declare(&fVbargraph61, "unit", "dB");
		ui_interface->addVerticalBargraph("chan 5", &fVbargraph61, FAUSTFLOAT(-7e+01), FAUSTFLOAT(5.0));
		ui_interface->declare(&fVbargraph62, "2", "");
		ui_interface->declare(&fVbargraph62, "unit", "dB");
		ui_interface->addVerticalBargraph("chan 6", &fVbargraph62, FAUSTFLOAT(-7e+01), FAUSTFLOAT(5.0));
		ui_interface->declare(&fVbargraph63, "2", "");
		ui_interface->declare(&fVbargraph63, "unit", "dB");
		ui_interface->addVerticalBargraph("chan 7", &fVbargraph63, FAUSTFLOAT(-7e+01), FAUSTFLOAT(5.0));
		ui_interface->closeBox();
		ui_interface->declare(&fVslider0, "style", "radio{'Stereophonic':0;'Quadraphonic':1;'Octophonic':2}");
		ui_interface->addVerticalSlider("Output Channels", &fVslider0, FAUSTFLOAT(2.0), FAUSTFLOAT(0.0), FAUSTFLOAT(2.0), FAUSTFLOAT(1.0));
		ui_interface->closeBox();
		ui_interface->closeBox();
	}
	
	virtual void compute(int count, FAUSTFLOAT** RESTRICT inputs, FAUSTFLOAT** RESTRICT outputs) {
		FAUSTFLOAT* output0 = outputs[0];
		FAUSTFLOAT* output1 = outputs[1];
		FAUSTFLOAT* output2 = outputs[2];
		FAUSTFLOAT* output3 = outputs[3];
		FAUSTFLOAT* output4 = outputs[4];
		FAUSTFLOAT* output5 = outputs[5];
		FAUSTFLOAT* output6 = outputs[6];
		FAUSTFLOAT* output7 = outputs[7];
		double fSlow0 = fConst2 * double(fHslider0);
		double fSlow1 = double(fVslider0);
		double fSlow2 = 0.25 * double(fSlow1 == 0.0);
		double fSlow3 = fConst2 * double(fHslider1);
		double fSlow4 = double(fCheckbox0);
		double fSlow5 = fConst2 * double(fHslider2);
		double fSlow6 = fConst2 * double(fHslider3);
		double fSlow7 = fConst2 * double(fHslider4);
		double fSlow8 = fConst2 * double(fHslider5);
		double fSlow9 = fConst2 * double(fHslider6);
		double fSlow10 = fConst2 * double(fHslider7);
		double fSlow11 = 0.5 * double(fSlow1 == 1.0);
		double fSlow12 = double(fSlow1 == 2.0);
		for (int i0 = 0; i0 < count; i0 = i0 + 1) {
			iVec0[0] = 1;
			fRec1[0] = fSlow0 + fConst3 * fRec1[1];
			fRec13[0] = fSlow3 + fConst3 * fRec13[1];
			fRec18[0] = std::fmod(fRec18[1], fConst0) + std::fabs(0.1 * fRec17[1]) + 0.1;
			int iTemp0 = (fConst1 * fRec18[0]) < (fConst1 * fRec18[1]);
			iVec1[0] = 13;
			iVec2[0] = 59;
			iRec19[0] = (13 - iVec1[1]) % -2147483648 + (12345 - 59 * iRec19[1]);
			int iTemp1 = 1 - iVec0[1];
			fRec17[0] = fRec17[1] * double(iVec0[1] - iTemp0) + (0.0 - 4.656612873077393e-10 * double(iRec19[0])) * double(iTemp0 + iTemp1);
			int iTemp2 = fRec17[0] == fRec17[1];
			fVec3[IOTA0 & 2047] = fRec3[1] + fRec5[1] + fRec7[1] + fRec9[1] + fRec4[1] + fRec6[1] + fRec8[1] + fRec10[1];
			double fTemp3 = fVec3[(IOTA0 - 2000) & 2047];
			fRec16[0] = fRec16[1] * double(iTemp2) + 0.125 * fTemp3 * double(1 - iTemp2);
			double fTemp4 = ((fRec16[0] != fRec16[1]) ? fConst4 : fRec14[1] + -1.0);
			fRec14[0] = fTemp4;
			fRec15[0] = ((fTemp4 > 0.0) ? fRec15[1] + (fRec16[0] - fRec15[1]) / fTemp4 : fRec16[0]);
			double fTemp5 = tanh(fRec13[0] + fSlow4 * std::sin(6.283185307179586 * fRec15[0])) + 1.0;
			fVbargraph0 = FAUSTFLOAT(5e+02 * fTemp5);
			double fTemp6 = 0.125 * fTemp3 + -1.0;
			fRec21[0] = fSlow5 + fConst3 * fRec21[1];
			fRec26[0] = std::fmod(fRec26[1], fConst0) + std::fabs(0.1 * fRec25[1]) + 0.1;
			int iTemp7 = (fConst1 * fRec26[0]) < (fConst1 * fRec26[1]);
			iVec4[0] = 2;
			iRec27[0] = (2 - iVec4[1]) % -2147483648 + (12345 - 59 * iRec27[1]);
			fRec25[0] = fRec25[1] * double(iVec0[1] - iTemp7) + (0.0 - 4.656612873077393e-10 * double(iRec27[0])) * double(iTemp7 + iTemp1);
			int iTemp8 = fRec25[0] == fRec25[1];
			fRec24[0] = fRec24[1] * double(iTemp8) + 0.125 * fTemp3 * double(1 - iTemp8);
			double fTemp9 = ((fRec24[0] != fRec24[1]) ? fConst4 : fRec22[1] + -1.0);
			fRec22[0] = fTemp9;
			fRec23[0] = ((fTemp9 > 0.0) ? fRec23[1] + (fRec24[0] - fRec23[1]) / fTemp9 : fRec24[0]);
			double fTemp10 = std::pow(5e+02, tanh(fRec21[0] + fSlow4 * std::sin(6.283185307179586 * fRec23[0])));
			fVbargraph1 = FAUSTFLOAT(1e+03 * fTemp10);
			fRec20[0] = fRec20[1] + fConst1 * fTemp10;
			fRec28[0] = fSlow6 + fConst3 * fRec28[1];
			fRec33[0] = std::fmod(fRec33[1], fConst0) + std::fabs(0.1 * fRec32[1]) + 0.1;
			int iTemp11 = (fConst1 * fRec33[0]) < (fConst1 * fRec33[1]);
			iVec5[0] = 11;
			iRec34[0] = (11 - iVec5[1]) % -2147483648 + (12345 - 59 * iRec34[1]);
			fRec32[0] = fRec32[1] * double(iVec0[1] - iTemp11) + (0.0 - 4.656612873077393e-10 * double(iRec34[0])) * double(iTemp11 + iTemp1);
			int iTemp12 = fRec32[0] == fRec32[1];
			fRec31[0] = fRec31[1] * double(iTemp12) + 0.125 * fTemp3 * double(1 - iTemp12);
			double fTemp13 = ((fRec31[0] != fRec31[1]) ? fConst4 : fRec29[1] + -1.0);
			fRec29[0] = fTemp13;
			fRec30[0] = ((fTemp13 > 0.0) ? fRec30[1] + (fRec31[0] - fRec30[1]) / fTemp13 : fRec31[0]);
			double fTemp14 = tanh(fRec28[0] + fSlow4 * std::sin(6.283185307179586 * fRec30[0])) + 1.0;
			fVbargraph2 = FAUSTFLOAT(5e+02 * fTemp14);
			double fTemp15 = (0.5 * fTemp5 * fTemp6 + 1.0) * fRec11[1] + mydsp_faustpower3_f(fRec12[1]) + std::cos(fRec20[0]) * 0.5 * fTemp14;
			double fTemp16 = 0.0 - fTemp15;
			fVec6[0] = fTemp16;
			fRec11[0] = fTemp16;
			fRec38[0] = fSlow7 + fConst3 * fRec38[1];
			fRec43[0] = std::fmod(fRec43[1], fConst0) + std::fabs(0.1 * fRec42[1]) + 0.1;
			int iTemp17 = (fConst1 * fRec43[0]) < (fConst1 * fRec43[1]);
			iVec7[0] = 3;
			iRec44[0] = (3 - iVec7[1]) % -2147483648 + (12345 - 59 * iRec44[1]);
			fRec42[0] = fRec42[1] * double(iVec0[1] - iTemp17) + (0.0 - 4.656612873077393e-10 * double(iRec44[0])) * double(iTemp17 + iTemp1);
			int iTemp18 = fRec42[0] == fRec42[1];
			fRec41[0] = fRec41[1] * double(iTemp18) + 0.125 * fTemp3 * double(1 - iTemp18);
			double fTemp19 = ((fRec41[0] != fRec41[1]) ? fConst4 : fRec39[1] + -1.0);
			fRec39[0] = fTemp19;
			fRec40[0] = ((fTemp19 > 0.0) ? fRec40[1] + (fRec41[0] - fRec40[1]) / fTemp19 : fRec41[0]);
			double fTemp20 = 0.45 * (tanh(fRec38[0] + fSlow4 * std::sin(6.283185307179586 * fRec40[0])) + 1.0) + 0.1;
			fVbargraph3 = FAUSTFLOAT(1e+03 * fTemp20);
			double fTemp21 = fTemp20;
			fRec45[0] = fSlow8 + fConst3 * fRec45[1];
			fRec50[0] = std::fmod(fRec50[1], fConst0) + std::fabs(0.1 * fRec49[1]) + 0.1;
			int iTemp22 = (fConst1 * fRec50[0]) < (fConst1 * fRec50[1]);
			iVec8[0] = 5;
			iRec51[0] = (5 - iVec8[1]) % -2147483648 + (12345 - 59 * iRec51[1]);
			fRec49[0] = fRec49[1] * double(iVec0[1] - iTemp22) + (0.0 - 4.656612873077393e-10 * double(iRec51[0])) * double(iTemp22 + iTemp1);
			int iTemp23 = fRec49[0] == fRec49[1];
			fRec48[0] = fRec48[1] * double(iTemp23) + 0.125 * fTemp3 * double(1 - iTemp23);
			double fTemp24 = ((fRec48[0] != fRec48[1]) ? fConst4 : fRec46[1] + -1.0);
			fRec46[0] = fTemp24;
			fRec47[0] = ((fTemp24 > 0.0) ? fRec47[1] + (fRec48[0] - fRec47[1]) / fTemp24 : fRec48[0]);
			double fTemp25 = tanh(fRec45[0] + fSlow4 * std::sin(6.283185307179586 * fRec47[0])) + 1.0;
			fVbargraph4 = FAUSTFLOAT(5e+02 * fTemp25);
			double fTemp26 = 4.0 * 0.5 * fTemp25;
			int iTemp27 = int(fTemp26);
			double fTemp28 = double(iTemp27);
			double fTemp29 = fTemp28 + (1.0 - fTemp26);
			int iTemp30 = iTemp27 >= 2;
			double fTemp31 = double(1 - iTemp30);
			int iTemp32 = iTemp27 >= 1;
			double fTemp33 = double(1 - iTemp32);
			double fTemp34 = double(iTemp32);
			double fTemp35 = double(iTemp30);
			int iTemp36 = iTemp27 >= 3;
			double fTemp37 = double(1 - iTemp36);
			double fTemp38 = double(iTemp36);
			double fTemp39 = fTemp26 - fTemp28;
			int iTemp40 = iTemp27 + 1;
			int iTemp41 = iTemp40 >= 2;
			double fTemp42 = double(1 - iTemp41);
			int iTemp43 = iTemp40 >= 1;
			double fTemp44 = double(1 - iTemp43);
			double fTemp45 = double(iTemp43);
			double fTemp46 = double(iTemp41);
			int iTemp47 = iTemp40 >= 3;
			double fTemp48 = double(1 - iTemp47);
			double fTemp49 = double(iTemp47);
			double fTemp50 = fTemp21 * (fTemp29 * (fTemp31 * (1306.0 * fTemp33 + 1.86e+03 * fTemp34) + fTemp35 * (1764.0 * fTemp37 + 3298.0 * fTemp38)) + fTemp39 * (fTemp42 * (1306.0 * fTemp44 + 1.86e+03 * fTemp45) + fTemp46 * (1764.0 * fTemp48 + 3298.0 * fTemp49)));
			double fTemp51 = std::tan(fConst5 * fTemp50);
			fRec52[0] = 0.995 * fRec52[1] - (fTemp15 + fVec6[1]);
			fRec53[0] = fSlow9 + fConst3 * fRec53[1];
			fRec58[0] = std::fmod(fRec58[1], fConst0) + std::fabs(0.1 * fRec57[1]) + 0.1;
			int iTemp52 = (fConst1 * fRec58[0]) < (fConst1 * fRec58[1]);
			iVec9[0] = 17;
			iRec59[0] = (17 - iVec9[1]) % -2147483648 + (12345 - 59 * iRec59[1]);
			fRec57[0] = fRec57[1] * double(iVec0[1] - iTemp52) + (0.0 - 4.656612873077393e-10 * double(iRec59[0])) * double(iTemp52 + iTemp1);
			int iTemp53 = fRec57[0] == fRec57[1];
			fRec56[0] = fRec56[1] * double(iTemp53) + 0.125 * fTemp3 * double(1 - iTemp53);
			double fTemp54 = ((fRec56[0] != fRec56[1]) ? fConst4 : fRec54[1] + -1.0);
			fRec54[0] = fTemp54;
			fRec55[0] = ((fTemp54 > 0.0) ? fRec55[1] + (fRec56[0] - fRec55[1]) / fTemp54 : fRec56[0]);
			double fTemp55 = std::pow(1e+03, tanh(fRec53[0] + fSlow4 * std::sin(6.283185307179586 * fRec55[0])));
			fVbargraph5 = FAUSTFLOAT(fTemp55);
			double fTemp56 = fRec52[0] * fTemp55;
			double fTemp57 = fTemp51 * (fTemp56 - fRec36[1]) + fRec35[1];
			fRec60[0] = fSlow10 + fConst3 * fRec60[1];
			fRec65[0] = std::fmod(fRec65[1], fConst0) + std::fabs(0.1 * fRec64[1]) + 0.1;
			int iTemp58 = (fConst1 * fRec65[0]) < (fConst1 * fRec65[1]);
			iVec10[0] = 7;
			iRec66[0] = (7 - iVec10[1]) % -2147483648 + (12345 - 59 * iRec66[1]);
			fRec64[0] = fRec64[1] * double(iVec0[1] - iTemp58) + (0.0 - 4.656612873077393e-10 * double(iRec66[0])) * double(iTemp58 + iTemp1);
			int iTemp59 = fRec64[0] == fRec64[1];
			fRec63[0] = fRec63[1] * double(iTemp59) + 0.125 * fTemp3 * double(1 - iTemp59);
			double fTemp60 = ((fRec63[0] != fRec63[1]) ? fConst4 : fRec61[1] + -1.0);
			fRec61[0] = fTemp60;
			fRec62[0] = ((fTemp60 > 0.0) ? fRec62[1] + (fRec63[0] - fRec62[1]) / fTemp60 : fRec63[0]);
			double fTemp61 = std::pow(1e+02, tanh(fRec60[0] + fSlow4 * std::sin(6.283185307179586 * fRec62[0])));
			fVbargraph6 = FAUSTFLOAT(fTemp61);
			double fTemp62 = std::max<double>(2.220446049250313e-16, fTemp61);
			double fTemp63 = fTemp51 * (fTemp51 + fTemp62 / fTemp50) + 1.0;
			double fTemp64 = fTemp57 / fTemp63;
			fRec35[0] = 2.0 * fTemp64 - fRec35[1];
			fRec36[0] = fRec36[1] + 2.0 * (fTemp51 * fTemp57 / fTemp63);
			double fRec37 = fTemp64;
			double fTemp65 = fTemp21 * (fTemp29 * (fTemp31 * (1241.0 * fTemp33 + 1762.0 * fTemp34) + fTemp35 * (1617.0 * fTemp37 + 3078.0 * fTemp38)) + fTemp39 * (fTemp42 * (1241.0 * fTemp44 + 1762.0 * fTemp45) + fTemp46 * (1617.0 * fTemp48 + 3078.0 * fTemp49)));
			double fTemp66 = std::tan(fConst5 * fTemp65);
			double fTemp67 = fTemp66 * (fTemp56 - fRec68[1]) + fRec67[1];
			double fTemp68 = fTemp66 * (fTemp66 + fTemp62 / fTemp65) + 1.0;
			double fTemp69 = fTemp67 / fTemp68;
			fRec67[0] = 2.0 * fTemp69 - fRec67[1];
			fRec68[0] = fRec68[1] + 2.0 * (fTemp66 * fTemp67 / fTemp68);
			double fRec69 = fTemp69;
			double fTemp70 = fTemp21 * (fTemp29 * (fTemp31 * (1175.0 * fTemp33 + 1664.0 * fTemp34) + fTemp35 * (1.47e+03 * fTemp37 + 2858.0 * fTemp38)) + fTemp39 * (fTemp42 * (1175.0 * fTemp44 + 1664.0 * fTemp45) + fTemp46 * (1.47e+03 * fTemp48 + 2858.0 * fTemp49)));
			double fTemp71 = std::tan(fConst5 * fTemp70);
			double fTemp72 = fTemp71 * (fTemp56 - fRec71[1]) + fRec70[1];
			double fTemp73 = fTemp71 * (fTemp71 + fTemp62 / fTemp70) + 1.0;
			double fTemp74 = fTemp72 / fTemp73;
			fRec70[0] = 2.0 * fTemp74 - fRec70[1];
			fRec71[0] = fRec71[1] + 2.0 * (fTemp71 * fTemp72 / fTemp73);
			double fRec72 = fTemp74;
			double fTemp75 = fTemp21 * (fTemp29 * (fTemp31 * (1.11e+03 * fTemp33 + 1566.0 * fTemp34) + fTemp35 * (1323.0 * fTemp37 + 2638.0 * fTemp38)) + fTemp39 * (fTemp42 * (1.11e+03 * fTemp44 + 1566.0 * fTemp45) + fTemp46 * (1323.0 * fTemp48 + 2638.0 * fTemp49)));
			double fTemp76 = std::tan(fConst5 * fTemp75);
			double fTemp77 = fTemp76 * (fTemp56 - fRec74[1]) + fRec73[1];
			double fTemp78 = fTemp76 * (fTemp76 + fTemp62 / fTemp75) + 1.0;
			double fTemp79 = fTemp77 / fTemp78;
			fRec73[0] = 2.0 * fTemp79 - fRec73[1];
			fRec74[0] = fRec74[1] + 2.0 * (fTemp76 * fTemp77 / fTemp78);
			double fRec75 = fTemp79;
			double fTemp80 = fTemp21 * (fTemp29 * (fTemp31 * (1045.0 * fTemp33 + 1468.0 * fTemp34) + fTemp35 * (1269.0 * fTemp37 + 2418.0 * fTemp38)) + fTemp39 * (fTemp42 * (1045.0 * fTemp44 + 1468.0 * fTemp45) + fTemp46 * (1269.0 * fTemp48 + 2418.0 * fTemp49)));
			double fTemp81 = std::tan(fConst5 * fTemp80);
			double fTemp82 = fTemp81 * (fTemp56 - fRec77[1]) + fRec76[1];
			double fTemp83 = fTemp81 * (fTemp81 + fTemp62 / fTemp80) + 1.0;
			double fTemp84 = fTemp82 / fTemp83;
			fRec76[0] = 2.0 * fTemp84 - fRec76[1];
			fRec77[0] = fRec77[1] + 2.0 * (fTemp81 * fTemp82 / fTemp83);
			double fRec78 = fTemp84;
			double fTemp85 = fTemp21 * (fTemp29 * (fTemp31 * (979.0 * fTemp33 + 1371.0 * fTemp34) + fTemp35 * (1175.0 * fTemp37 + 2198.0 * fTemp38)) + fTemp39 * (fTemp42 * (979.0 * fTemp44 + 1371.0 * fTemp45) + fTemp46 * (1175.0 * fTemp48 + 2198.0 * fTemp49)));
			double fTemp86 = std::tan(fConst5 * fTemp85);
			double fTemp87 = fTemp86 * (fTemp56 - fRec80[1]) + fRec79[1];
			double fTemp88 = fTemp86 * (fTemp86 + fTemp62 / fTemp85) + 1.0;
			double fTemp89 = fTemp87 / fTemp88;
			fRec79[0] = 2.0 * fTemp89 - fRec79[1];
			fRec80[0] = fRec80[1] + 2.0 * (fTemp86 * fTemp87 / fTemp88);
			double fRec81 = fTemp89;
			double fTemp90 = fTemp21 * (fTemp29 * (fTemp31 * (914.0 * fTemp33 + 1272.0 * fTemp34) + fTemp35 * (1078.0 * fTemp37 + 1978.0 * fTemp38)) + fTemp39 * (fTemp42 * (914.0 * fTemp44 + 1272.0 * fTemp45) + fTemp46 * (1078.0 * fTemp48 + 1978.0 * fTemp49)));
			double fTemp91 = std::tan(fConst5 * fTemp90);
			double fTemp92 = fTemp91 * (fTemp56 - fRec83[1]) + fRec82[1];
			double fTemp93 = fTemp91 * (fTemp91 + fTemp62 / fTemp90) + 1.0;
			double fTemp94 = fTemp92 / fTemp93;
			fRec82[0] = 2.0 * fTemp94 - fRec82[1];
			fRec83[0] = fRec83[1] + 2.0 * (fTemp91 * fTemp92 / fTemp93);
			double fRec84 = fTemp94;
			double fTemp95 = fTemp21 * (fTemp29 * (fTemp31 * (849.0 * fTemp33 + 1174.0 * fTemp34) + fTemp35 * (1028.0 * fTemp37 + 1759.0 * fTemp38)) + fTemp39 * (fTemp42 * (849.0 * fTemp44 + 1174.0 * fTemp45) + fTemp46 * (1028.0 * fTemp48 + 1759.0 * fTemp49)));
			double fTemp96 = std::tan(fConst5 * fTemp95);
			double fTemp97 = fTemp96 * (fTemp56 - fRec86[1]) + fRec85[1];
			double fTemp98 = fTemp96 * (fTemp96 + fTemp62 / fTemp95) + 1.0;
			double fTemp99 = fTemp97 / fTemp98;
			fRec85[0] = 2.0 * fTemp99 - fRec85[1];
			fRec86[0] = fRec86[1] + 2.0 * (fTemp96 * fTemp97 / fTemp98);
			double fRec87 = fTemp99;
			double fTemp100 = fTemp21 * (fTemp29 * (fTemp31 * (784.0 * fTemp33 + 1076.0 * fTemp34) + fTemp35 * (961.0 * fTemp37 + 1539.0 * fTemp38)) + fTemp39 * (fTemp42 * (784.0 * fTemp44 + 1076.0 * fTemp45) + fTemp46 * (961.0 * fTemp48 + 1539.0 * fTemp49)));
			double fTemp101 = std::tan(fConst5 * fTemp100);
			double fTemp102 = fTemp101 * (fTemp56 - fRec89[1]) + fRec88[1];
			double fTemp103 = fTemp101 * (fTemp101 + fTemp62 / fTemp100) + 1.0;
			double fTemp104 = fTemp102 / fTemp103;
			fRec88[0] = 2.0 * fTemp104 - fRec88[1];
			fRec89[0] = fRec89[1] + 2.0 * (fTemp101 * fTemp102 / fTemp103);
			double fRec90 = fTemp104;
			double fTemp105 = fTemp21 * (fTemp29 * (fTemp31 * (1894.0 * fTemp33 + 2839.0 * fTemp34) + fTemp35 * (2645.0 * fTemp37 + 5717.0 * fTemp38)) + fTemp39 * (fTemp42 * (1894.0 * fTemp44 + 2839.0 * fTemp45) + fTemp46 * (2645.0 * fTemp48 + 5717.0 * fTemp49)));
			double fTemp106 = std::tan(fConst5 * fTemp105);
			double fTemp107 = fTemp106 * (fTemp56 - fRec92[1]) + fRec91[1];
			double fTemp108 = fTemp106 * (fTemp106 + fTemp62 / fTemp105) + 1.0;
			double fTemp109 = fTemp107 / fTemp108;
			fRec91[0] = 2.0 * fTemp109 - fRec91[1];
			fRec92[0] = fRec92[1] + 2.0 * (fTemp106 * fTemp107 / fTemp108);
			double fRec93 = fTemp109;
			double fTemp110 = fTemp21 * (fTemp29 * (fTemp31 * (1828.0 * fTemp33 + 2741.0 * fTemp34) + fTemp35 * (2498.0 * fTemp37 + 5496.0 * fTemp38)) + fTemp39 * (fTemp42 * (1828.0 * fTemp44 + 2741.0 * fTemp45) + fTemp46 * (2498.0 * fTemp48 + 5496.0 * fTemp49)));
			double fTemp111 = std::tan(fConst5 * fTemp110);
			double fTemp112 = fTemp111 * (fTemp56 - fRec95[1]) + fRec94[1];
			double fTemp113 = fTemp111 * (fTemp111 + fTemp62 / fTemp110) + 1.0;
			double fTemp114 = fTemp112 / fTemp113;
			fRec94[0] = 2.0 * fTemp114 - fRec94[1];
			fRec95[0] = fRec95[1] + 2.0 * (fTemp111 * fTemp112 / fTemp113);
			double fRec96 = fTemp114;
			double fTemp115 = fTemp21 * (fTemp29 * (fTemp31 * (1763.0 * fTemp33 + 2643.0 * fTemp34) + fTemp35 * (2351.0 * fTemp37 + 5056.0 * fTemp38)) + fTemp39 * (fTemp42 * (1763.0 * fTemp44 + 2643.0 * fTemp45) + fTemp46 * (2351.0 * fTemp48 + 5056.0 * fTemp49)));
			double fTemp116 = std::tan(fConst5 * fTemp115);
			double fTemp117 = fTemp116 * (fTemp56 - fRec98[1]) + fRec97[1];
			double fTemp118 = fTemp116 * (fTemp116 + fTemp62 / fTemp115) + 1.0;
			double fTemp119 = fTemp117 / fTemp118;
			fRec97[0] = 2.0 * fTemp119 - fRec97[1];
			fRec98[0] = fRec98[1] + 2.0 * (fTemp116 * fTemp117 / fTemp118);
			double fRec99 = fTemp119;
			double fTemp120 = fTemp21 * (fTemp29 * (fTemp31 * (1698.0 * fTemp33 + 2349.0 * fTemp34) + fTemp35 * (2273.0 * fTemp37 + 4617.0 * fTemp38)) + fTemp39 * (fTemp42 * (1698.0 * fTemp44 + 2349.0 * fTemp45) + fTemp46 * (2273.0 * fTemp48 + 4617.0 * fTemp49)));
			double fTemp121 = std::tan(fConst5 * fTemp120);
			double fTemp122 = fTemp121 * (fTemp56 - fRec101[1]) + fRec100[1];
			double fTemp123 = fTemp121 * (fTemp121 + fTemp62 / fTemp120) + 1.0;
			double fTemp124 = fTemp122 / fTemp123;
			fRec100[0] = 2.0 * fTemp124 - fRec100[1];
			fRec101[0] = fRec101[1] + 2.0 * (fTemp121 * fTemp122 / fTemp123);
			double fRec102 = fTemp124;
			double fTemp125 = fTemp21 * (fTemp29 * (fTemp31 * (1632.0 * fTemp33 + 2252.0 * fTemp34) + fTemp35 * (2204.0 * fTemp37 + 4177.0 * fTemp38)) + fTemp39 * (fTemp42 * (1632.0 * fTemp44 + 2252.0 * fTemp45) + fTemp46 * (2204.0 * fTemp48 + 4177.0 * fTemp49)));
			double fTemp126 = std::tan(fConst5 * fTemp125);
			double fTemp127 = fTemp126 * (fTemp56 - fRec104[1]) + fRec103[1];
			double fTemp128 = fTemp126 * (fTemp126 + fTemp62 / fTemp125) + 1.0;
			double fTemp129 = fTemp127 / fTemp128;
			fRec103[0] = 2.0 * fTemp129 - fRec103[1];
			fRec104[0] = fRec104[1] + 2.0 * (fTemp126 * fTemp127 / fTemp128);
			double fRec105 = fTemp129;
			double fTemp130 = fTemp21 * (fTemp29 * (fTemp31 * (1567.0 * fTemp33 + 2153.0 * fTemp34) + fTemp35 * (2054.0 * fTemp37 + 3957.0 * fTemp38)) + fTemp39 * (fTemp42 * (1567.0 * fTemp44 + 2153.0 * fTemp45) + fTemp46 * (2054.0 * fTemp48 + 3957.0 * fTemp49)));
			double fTemp131 = std::tan(fConst5 * fTemp130);
			double fTemp132 = fTemp131 * (fTemp56 - fRec107[1]) + fRec106[1];
			double fTemp133 = fTemp131 * (fTemp131 + fTemp62 / fTemp130) + 1.0;
			double fTemp134 = fTemp132 / fTemp133;
			fRec106[0] = 2.0 * fTemp134 - fRec106[1];
			fRec107[0] = fRec107[1] + 2.0 * (fTemp131 * fTemp132 / fTemp133);
			double fRec108 = fTemp134;
			double fTemp135 = fTemp21 * (fTemp29 * (fTemp31 * (1502.0 * fTemp33 + 2056.0 * fTemp34) + fTemp35 * (1.91e+03 * fTemp37 + 3737.0 * fTemp38)) + fTemp39 * (fTemp42 * (1502.0 * fTemp44 + 2056.0 * fTemp45) + fTemp46 * (1.91e+03 * fTemp48 + 3737.0 * fTemp49)));
			double fTemp136 = std::tan(fConst5 * fTemp135);
			double fTemp137 = fTemp136 * (fTemp56 - fRec110[1]) + fRec109[1];
			double fTemp138 = fTemp136 * (fTemp136 + fTemp62 / fTemp135) + 1.0;
			double fTemp139 = fTemp137 / fTemp138;
			fRec109[0] = 2.0 * fTemp139 - fRec109[1];
			fRec110[0] = fRec110[1] + 2.0 * (fTemp136 * fTemp137 / fTemp138);
			double fRec111 = fTemp139;
			double fTemp140 = fTemp21 * (fTemp29 * (fTemp31 * (1371.0 * fTemp33 + 1958.0 * fTemp34) + fTemp35 * (1855.0 * fTemp37 + 3517.0 * fTemp38)) + fTemp39 * (fTemp42 * (1371.0 * fTemp44 + 1958.0 * fTemp45) + fTemp46 * (1855.0 * fTemp48 + 3517.0 * fTemp49)));
			double fTemp141 = std::tan(fConst5 * fTemp140);
			double fTemp142 = fTemp141 * (fTemp56 - fRec113[1]) + fRec112[1];
			double fTemp143 = fTemp141 * (fTemp141 + fTemp62 / fTemp140) + 1.0;
			double fTemp144 = fTemp142 / fTemp143;
			fRec112[0] = 2.0 * fTemp144 - fRec112[1];
			fRec113[0] = fRec113[1] + 2.0 * (fTemp141 * fTemp142 / fTemp143);
			double fRec114 = fTemp144;
			double fTemp145 = fTemp21 * (fTemp29 * (fTemp31 * (131.0 * fTemp33 + 195.0 * fTemp34) + fTemp35 * (147.0 * fTemp37 + 1.3e+02 * fTemp38)) + fTemp39 * (fTemp42 * (131.0 * fTemp44 + 195.0 * fTemp45) + fTemp46 * (147.0 * fTemp48 + 1.3e+02 * fTemp49)));
			double fTemp146 = std::tan(fConst5 * fTemp145);
			double fTemp147 = fTemp146 * (fTemp56 - fRec116[1]) + fRec115[1];
			double fTemp148 = fTemp146 * (fTemp146 + fTemp62 / fTemp145) + 1.0;
			double fTemp149 = fTemp147 / fTemp148;
			fRec115[0] = 2.0 * fTemp149 - fRec115[1];
			fRec116[0] = fRec116[1] + 2.0 * (fTemp146 * fTemp147 / fTemp148);
			double fRec117 = fTemp149;
			double fTemp150 = (fTemp29 * ((65.0 * fTemp33 + 98.0 * fTemp34) * fTemp31 + (53.0 * fTemp37 + 5e+01 * fTemp38) * fTemp35) + fTemp39 * ((65.0 * fTemp44 + 98.0 * fTemp45) * fTemp42 + (53.0 * fTemp48 + 5e+01 * fTemp49) * fTemp46)) * fTemp21;
			double fTemp151 = std::tan(fConst5 * fTemp150);
			double fTemp152 = fTemp151 * (fTemp56 - fRec119[1]) + fRec118[1];
			double fTemp153 = fTemp151 * (fTemp151 + fTemp62 / fTemp150) + 1.0;
			double fTemp154 = fTemp152 / fTemp153;
			fRec118[0] = 2.0 * fTemp154 - fRec118[1];
			fRec119[0] = fRec119[1] + 2.0 * (fTemp151 * fTemp152 / fTemp153);
			double fRec120 = fTemp154;
			double fTemp155 = fTemp21 * (fTemp29 * (fTemp31 * (196.0 * fTemp33 + 293.0 * fTemp34) + fTemp35 * (203.0 * fTemp37 + 2.2e+02 * fTemp38)) + fTemp39 * (fTemp42 * (196.0 * fTemp44 + 293.0 * fTemp45) + fTemp46 * (203.0 * fTemp48 + 2.2e+02 * fTemp49)));
			double fTemp156 = std::tan(fConst5 * fTemp155);
			double fTemp157 = fTemp156 * (fTemp56 - fRec122[1]) + fRec121[1];
			double fTemp158 = fTemp156 * (fTemp156 + fTemp62 / fTemp155) + 1.0;
			double fTemp159 = fTemp157 / fTemp158;
			fRec121[0] = 2.0 * fTemp159 - fRec121[1];
			fRec122[0] = fRec122[1] + 2.0 * (fTemp156 * fTemp157 / fTemp158);
			double fRec123 = fTemp159;
			double fTemp160 = fTemp21 * (fTemp29 * (fTemp31 * (261.0 * fTemp33 + 391.0 * fTemp34) + fTemp35 * (294.0 * fTemp37 + 309.0 * fTemp38)) + fTemp39 * (fTemp42 * (261.0 * fTemp44 + 391.0 * fTemp45) + fTemp46 * (294.0 * fTemp48 + 309.0 * fTemp49)));
			double fTemp161 = std::tan(fConst5 * fTemp160);
			double fTemp162 = fTemp161 * (fTemp56 - fRec125[1]) + fRec124[1];
			double fTemp163 = fTemp161 * (fTemp161 + fTemp62 / fTemp160) + 1.0;
			double fTemp164 = fTemp162 / fTemp163;
			fRec124[0] = 2.0 * fTemp164 - fRec124[1];
			fRec125[0] = fRec125[1] + 2.0 * (fTemp161 * fTemp162 / fTemp163);
			double fRec126 = fTemp164;
			double fTemp165 = fTemp21 * (fTemp29 * (fTemp31 * (326.0 * fTemp33 + 489.0 * fTemp34) + fTemp35 * (367.0 * fTemp37 + 368.0 * fTemp38)) + fTemp39 * (fTemp42 * (326.0 * fTemp44 + 489.0 * fTemp45) + fTemp46 * (367.0 * fTemp48 + 368.0 * fTemp49)));
			double fTemp166 = std::tan(fConst5 * fTemp165);
			double fTemp167 = fTemp166 * (fTemp56 - fRec128[1]) + fRec127[1];
			double fTemp168 = fTemp166 * (fTemp166 + fTemp62 / fTemp165) + 1.0;
			double fTemp169 = fTemp167 / fTemp168;
			fRec127[0] = 2.0 * fTemp169 - fRec127[1];
			fRec128[0] = fRec128[1] + 2.0 * (fTemp166 * fTemp167 / fTemp168);
			double fRec129 = fTemp169;
			double fTemp170 = fTemp21 * (fTemp29 * (fTemp31 * (392.0 * fTemp33 + 537.0 * fTemp34) + fTemp35 * (441.0 * fTemp37 + 439.0 * fTemp38)) + fTemp39 * (fTemp42 * (392.0 * fTemp44 + 537.0 * fTemp45) + fTemp46 * (441.0 * fTemp48 + 439.0 * fTemp49)));
			double fTemp171 = std::tan(fConst5 * fTemp170);
			double fTemp172 = fTemp171 * (fTemp56 - fRec131[1]) + fRec130[1];
			double fTemp173 = fTemp171 * (fTemp171 + fTemp62 / fTemp170) + 1.0;
			double fTemp174 = fTemp172 / fTemp173;
			fRec130[0] = 2.0 * fTemp174 - fRec130[1];
			fRec131[0] = fRec131[1] + 2.0 * (fTemp171 * fTemp172 / fTemp173);
			double fRec132 = fTemp174;
			double fTemp175 = fTemp21 * (fTemp29 * (fTemp31 * (457.0 * fTemp33 + 587.0 * fTemp34) + fTemp35 * (534.0 * fTemp37 + 538.0 * fTemp38)) + fTemp39 * (fTemp42 * (457.0 * fTemp44 + 587.0 * fTemp45) + fTemp46 * (534.0 * fTemp48 + 538.0 * fTemp49)));
			double fTemp176 = std::tan(fConst5 * fTemp175);
			double fTemp177 = fTemp176 * (fTemp56 - fRec134[1]) + fRec133[1];
			double fTemp178 = fTemp176 * (fTemp176 + fTemp62 / fTemp175) + 1.0;
			double fTemp179 = fTemp177 / fTemp178;
			fRec133[0] = 2.0 * fTemp179 - fRec133[1];
			fRec134[0] = fRec134[1] + 2.0 * (fTemp176 * fTemp177 / fTemp178);
			double fRec135 = fTemp179;
			double fTemp180 = fTemp21 * (fTemp29 * (fTemp31 * (522.0 * fTemp33 + 685.0 * fTemp34) + fTemp35 * (588.0 * fTemp37 + 659.0 * fTemp38)) + fTemp39 * (fTemp42 * (522.0 * fTemp44 + 685.0 * fTemp45) + fTemp46 * (588.0 * fTemp48 + 659.0 * fTemp49)));
			double fTemp181 = std::tan(fConst5 * fTemp180);
			double fTemp182 = fTemp181 * (fTemp56 - fRec137[1]) + fRec136[1];
			double fTemp183 = fTemp181 * (fTemp181 + fTemp62 / fTemp180) + 1.0;
			double fTemp184 = fTemp182 / fTemp183;
			fRec136[0] = 2.0 * fTemp184 - fRec136[1];
			fRec137[0] = fRec137[1] + 2.0 * (fTemp181 * fTemp182 / fTemp183);
			double fRec138 = fTemp184;
			double fTemp185 = fTemp21 * (fTemp29 * (fTemp31 * (588.0 * fTemp33 + 783.0 * fTemp34) + fTemp35 * (735.0 * fTemp37 + 879.0 * fTemp38)) + fTemp39 * (fTemp42 * (588.0 * fTemp44 + 783.0 * fTemp45) + fTemp46 * (735.0 * fTemp48 + 879.0 * fTemp49)));
			double fTemp186 = std::tan(fConst5 * fTemp185);
			double fTemp187 = fTemp186 * (fTemp56 - fRec140[1]) + fRec139[1];
			double fTemp188 = fTemp186 * (fTemp186 + fTemp62 / fTemp185) + 1.0;
			double fTemp189 = fTemp187 / fTemp188;
			fRec139[0] = 2.0 * fTemp189 - fRec139[1];
			fRec140[0] = fRec140[1] + 2.0 * (fTemp186 * fTemp187 / fTemp188);
			double fRec141 = fTemp189;
			double fTemp190 = fTemp21 * (fTemp29 * (fTemp31 * (653.0 * fTemp33 + 8.8e+02 * fTemp34) + fTemp35 * (785.0 * fTemp37 + 1099.0 * fTemp38)) + fTemp39 * (fTemp42 * (653.0 * fTemp44 + 8.8e+02 * fTemp45) + fTemp46 * (785.0 * fTemp48 + 1099.0 * fTemp49)));
			double fTemp191 = std::tan(fConst5 * fTemp190);
			double fTemp192 = fTemp191 * (fTemp56 - fRec143[1]) + fRec142[1];
			double fTemp193 = fTemp191 * (fTemp191 + fTemp62 / fTemp190) + 1.0;
			double fTemp194 = fTemp192 / fTemp193;
			fRec142[0] = 2.0 * fTemp194 - fRec142[1];
			fRec143[0] = fRec143[1] + 2.0 * (fTemp191 * fTemp192 / fTemp193);
			double fRec144 = fTemp194;
			double fTemp195 = fTemp21 * (fTemp29 * (fTemp31 * (718.0 * fTemp33 + 979.0 * fTemp34) + fTemp35 * (882.0 * fTemp37 + 1319.0 * fTemp38)) + fTemp39 * (fTemp42 * (718.0 * fTemp44 + 979.0 * fTemp45) + fTemp46 * (882.0 * fTemp48 + 1319.0 * fTemp49)));
			double fTemp196 = std::tan(fConst5 * fTemp195);
			double fTemp197 = fTemp196 * (fTemp56 - fRec146[1]) + fRec145[1];
			double fTemp198 = fTemp196 * (fTemp196 + fTemp62 / fTemp195) + 1.0;
			double fTemp199 = fTemp197 / fTemp198;
			fRec145[0] = 2.0 * fTemp199 - fRec145[1];
			fRec146[0] = fRec146[1] + 2.0 * (fTemp196 * fTemp197 / fTemp198);
			double fRec147 = fTemp199;
			double fTemp200 = fTemp21 * (fTemp29 * (fTemp31 * (1959.0 * fTemp33 + 2937.0 * fTemp34) + fTemp35 * (2792.0 * fTemp37 + 7035.0 * fTemp38)) + fTemp39 * (fTemp42 * (1959.0 * fTemp44 + 2937.0 * fTemp45) + fTemp46 * (2792.0 * fTemp48 + 7035.0 * fTemp49)));
			double fTemp201 = std::tan(fConst5 * fTemp200);
			double fTemp202 = fTemp201 * (fTemp56 - fRec149[1]) + fRec148[1];
			double fTemp203 = fTemp201 * (fTemp201 + fTemp62 / fTemp200) + 1.0;
			double fTemp204 = fTemp202 / fTemp203;
			fRec148[0] = 2.0 * fTemp204 - fRec148[1];
			fRec149[0] = fRec149[1] + 2.0 * (fTemp201 * fTemp202 / fTemp203);
			double fRec150 = fTemp204;
			double fTemp205 = fTemp21 * (fTemp29 * (fTemp31 * (2024.0 * fTemp33 + 3.23e+03 * fTemp34) + fTemp35 * (3233.0 * fTemp37 + 7255.0 * fTemp38)) + fTemp39 * (fTemp42 * (2024.0 * fTemp44 + 3.23e+03 * fTemp45) + fTemp46 * (3233.0 * fTemp48 + 7255.0 * fTemp49)));
			double fTemp206 = std::tan(fConst5 * fTemp205);
			double fTemp207 = fTemp206 * (fTemp56 - fRec152[1]) + fRec151[1];
			double fTemp208 = fTemp206 * (fTemp206 + fTemp62 / fTemp205) + 1.0;
			double fTemp209 = fTemp207 / fTemp208;
			fRec151[0] = 2.0 * fTemp209 - fRec151[1];
			fRec152[0] = fRec152[1] + 2.0 * (fTemp206 * fTemp207 / fTemp208);
			double fRec153 = fTemp209;
			double fTemp210 = fTemp21 * (fTemp29 * (fTemp31 * (2089.0 * fTemp33 + 3328.0 * fTemp34) + fTemp35 * (3.38e+03 * fTemp37 + 8574.0 * fTemp38)) + fTemp39 * (fTemp42 * (2089.0 * fTemp44 + 3328.0 * fTemp45) + fTemp46 * (3.38e+03 * fTemp48 + 8574.0 * fTemp49)));
			double fTemp211 = std::tan(fConst5 * fTemp210);
			double fTemp212 = fTemp211 * (fTemp56 - fRec155[1]) + fRec154[1];
			double fTemp213 = fTemp211 * (fTemp211 + fTemp62 / fTemp210) + 1.0;
			double fTemp214 = fTemp212 / fTemp213;
			fRec154[0] = 2.0 * fTemp214 - fRec154[1];
			fRec155[0] = fRec155[1] + 2.0 * (fTemp211 * fTemp212 / fTemp213);
			double fRec156 = fTemp214;
			double fTemp215 = fTemp21 * (fTemp29 * (fTemp31 * (2351.0 * fTemp33 + 4013.0 * fTemp34) + fTemp35 * (3527.0 * fTemp37 + 9672.0 * fTemp38)) + fTemp39 * (fTemp42 * (2351.0 * fTemp44 + 4013.0 * fTemp45) + fTemp46 * (3527.0 * fTemp48 + 9672.0 * fTemp49)));
			double fTemp216 = std::tan(fConst5 * fTemp215);
			double fTemp217 = fTemp216 * (fTemp56 - fRec158[1]) + fRec157[1];
			double fTemp218 = fTemp216 * (fTemp216 + fTemp62 / fTemp215) + 1.0;
			double fTemp219 = fTemp217 / fTemp218;
			fRec157[0] = 2.0 * fTemp219 - fRec157[1];
			fRec158[0] = fRec158[1] + 2.0 * (fTemp216 * fTemp217 / fTemp218);
			double fRec159 = fTemp219;
			fRec12[0] = 0.6366197723675814 * std::atan(0.03125 * (fRec37 * (fTemp29 * (fTemp31 * (0.00848029 * fTemp33 + 0.01670722 * fTemp34) + fTemp35 * (0.05126037 * fTemp37 + 0.03283333 * fTemp38)) + fTemp39 * (fTemp42 * (0.00848029 * fTemp44 + 0.01670722 * fTemp45) + fTemp46 * (0.05126037 * fTemp48 + 0.03283333 * fTemp49))) + fRec69 * (fTemp29 * (fTemp31 * (0.00496045 * fTemp33 + 0.02143791 * fTemp34) + fTemp35 * (0.07354127 * fTemp37 + 0.01222045 * fTemp38)) + fTemp39 * (fTemp42 * (0.00496045 * fTemp44 + 0.02143791 * fTemp45) + fTemp46 * (0.07354127 * fTemp48 + 0.01222045 * fTemp49))) + fRec72 * (fTemp29 * (fTemp31 * (0.00482074 * fTemp33 + 0.01863539 * fTemp34) + fTemp35 * (0.06191843 * fTemp37 + 0.03888326 * fTemp38)) + fTemp39 * (fTemp42 * (0.00482074 * fTemp44 + 0.01863539 * fTemp45) + fTemp46 * (0.06191843 * fTemp48 + 0.03888326 * fTemp49))) + fRec75 * (fTemp29 * (fTemp31 * (0.02735344 * fTemp33 + 0.02193515 * fTemp34) + fTemp35 * (0.07170723 * fTemp37 + 0.04759307 * fTemp38)) + fTemp39 * (fTemp42 * (0.02735344 * fTemp44 + 0.02193515 * fTemp45) + fTemp46 * (0.07170723 * fTemp48 + 0.04759307 * fTemp49))) + fRec78 * (fTemp29 * (fTemp31 * (0.02222397 * fTemp33 + 0.00886369 * fTemp34) + fTemp35 * (0.02115358 * fTemp37 + 0.02409027 * fTemp38)) + fTemp39 * (fTemp42 * (0.02222397 * fTemp44 + 0.00886369 * fTemp45) + fTemp46 * (0.02115358 * fTemp48 + 0.02409027 * fTemp49))) + fRec81 * (fTemp29 * (fTemp31 * (0.01985851 * fTemp33 + 0.00274825 * fTemp34) + fTemp35 * (0.28175268 * fTemp37 + 0.22375855 * fTemp38)) + fTemp39 * (fTemp42 * (0.01985851 * fTemp44 + 0.00274825 * fTemp45) + fTemp46 * (0.28175268 * fTemp48 + 0.22375855 * fTemp49))) + fRec84 * (fTemp29 * (fTemp31 * (0.03480883 * fTemp33 + 0.02102163 * fTemp34) + fTemp35 * (0.01626654 * fTemp37 + 0.03442368 * fTemp38)) + fTemp39 * (fTemp42 * (0.03480883 * fTemp44 + 0.02102163 * fTemp45) + fTemp46 * (0.01626654 * fTemp48 + 0.03442368 * fTemp49))) + fRec87 * (fTemp29 * (fTemp31 * (0.05834666 * fTemp33 + 0.01772408 * fTemp34) + fTemp35 * (0.14442907 * fTemp37 + 0.07338235 * fTemp38)) + fTemp39 * (fTemp42 * (0.05834666 * fTemp44 + 0.01772408 * fTemp45) + fTemp46 * (0.14442907 * fTemp48 + 0.07338235 * fTemp49))) + fRec90 * (fTemp29 * (fTemp31 * (0.02913938 * fTemp33 + 0.03638926 * fTemp34) + fTemp35 * (0.01228042 * fTemp37 + 0.08982961 * fTemp38)) + fTemp39 * (fTemp42 * (0.02913938 * fTemp44 + 0.03638926 * fTemp45) + fTemp46 * (0.01228042 * fTemp48 + 0.08982961 * fTemp49))) + fRec93 * (fTemp29 * (fTemp31 * (0.00722225 * fTemp33 + 0.00320751 * fTemp34) + fTemp35 * (0.01055565 * fTemp37 + 0.00841917 * fTemp38)) + fTemp39 * (fTemp42 * (0.00722225 * fTemp44 + 0.00320751 * fTemp45) + fTemp46 * (0.01055565 * fTemp48 + 0.00841917 * fTemp49))) + fRec96 * (fTemp29 * (fTemp31 * (0.01041008 * fTemp33 + 0.00333966 * fTemp34) + fTemp35 * (0.01134687 * fTemp37 + 0.01369543 * fTemp38)) + fTemp39 * (fTemp42 * (0.01041008 * fTemp44 + 0.00333966 * fTemp45) + fTemp46 * (0.01134687 * fTemp48 + 0.01369543 * fTemp49))) + fRec99 * (fTemp29 * (fTemp31 * (0.00722812 * fTemp33 + 0.00161424 * fTemp34) + fTemp35 * (0.01233555 * fTemp37 + 0.01528356 * fTemp38)) + fTemp39 * (fTemp42 * (0.00722812 * fTemp44 + 0.00161424 * fTemp45) + fTemp46 * (0.01233555 * fTemp48 + 0.01528356 * fTemp49))) + fRec102 * (fTemp29 * (fTemp31 * (0.00729633 * fTemp33 + 0.00190274 * fTemp34) + fTemp35 * (0.00656447 * fTemp37 + 0.00854136 * fTemp38)) + fTemp39 * (fTemp42 * (0.00729633 * fTemp44 + 0.00190274 * fTemp45) + fTemp46 * (0.00656447 * fTemp48 + 0.00854136 * fTemp49))) + fRec105 * (fTemp29 * (fTemp31 * (0.02313585 * fTemp33 + 0.00348521 * fTemp34) + fTemp35 * (0.09585942 * fTemp37 + 0.01776269 * fTemp38)) + fTemp39 * (fTemp42 * (0.02313585 * fTemp44 + 0.00348521 * fTemp45) + fTemp46 * (0.09585942 * fTemp48 + 0.01776269 * fTemp49))) + fRec108 * (fTemp29 * (fTemp31 * (0.04640077 * fTemp33 + 0.01305707 * fTemp34) + fTemp35 * (0.06985491 * fTemp37 + 0.01631748 * fTemp38)) + fTemp39 * (fTemp42 * (0.04640077 * fTemp44 + 0.01305707 * fTemp45) + fTemp46 * (0.06985491 * fTemp48 + 0.01631748 * fTemp49))) + fRec111 * (fTemp29 * (fTemp31 * (0.0121161 * fTemp33 + 0.00709897 * fTemp34) + fTemp35 * (0.0343155 * fTemp37 + 0.02601317 * fTemp38)) + fTemp39 * (fTemp42 * (0.0121161 * fTemp44 + 0.00709897 * fTemp45) + fTemp46 * (0.0343155 * fTemp48 + 0.02601317 * fTemp49))) + fRec114 * (fTemp29 * (fTemp31 * (0.01668042 * fTemp33 + 0.01592137 * fTemp34) + fTemp35 * (0.01093969 * fTemp37 + 0.02061391 * fTemp38)) + fTemp39 * (fTemp42 * (0.01668042 * fTemp44 + 0.01592137 * fTemp45) + fTemp46 * (0.01093969 * fTemp48 + 0.02061391 * fTemp49))) + fRec117 * (fTemp29 * (fTemp31 * (fTemp34 + 0.27707616 * fTemp33) + fTemp35 * (fTemp37 + 0.01216278 * fTemp38)) + fTemp39 * (fTemp42 * (fTemp45 + 0.27707616 * fTemp44) + fTemp46 * (fTemp48 + 0.01216278 * fTemp49))) + fRec120 * (fTemp29 * (fTemp31 * (0.04196492 * fTemp33 + 0.75217775 * fTemp34) + fTemp35 * (0.07116083 * fTemp37 + 0.01835863 * fTemp38)) + fTemp39 * (fTemp42 * (0.04196492 * fTemp44 + 0.75217775 * fTemp45) + fTemp46 * (0.07116083 * fTemp48 + 0.01835863 * fTemp49))) + fRec123 * (fTemp29 * (fTemp31 * (fTemp33 + 0.09843679 * fTemp34) + fTemp35 * (fTemp38 + 0.0405712 * fTemp37)) + fTemp39 * (fTemp42 * (fTemp44 + 0.09843679 * fTemp45) + fTemp46 * (fTemp49 + 0.0405712 * fTemp48))) + fRec126 * (fTemp29 * (fTemp31 * (0.08153769 * fTemp33 + 0.02426847 * fTemp34) + fTemp35 * (0.49828005 * fTemp37 + 0.00749257 * fTemp38)) + fTemp39 * (fTemp42 * (0.08153769 * fTemp44 + 0.02426847 * fTemp45) + fTemp46 * (0.49828005 * fTemp48 + 0.00749257 * fTemp49))) + fRec129 * (fTemp29 * (fTemp31 * (0.05522969 * fTemp33 + 0.06051622 * fTemp34) + fTemp35 * (0.02470587 * fTemp37 + 0.01035828 * fTemp38)) + fTemp39 * (fTemp42 * (0.05522969 * fTemp44 + 0.06051622 * fTemp45) + fTemp46 * (0.02470587 * fTemp48 + 0.01035828 * fTemp49))) + fRec132 * (fTemp29 * (fTemp31 * (0.01922137 * fTemp33 + 0.00787687 * fTemp34) + fTemp35 * (0.25042786 * fTemp37 + 0.6674602 * fTemp38)) + fTemp39 * (fTemp42 * (0.01922137 * fTemp44 + 0.00787687 * fTemp45) + fTemp46 * (0.25042786 * fTemp48 + 0.6674602 * fTemp49))) + fRec135 * (fTemp29 * (fTemp31 * (0.03436227 * fTemp33 + 0.04838698 * fTemp34) + fTemp35 * (0.0250452 * fTemp37 + 0.00707754 * fTemp38)) + fTemp39 * (fTemp42 * (0.03436227 * fTemp44 + 0.04838698 * fTemp45) + fTemp46 * (0.0250452 * fTemp48 + 0.00707754 * fTemp49))) + fRec138 * (fTemp29 * (fTemp31 * (0.03067041 * fTemp33 + 0.05785498 * fTemp34) + fTemp35 * (0.09954785 * fTemp37 + 0.62411215 * fTemp38)) + fTemp39 * (fTemp42 * (0.03067041 * fTemp44 + 0.05785498 * fTemp45) + fTemp46 * (0.09954785 * fTemp48 + 0.62411215 * fTemp49))) + fRec141 * (fTemp29 * (fTemp31 * (0.01797695 * fTemp33 + 0.0640251 * fTemp34) + fTemp35 * (0.54357606 * fTemp37 + 0.4053105 * fTemp38)) + fTemp39 * (fTemp42 * (0.01797695 * fTemp44 + 0.0640251 * fTemp45) + fTemp46 * (0.54357606 * fTemp48 + 0.4053105 * fTemp49))) + fRec144 * (fTemp29 * (fTemp31 * (0.03381146 * fTemp33 + 0.05363475 * fTemp34) + fTemp35 * (0.01573797 * fTemp37 + 0.64427134 * fTemp38)) + fTemp39 * (fTemp42 * (0.03381146 * fTemp44 + 0.05363475 * fTemp45) + fTemp46 * (0.01573797 * fTemp48 + 0.64427134 * fTemp49))) + fRec147 * (fTemp29 * (fTemp31 * (0.0550058 * fTemp33 + 0.02121633 * fTemp34) + fTemp35 * (0.2722688 * fTemp37 + 0.27821024 * fTemp38)) + fTemp39 * (fTemp42 * (0.0550058 * fTemp44 + 0.02121633 * fTemp45) + fTemp46 * (0.2722688 * fTemp48 + 0.27821024 * fTemp49))) + fRec150 * (fTemp29 * (fTemp31 * (0.00592071 * fTemp33 + 0.00126865 * fTemp34) + fTemp35 * (0.03127152 * fTemp37 + 0.02237106 * fTemp38)) + fTemp39 * (fTemp42 * (0.00592071 * fTemp44 + 0.00126865 * fTemp45) + fTemp46 * (0.03127152 * fTemp48 + 0.02237106 * fTemp49))) + fRec153 * (fTemp29 * (fTemp31 * (0.01158114 * fTemp33 + 0.00132724 * fTemp34) + fTemp35 * (0.01587526 * fTemp37 + 0.00969712 * fTemp38)) + fTemp39 * (fTemp42 * (0.01158114 * fTemp44 + 0.00132724 * fTemp45) + fTemp46 * (0.01587526 * fTemp48 + 0.00969712 * fTemp49))) + fRec156 * (fTemp29 * (fTemp31 * (0.00443968 * fTemp33 + 0.00152525 * fTemp34) + fTemp35 * (0.00962998 * fTemp37 + 0.00986048 * fTemp38)) + fTemp39 * (fTemp42 * (0.00443968 * fTemp44 + 0.00152525 * fTemp45) + fTemp46 * (0.00962998 * fTemp48 + 0.00986048 * fTemp49))) + fRec159 * (fTemp29 * (fTemp31 * (0.00282064 * fTemp33 + 0.00097757 * fTemp34) + fTemp35 * (0.0068168 * fTemp37 + 0.01255551 * fTemp38)) + fTemp39 * (fTemp42 * (0.00282064 * fTemp44 + 0.00097757 * fTemp45) + fTemp46 * (0.0068168 * fTemp48 + 0.01255551 * fTemp49)))));
			fRec3[0] = fRec12[0];
			fRec166[0] = std::fmod(fRec166[1], fConst0) + std::fabs(0.1 * fRec165[1]) + 0.1;
			int iTemp220 = (fConst1 * fRec166[0]) < (fConst1 * fRec166[1]);
			iVec11[0] = 53;
			iRec167[0] = (53 - iVec11[1]) % -2147483648 + (12345 - 59 * iRec167[1]);
			fRec165[0] = fRec165[1] * double(iVec0[1] - iTemp220) + (0.0 - 4.656612873077393e-10 * double(iRec167[0])) * double(iTemp220 + iTemp1);
			int iTemp221 = fRec165[0] == fRec165[1];
			fRec164[0] = fRec164[1] * double(iTemp221) + 0.125 * fTemp3 * double(1 - iTemp221);
			double fTemp222 = ((fRec164[0] != fRec164[1]) ? fConst4 : fRec162[1] + -1.0);
			fRec162[0] = fTemp222;
			fRec163[0] = ((fTemp222 > 0.0) ? fRec163[1] + (fRec164[0] - fRec163[1]) / fTemp222 : fRec164[0]);
			double fTemp223 = tanh(fRec13[0] + fSlow4 * std::sin(6.283185307179586 * fRec163[0])) + 1.0;
			fVbargraph7 = FAUSTFLOAT(5e+02 * fTemp223);
			double fTemp224 = (fTemp6 * 0.5 * fTemp223 + 1.0) * fRec160[1];
			double fTemp225 = mydsp_faustpower3_f(fRec161[1]);
			fRec173[0] = std::fmod(fRec173[1], fConst0) + std::fabs(0.1 * fRec172[1]) + 0.1;
			int iTemp226 = (fConst1 * fRec173[0]) < (fConst1 * fRec173[1]);
			iVec12[0] = 31;
			iRec174[0] = (31 - iVec12[1]) % -2147483648 + (12345 - 59 * iRec174[1]);
			fRec172[0] = fRec172[1] * double(iVec0[1] - iTemp226) + (0.0 - 4.656612873077393e-10 * double(iRec174[0])) * double(iTemp226 + iTemp1);
			int iTemp227 = fRec172[0] == fRec172[1];
			fRec171[0] = fRec171[1] * double(iTemp227) + 0.125 * fTemp3 * double(1 - iTemp227);
			double fTemp228 = ((fRec171[0] != fRec171[1]) ? fConst4 : fRec169[1] + -1.0);
			fRec169[0] = fTemp228;
			fRec170[0] = ((fTemp228 > 0.0) ? fRec170[1] + (fRec171[0] - fRec170[1]) / fTemp228 : fRec171[0]);
			double fTemp229 = std::pow(5e+02, tanh(fRec21[0] + fSlow4 * std::sin(6.283185307179586 * fRec170[0])));
			fVbargraph8 = FAUSTFLOAT(1e+03 * fTemp229);
			fRec168[0] = fRec168[1] + fConst1 * fTemp229;
			fRec179[0] = std::fmod(fRec179[1], fConst0) + std::fabs(0.1 * fRec178[1]) + 0.1;
			int iTemp230 = (fConst1 * fRec179[0]) < (fConst1 * fRec179[1]);
			iVec13[0] = 47;
			iRec180[0] = (47 - iVec13[1]) % -2147483648 + (12345 - 59 * iRec180[1]);
			fRec178[0] = fRec178[1] * double(iVec0[1] - iTemp230) + (0.0 - 4.656612873077393e-10 * double(iRec180[0])) * double(iTemp230 + iTemp1);
			int iTemp231 = fRec178[0] == fRec178[1];
			fRec177[0] = fRec177[1] * double(iTemp231) + 0.125 * fTemp3 * double(1 - iTemp231);
			double fTemp232 = ((fRec177[0] != fRec177[1]) ? fConst4 : fRec175[1] + -1.0);
			fRec175[0] = fTemp232;
			fRec176[0] = ((fTemp232 > 0.0) ? fRec176[1] + (fRec177[0] - fRec176[1]) / fTemp232 : fRec177[0]);
			double fTemp233 = tanh(fRec28[0] + fSlow4 * std::sin(6.283185307179586 * fRec176[0])) + 1.0;
			fVbargraph9 = FAUSTFLOAT(5e+02 * fTemp233);
			double fTemp234 = std::cos(fRec168[0]) * 0.5 * fTemp233;
			double fTemp235 = 0.0 - (fTemp224 + fTemp225 + fTemp234);
			fVec14[0] = fTemp235;
			fRec160[0] = fTemp235;
			fRec188[0] = std::fmod(fRec188[1], fConst0) + std::fabs(0.1 * fRec187[1]) + 0.1;
			int iTemp236 = (fConst1 * fRec188[0]) < (fConst1 * fRec188[1]);
			iVec15[0] = 37;
			iRec189[0] = (37 - iVec15[1]) % -2147483648 + (12345 - 59 * iRec189[1]);
			fRec187[0] = fRec187[1] * double(iVec0[1] - iTemp236) + (0.0 - 4.656612873077393e-10 * double(iRec189[0])) * double(iTemp236 + iTemp1);
			int iTemp237 = fRec187[0] == fRec187[1];
			fRec186[0] = fRec186[1] * double(iTemp237) + 0.125 * fTemp3 * double(1 - iTemp237);
			double fTemp238 = ((fRec186[0] != fRec186[1]) ? fConst4 : fRec184[1] + -1.0);
			fRec184[0] = fTemp238;
			fRec185[0] = ((fTemp238 > 0.0) ? fRec185[1] + (fRec186[0] - fRec185[1]) / fTemp238 : fRec186[0]);
			double fTemp239 = 0.45 * (tanh(fRec38[0] + fSlow4 * std::sin(6.283185307179586 * fRec185[0])) + 1.0) + 0.1;
			fVbargraph10 = FAUSTFLOAT(1e+03 * fTemp239);
			double fTemp240 = fTemp239;
			fRec194[0] = std::fmod(fRec194[1], fConst0) + std::fabs(0.1 * fRec193[1]) + 0.1;
			int iTemp241 = (fConst1 * fRec194[0]) < (fConst1 * fRec194[1]);
			iVec16[0] = 41;
			iRec195[0] = (41 - iVec16[1]) % -2147483648 + (12345 - 59 * iRec195[1]);
			fRec193[0] = fRec193[1] * double(iVec0[1] - iTemp241) + (0.0 - 4.656612873077393e-10 * double(iRec195[0])) * double(iTemp241 + iTemp1);
			int iTemp242 = fRec193[0] == fRec193[1];
			fRec192[0] = fRec192[1] * double(iTemp242) + 0.125 * fTemp3 * double(1 - iTemp242);
			double fTemp243 = ((fRec192[0] != fRec192[1]) ? fConst4 : fRec190[1] + -1.0);
			fRec190[0] = fTemp243;
			fRec191[0] = ((fTemp243 > 0.0) ? fRec191[1] + (fRec192[0] - fRec191[1]) / fTemp243 : fRec192[0]);
			double fTemp244 = tanh(fRec45[0] + fSlow4 * std::sin(6.283185307179586 * fRec191[0])) + 1.0;
			fVbargraph11 = FAUSTFLOAT(5e+02 * fTemp244);
			double fTemp245 = 4.0 * 0.5 * fTemp244;
			int iTemp246 = int(fTemp245);
			double fTemp247 = double(iTemp246);
			double fTemp248 = fTemp247 + (1.0 - fTemp245);
			int iTemp249 = iTemp246 >= 2;
			double fTemp250 = double(1 - iTemp249);
			int iTemp251 = iTemp246 >= 1;
			double fTemp252 = double(1 - iTemp251);
			double fTemp253 = double(iTemp251);
			double fTemp254 = double(iTemp249);
			int iTemp255 = iTemp246 >= 3;
			double fTemp256 = double(1 - iTemp255);
			double fTemp257 = double(iTemp255);
			double fTemp258 = fTemp245 - fTemp247;
			int iTemp259 = iTemp246 + 1;
			int iTemp260 = iTemp259 >= 2;
			double fTemp261 = double(1 - iTemp260);
			int iTemp262 = iTemp259 >= 1;
			double fTemp263 = double(1 - iTemp262);
			double fTemp264 = double(iTemp262);
			double fTemp265 = double(iTemp260);
			int iTemp266 = iTemp259 >= 3;
			double fTemp267 = double(1 - iTemp266);
			double fTemp268 = double(iTemp266);
			double fTemp269 = fTemp240 * (fTemp248 * (fTemp250 * (457.0 * fTemp252 + 587.0 * fTemp253) + fTemp254 * (534.0 * fTemp256 + 538.0 * fTemp257)) + fTemp258 * (fTemp261 * (457.0 * fTemp263 + 587.0 * fTemp264) + fTemp265 * (534.0 * fTemp267 + 538.0 * fTemp268)));
			double fTemp270 = std::tan(fConst5 * fTemp269);
			fRec196[0] = 0.995 * fRec196[1] - (fTemp234 + fTemp225 + fTemp224 + fVec14[1]);
			fRec201[0] = std::fmod(fRec201[1], fConst0) + std::fabs(0.1 * fRec200[1]) + 0.1;
			int iTemp271 = (fConst1 * fRec201[0]) < (fConst1 * fRec201[1]);
			iRec202[0] = (59 - iVec2[1]) % -2147483648 + (12345 - 59 * iRec202[1]);
			fRec200[0] = fRec200[1] * double(iVec0[1] - iTemp271) + (0.0 - 4.656612873077393e-10 * double(iRec202[0])) * double(iTemp271 + iTemp1);
			int iTemp272 = fRec200[0] == fRec200[1];
			fRec199[0] = fRec199[1] * double(iTemp272) + 0.125 * fTemp3 * double(1 - iTemp272);
			double fTemp273 = ((fRec199[0] != fRec199[1]) ? fConst4 : fRec197[1] + -1.0);
			fRec197[0] = fTemp273;
			fRec198[0] = ((fTemp273 > 0.0) ? fRec198[1] + (fRec199[0] - fRec198[1]) / fTemp273 : fRec199[0]);
			double fTemp274 = std::pow(1e+03, tanh(fRec53[0] + fSlow4 * std::sin(6.283185307179586 * fRec198[0])));
			fVbargraph12 = FAUSTFLOAT(fTemp274);
			double fTemp275 = fRec196[0] * fTemp274;
			double fTemp276 = fTemp270 * (fTemp275 - fRec182[1]) + fRec181[1];
			fRec207[0] = std::fmod(fRec207[1], fConst0) + std::fabs(0.1 * fRec206[1]) + 0.1;
			int iTemp277 = (fConst1 * fRec207[0]) < (fConst1 * fRec207[1]);
			iVec17[0] = 43;
			iRec208[0] = (43 - iVec17[1]) % -2147483648 + (12345 - 59 * iRec208[1]);
			fRec206[0] = fRec206[1] * double(iVec0[1] - iTemp277) + (0.0 - 4.656612873077393e-10 * double(iRec208[0])) * double(iTemp277 + iTemp1);
			int iTemp278 = fRec206[0] == fRec206[1];
			fRec205[0] = fRec205[1] * double(iTemp278) + 0.125 * fTemp3 * double(1 - iTemp278);
			double fTemp279 = ((fRec205[0] != fRec205[1]) ? fConst4 : fRec203[1] + -1.0);
			fRec203[0] = fTemp279;
			fRec204[0] = ((fTemp279 > 0.0) ? fRec204[1] + (fRec205[0] - fRec204[1]) / fTemp279 : fRec205[0]);
			double fTemp280 = std::pow(1e+02, tanh(fRec60[0] + fSlow4 * std::sin(6.283185307179586 * fRec204[0])));
			fVbargraph13 = FAUSTFLOAT(fTemp280);
			double fTemp281 = std::max<double>(2.220446049250313e-16, fTemp280);
			double fTemp282 = fTemp270 * (fTemp270 + fTemp281 / fTemp269) + 1.0;
			double fTemp283 = fTemp276 / fTemp282;
			fRec181[0] = 2.0 * fTemp283 - fRec181[1];
			fRec182[0] = fRec182[1] + 2.0 * (fTemp270 * fTemp276 / fTemp282);
			double fRec183 = fTemp283;
			double fTemp284 = fTemp240 * (fTemp248 * (fTemp250 * (392.0 * fTemp252 + 537.0 * fTemp253) + fTemp254 * (441.0 * fTemp256 + 439.0 * fTemp257)) + fTemp258 * (fTemp261 * (392.0 * fTemp263 + 537.0 * fTemp264) + fTemp265 * (441.0 * fTemp267 + 439.0 * fTemp268)));
			double fTemp285 = std::tan(fConst5 * fTemp284);
			double fTemp286 = fTemp285 * (fTemp275 - fRec210[1]) + fRec209[1];
			double fTemp287 = fTemp285 * (fTemp285 + fTemp281 / fTemp284) + 1.0;
			double fTemp288 = fTemp286 / fTemp287;
			fRec209[0] = 2.0 * fTemp288 - fRec209[1];
			fRec210[0] = fRec210[1] + 2.0 * (fTemp285 * fTemp286 / fTemp287);
			double fRec211 = fTemp288;
			double fTemp289 = fTemp240 * (fTemp248 * (fTemp250 * (326.0 * fTemp252 + 489.0 * fTemp253) + fTemp254 * (367.0 * fTemp256 + 368.0 * fTemp257)) + fTemp258 * (fTemp261 * (326.0 * fTemp263 + 489.0 * fTemp264) + fTemp265 * (367.0 * fTemp267 + 368.0 * fTemp268)));
			double fTemp290 = std::tan(fConst5 * fTemp289);
			double fTemp291 = fTemp290 * (fTemp275 - fRec213[1]) + fRec212[1];
			double fTemp292 = fTemp290 * (fTemp290 + fTemp281 / fTemp289) + 1.0;
			double fTemp293 = fTemp291 / fTemp292;
			fRec212[0] = 2.0 * fTemp293 - fRec212[1];
			fRec213[0] = fRec213[1] + 2.0 * (fTemp290 * fTemp291 / fTemp292);
			double fRec214 = fTemp293;
			double fTemp294 = fTemp240 * (fTemp248 * (fTemp250 * (261.0 * fTemp252 + 391.0 * fTemp253) + fTemp254 * (294.0 * fTemp256 + 309.0 * fTemp257)) + fTemp258 * (fTemp261 * (261.0 * fTemp263 + 391.0 * fTemp264) + fTemp265 * (294.0 * fTemp267 + 309.0 * fTemp268)));
			double fTemp295 = std::tan(fConst5 * fTemp294);
			double fTemp296 = fTemp295 * (fTemp275 - fRec216[1]) + fRec215[1];
			double fTemp297 = fTemp295 * (fTemp295 + fTemp281 / fTemp294) + 1.0;
			double fTemp298 = fTemp296 / fTemp297;
			fRec215[0] = 2.0 * fTemp298 - fRec215[1];
			fRec216[0] = fRec216[1] + 2.0 * (fTemp295 * fTemp296 / fTemp297);
			double fRec217 = fTemp298;
			double fTemp299 = fTemp240 * (fTemp248 * (fTemp250 * (196.0 * fTemp252 + 293.0 * fTemp253) + fTemp254 * (203.0 * fTemp256 + 2.2e+02 * fTemp257)) + fTemp258 * (fTemp261 * (196.0 * fTemp263 + 293.0 * fTemp264) + fTemp265 * (203.0 * fTemp267 + 2.2e+02 * fTemp268)));
			double fTemp300 = std::tan(fConst5 * fTemp299);
			double fTemp301 = fTemp300 * (fTemp275 - fRec219[1]) + fRec218[1];
			double fTemp302 = fTemp300 * (fTemp300 + fTemp281 / fTemp299) + 1.0;
			double fTemp303 = fTemp301 / fTemp302;
			fRec218[0] = 2.0 * fTemp303 - fRec218[1];
			fRec219[0] = fRec219[1] + 2.0 * (fTemp300 * fTemp301 / fTemp302);
			double fRec220 = fTemp303;
			double fTemp304 = fTemp240 * (fTemp248 * (fTemp250 * (131.0 * fTemp252 + 195.0 * fTemp253) + fTemp254 * (147.0 * fTemp256 + 1.3e+02 * fTemp257)) + fTemp258 * (fTemp261 * (131.0 * fTemp263 + 195.0 * fTemp264) + fTemp265 * (147.0 * fTemp267 + 1.3e+02 * fTemp268)));
			double fTemp305 = std::tan(fConst5 * fTemp304);
			double fTemp306 = fTemp305 * (fTemp275 - fRec222[1]) + fRec221[1];
			double fTemp307 = fTemp305 * (fTemp305 + fTemp281 / fTemp304) + 1.0;
			double fTemp308 = fTemp306 / fTemp307;
			fRec221[0] = 2.0 * fTemp308 - fRec221[1];
			fRec222[0] = fRec222[1] + 2.0 * (fTemp305 * fTemp306 / fTemp307);
			double fRec223 = fTemp308;
			double fTemp309 = (fTemp248 * ((65.0 * fTemp252 + 98.0 * fTemp253) * fTemp250 + (53.0 * fTemp256 + 5e+01 * fTemp257) * fTemp254) + fTemp258 * ((65.0 * fTemp263 + 98.0 * fTemp264) * fTemp261 + (53.0 * fTemp267 + 5e+01 * fTemp268) * fTemp265)) * fTemp240;
			double fTemp310 = std::tan(fConst5 * fTemp309);
			double fTemp311 = fTemp310 * (fTemp275 - fRec225[1]) + fRec224[1];
			double fTemp312 = fTemp310 * (fTemp310 + fTemp281 / fTemp309) + 1.0;
			double fTemp313 = fTemp311 / fTemp312;
			fRec224[0] = 2.0 * fTemp313 - fRec224[1];
			fRec225[0] = fRec225[1] + 2.0 * (fTemp310 * fTemp311 / fTemp312);
			double fRec226 = fTemp313;
			double fTemp314 = fTemp240 * (fTemp248 * (fTemp250 * (979.0 * fTemp252 + 1371.0 * fTemp253) + fTemp254 * (1175.0 * fTemp256 + 2198.0 * fTemp257)) + fTemp258 * (fTemp261 * (979.0 * fTemp263 + 1371.0 * fTemp264) + fTemp265 * (1175.0 * fTemp267 + 2198.0 * fTemp268)));
			double fTemp315 = std::tan(fConst5 * fTemp314);
			double fTemp316 = fTemp315 * (fTemp275 - fRec228[1]) + fRec227[1];
			double fTemp317 = fTemp315 * (fTemp315 + fTemp281 / fTemp314) + 1.0;
			double fTemp318 = fTemp316 / fTemp317;
			fRec227[0] = 2.0 * fTemp318 - fRec227[1];
			fRec228[0] = fRec228[1] + 2.0 * (fTemp315 * fTemp316 / fTemp317);
			double fRec229 = fTemp318;
			double fTemp319 = fTemp240 * (fTemp248 * (fTemp250 * (914.0 * fTemp252 + 1272.0 * fTemp253) + fTemp254 * (1078.0 * fTemp256 + 1978.0 * fTemp257)) + fTemp258 * (fTemp261 * (914.0 * fTemp263 + 1272.0 * fTemp264) + fTemp265 * (1078.0 * fTemp267 + 1978.0 * fTemp268)));
			double fTemp320 = std::tan(fConst5 * fTemp319);
			double fTemp321 = fTemp320 * (fTemp275 - fRec231[1]) + fRec230[1];
			double fTemp322 = fTemp320 * (fTemp320 + fTemp281 / fTemp319) + 1.0;
			double fTemp323 = fTemp321 / fTemp322;
			fRec230[0] = 2.0 * fTemp323 - fRec230[1];
			fRec231[0] = fRec231[1] + 2.0 * (fTemp320 * fTemp321 / fTemp322);
			double fRec232 = fTemp323;
			double fTemp324 = fTemp240 * (fTemp248 * (fTemp250 * (849.0 * fTemp252 + 1174.0 * fTemp253) + fTemp254 * (1028.0 * fTemp256 + 1759.0 * fTemp257)) + fTemp258 * (fTemp261 * (849.0 * fTemp263 + 1174.0 * fTemp264) + fTemp265 * (1028.0 * fTemp267 + 1759.0 * fTemp268)));
			double fTemp325 = std::tan(fConst5 * fTemp324);
			double fTemp326 = fTemp325 * (fTemp275 - fRec234[1]) + fRec233[1];
			double fTemp327 = fTemp325 * (fTemp325 + fTemp281 / fTemp324) + 1.0;
			double fTemp328 = fTemp326 / fTemp327;
			fRec233[0] = 2.0 * fTemp328 - fRec233[1];
			fRec234[0] = fRec234[1] + 2.0 * (fTemp325 * fTemp326 / fTemp327);
			double fRec235 = fTemp328;
			double fTemp329 = fTemp240 * (fTemp248 * (fTemp250 * (784.0 * fTemp252 + 1076.0 * fTemp253) + fTemp254 * (961.0 * fTemp256 + 1539.0 * fTemp257)) + fTemp258 * (fTemp261 * (784.0 * fTemp263 + 1076.0 * fTemp264) + fTemp265 * (961.0 * fTemp267 + 1539.0 * fTemp268)));
			double fTemp330 = std::tan(fConst5 * fTemp329);
			double fTemp331 = fTemp330 * (fTemp275 - fRec237[1]) + fRec236[1];
			double fTemp332 = fTemp330 * (fTemp330 + fTemp281 / fTemp329) + 1.0;
			double fTemp333 = fTemp331 / fTemp332;
			fRec236[0] = 2.0 * fTemp333 - fRec236[1];
			fRec237[0] = fRec237[1] + 2.0 * (fTemp330 * fTemp331 / fTemp332);
			double fRec238 = fTemp333;
			double fTemp334 = fTemp240 * (fTemp248 * (fTemp250 * (718.0 * fTemp252 + 979.0 * fTemp253) + fTemp254 * (882.0 * fTemp256 + 1319.0 * fTemp257)) + fTemp258 * (fTemp261 * (718.0 * fTemp263 + 979.0 * fTemp264) + fTemp265 * (882.0 * fTemp267 + 1319.0 * fTemp268)));
			double fTemp335 = std::tan(fConst5 * fTemp334);
			double fTemp336 = fTemp335 * (fTemp275 - fRec240[1]) + fRec239[1];
			double fTemp337 = fTemp335 * (fTemp335 + fTemp281 / fTemp334) + 1.0;
			double fTemp338 = fTemp336 / fTemp337;
			fRec239[0] = 2.0 * fTemp338 - fRec239[1];
			fRec240[0] = fRec240[1] + 2.0 * (fTemp335 * fTemp336 / fTemp337);
			double fRec241 = fTemp338;
			double fTemp339 = fTemp240 * (fTemp248 * (fTemp250 * (653.0 * fTemp252 + 8.8e+02 * fTemp253) + fTemp254 * (785.0 * fTemp256 + 1099.0 * fTemp257)) + fTemp258 * (fTemp261 * (653.0 * fTemp263 + 8.8e+02 * fTemp264) + fTemp265 * (785.0 * fTemp267 + 1099.0 * fTemp268)));
			double fTemp340 = std::tan(fConst5 * fTemp339);
			double fTemp341 = fTemp340 * (fTemp275 - fRec243[1]) + fRec242[1];
			double fTemp342 = fTemp340 * (fTemp340 + fTemp281 / fTemp339) + 1.0;
			double fTemp343 = fTemp341 / fTemp342;
			fRec242[0] = 2.0 * fTemp343 - fRec242[1];
			fRec243[0] = fRec243[1] + 2.0 * (fTemp340 * fTemp341 / fTemp342);
			double fRec244 = fTemp343;
			double fTemp344 = fTemp240 * (fTemp248 * (fTemp250 * (588.0 * fTemp252 + 783.0 * fTemp253) + fTemp254 * (735.0 * fTemp256 + 879.0 * fTemp257)) + fTemp258 * (fTemp261 * (588.0 * fTemp263 + 783.0 * fTemp264) + fTemp265 * (735.0 * fTemp267 + 879.0 * fTemp268)));
			double fTemp345 = std::tan(fConst5 * fTemp344);
			double fTemp346 = fTemp345 * (fTemp275 - fRec246[1]) + fRec245[1];
			double fTemp347 = fTemp345 * (fTemp345 + fTemp281 / fTemp344) + 1.0;
			double fTemp348 = fTemp346 / fTemp347;
			fRec245[0] = 2.0 * fTemp348 - fRec245[1];
			fRec246[0] = fRec246[1] + 2.0 * (fTemp345 * fTemp346 / fTemp347);
			double fRec247 = fTemp348;
			double fTemp349 = fTemp240 * (fTemp248 * (fTemp250 * (522.0 * fTemp252 + 685.0 * fTemp253) + fTemp254 * (588.0 * fTemp256 + 659.0 * fTemp257)) + fTemp258 * (fTemp261 * (522.0 * fTemp263 + 685.0 * fTemp264) + fTemp265 * (588.0 * fTemp267 + 659.0 * fTemp268)));
			double fTemp350 = std::tan(fConst5 * fTemp349);
			double fTemp351 = fTemp350 * (fTemp275 - fRec249[1]) + fRec248[1];
			double fTemp352 = fTemp350 * (fTemp350 + fTemp281 / fTemp349) + 1.0;
			double fTemp353 = fTemp351 / fTemp352;
			fRec248[0] = 2.0 * fTemp353 - fRec248[1];
			fRec249[0] = fRec249[1] + 2.0 * (fTemp350 * fTemp351 / fTemp352);
			double fRec250 = fTemp353;
			double fTemp354 = fTemp240 * (fTemp248 * (fTemp250 * (1567.0 * fTemp252 + 2153.0 * fTemp253) + fTemp254 * (2054.0 * fTemp256 + 3957.0 * fTemp257)) + fTemp258 * (fTemp261 * (1567.0 * fTemp263 + 2153.0 * fTemp264) + fTemp265 * (2054.0 * fTemp267 + 3957.0 * fTemp268)));
			double fTemp355 = std::tan(fConst5 * fTemp354);
			double fTemp356 = fTemp355 * (fTemp275 - fRec252[1]) + fRec251[1];
			double fTemp357 = fTemp355 * (fTemp355 + fTemp281 / fTemp354) + 1.0;
			double fTemp358 = fTemp356 / fTemp357;
			fRec251[0] = 2.0 * fTemp358 - fRec251[1];
			fRec252[0] = fRec252[1] + 2.0 * (fTemp355 * fTemp356 / fTemp357);
			double fRec253 = fTemp358;
			double fTemp359 = fTemp240 * (fTemp248 * (fTemp250 * (1502.0 * fTemp252 + 2056.0 * fTemp253) + fTemp254 * (1.91e+03 * fTemp256 + 3737.0 * fTemp257)) + fTemp258 * (fTemp261 * (1502.0 * fTemp263 + 2056.0 * fTemp264) + fTemp265 * (1.91e+03 * fTemp267 + 3737.0 * fTemp268)));
			double fTemp360 = std::tan(fConst5 * fTemp359);
			double fTemp361 = fTemp360 * (fTemp275 - fRec255[1]) + fRec254[1];
			double fTemp362 = fTemp360 * (fTemp360 + fTemp281 / fTemp359) + 1.0;
			double fTemp363 = fTemp361 / fTemp362;
			fRec254[0] = 2.0 * fTemp363 - fRec254[1];
			fRec255[0] = fRec255[1] + 2.0 * (fTemp360 * fTemp361 / fTemp362);
			double fRec256 = fTemp363;
			double fTemp364 = fTemp240 * (fTemp248 * (fTemp250 * (1371.0 * fTemp252 + 1958.0 * fTemp253) + fTemp254 * (1855.0 * fTemp256 + 3517.0 * fTemp257)) + fTemp258 * (fTemp261 * (1371.0 * fTemp263 + 1958.0 * fTemp264) + fTemp265 * (1855.0 * fTemp267 + 3517.0 * fTemp268)));
			double fTemp365 = std::tan(fConst5 * fTemp364);
			double fTemp366 = fTemp365 * (fTemp275 - fRec258[1]) + fRec257[1];
			double fTemp367 = fTemp365 * (fTemp365 + fTemp281 / fTemp364) + 1.0;
			double fTemp368 = fTemp366 / fTemp367;
			fRec257[0] = 2.0 * fTemp368 - fRec257[1];
			fRec258[0] = fRec258[1] + 2.0 * (fTemp365 * fTemp366 / fTemp367);
			double fRec259 = fTemp368;
			double fTemp369 = fTemp240 * (fTemp248 * (fTemp250 * (1306.0 * fTemp252 + 1.86e+03 * fTemp253) + fTemp254 * (1764.0 * fTemp256 + 3298.0 * fTemp257)) + fTemp258 * (fTemp261 * (1306.0 * fTemp263 + 1.86e+03 * fTemp264) + fTemp265 * (1764.0 * fTemp267 + 3298.0 * fTemp268)));
			double fTemp370 = std::tan(fConst5 * fTemp369);
			double fTemp371 = fTemp370 * (fTemp275 - fRec261[1]) + fRec260[1];
			double fTemp372 = fTemp370 * (fTemp370 + fTemp281 / fTemp369) + 1.0;
			double fTemp373 = fTemp371 / fTemp372;
			fRec260[0] = 2.0 * fTemp373 - fRec260[1];
			fRec261[0] = fRec261[1] + 2.0 * (fTemp370 * fTemp371 / fTemp372);
			double fRec262 = fTemp373;
			double fTemp374 = fTemp240 * (fTemp248 * (fTemp250 * (1241.0 * fTemp252 + 1762.0 * fTemp253) + fTemp254 * (1617.0 * fTemp256 + 3078.0 * fTemp257)) + fTemp258 * (fTemp261 * (1241.0 * fTemp263 + 1762.0 * fTemp264) + fTemp265 * (1617.0 * fTemp267 + 3078.0 * fTemp268)));
			double fTemp375 = std::tan(fConst5 * fTemp374);
			double fTemp376 = fTemp375 * (fTemp275 - fRec264[1]) + fRec263[1];
			double fTemp377 = fTemp375 * (fTemp375 + fTemp281 / fTemp374) + 1.0;
			double fTemp378 = fTemp376 / fTemp377;
			fRec263[0] = 2.0 * fTemp378 - fRec263[1];
			fRec264[0] = fRec264[1] + 2.0 * (fTemp375 * fTemp376 / fTemp377);
			double fRec265 = fTemp378;
			double fTemp379 = fTemp240 * (fTemp248 * (fTemp250 * (1175.0 * fTemp252 + 1664.0 * fTemp253) + fTemp254 * (1.47e+03 * fTemp256 + 2858.0 * fTemp257)) + fTemp258 * (fTemp261 * (1175.0 * fTemp263 + 1664.0 * fTemp264) + fTemp265 * (1.47e+03 * fTemp267 + 2858.0 * fTemp268)));
			double fTemp380 = std::tan(fConst5 * fTemp379);
			double fTemp381 = fTemp380 * (fTemp275 - fRec267[1]) + fRec266[1];
			double fTemp382 = fTemp380 * (fTemp380 + fTemp281 / fTemp379) + 1.0;
			double fTemp383 = fTemp381 / fTemp382;
			fRec266[0] = 2.0 * fTemp383 - fRec266[1];
			fRec267[0] = fRec267[1] + 2.0 * (fTemp380 * fTemp381 / fTemp382);
			double fRec268 = fTemp383;
			double fTemp384 = fTemp240 * (fTemp248 * (fTemp250 * (1.11e+03 * fTemp252 + 1566.0 * fTemp253) + fTemp254 * (1323.0 * fTemp256 + 2638.0 * fTemp257)) + fTemp258 * (fTemp261 * (1.11e+03 * fTemp263 + 1566.0 * fTemp264) + fTemp265 * (1323.0 * fTemp267 + 2638.0 * fTemp268)));
			double fTemp385 = std::tan(fConst5 * fTemp384);
			double fTemp386 = fTemp385 * (fTemp275 - fRec270[1]) + fRec269[1];
			double fTemp387 = fTemp385 * (fTemp385 + fTemp281 / fTemp384) + 1.0;
			double fTemp388 = fTemp386 / fTemp387;
			fRec269[0] = 2.0 * fTemp388 - fRec269[1];
			fRec270[0] = fRec270[1] + 2.0 * (fTemp385 * fTemp386 / fTemp387);
			double fRec271 = fTemp388;
			double fTemp389 = fTemp240 * (fTemp248 * (fTemp250 * (1045.0 * fTemp252 + 1468.0 * fTemp253) + fTemp254 * (1269.0 * fTemp256 + 2418.0 * fTemp257)) + fTemp258 * (fTemp261 * (1045.0 * fTemp263 + 1468.0 * fTemp264) + fTemp265 * (1269.0 * fTemp267 + 2418.0 * fTemp268)));
			double fTemp390 = std::tan(fConst5 * fTemp389);
			double fTemp391 = fTemp390 * (fTemp275 - fRec273[1]) + fRec272[1];
			double fTemp392 = fTemp390 * (fTemp390 + fTemp281 / fTemp389) + 1.0;
			double fTemp393 = fTemp391 / fTemp392;
			fRec272[0] = 2.0 * fTemp393 - fRec272[1];
			fRec273[0] = fRec273[1] + 2.0 * (fTemp390 * fTemp391 / fTemp392);
			double fRec274 = fTemp393;
			double fTemp394 = fTemp240 * (fTemp248 * (fTemp250 * (2024.0 * fTemp252 + 3.23e+03 * fTemp253) + fTemp254 * (3233.0 * fTemp256 + 7255.0 * fTemp257)) + fTemp258 * (fTemp261 * (2024.0 * fTemp263 + 3.23e+03 * fTemp264) + fTemp265 * (3233.0 * fTemp267 + 7255.0 * fTemp268)));
			double fTemp395 = std::tan(fConst5 * fTemp394);
			double fTemp396 = fTemp395 * (fTemp275 - fRec276[1]) + fRec275[1];
			double fTemp397 = fTemp395 * (fTemp395 + fTemp281 / fTemp394) + 1.0;
			double fTemp398 = fTemp396 / fTemp397;
			fRec275[0] = 2.0 * fTemp398 - fRec275[1];
			fRec276[0] = fRec276[1] + 2.0 * (fTemp395 * fTemp396 / fTemp397);
			double fRec277 = fTemp398;
			double fTemp399 = fTemp240 * (fTemp248 * (fTemp250 * (1959.0 * fTemp252 + 2937.0 * fTemp253) + fTemp254 * (2792.0 * fTemp256 + 7035.0 * fTemp257)) + fTemp258 * (fTemp261 * (1959.0 * fTemp263 + 2937.0 * fTemp264) + fTemp265 * (2792.0 * fTemp267 + 7035.0 * fTemp268)));
			double fTemp400 = std::tan(fConst5 * fTemp399);
			double fTemp401 = fTemp400 * (fTemp275 - fRec279[1]) + fRec278[1];
			double fTemp402 = fTemp400 * (fTemp400 + fTemp281 / fTemp399) + 1.0;
			double fTemp403 = fTemp401 / fTemp402;
			fRec278[0] = 2.0 * fTemp403 - fRec278[1];
			fRec279[0] = fRec279[1] + 2.0 * (fTemp400 * fTemp401 / fTemp402);
			double fRec280 = fTemp403;
			double fTemp404 = fTemp240 * (fTemp248 * (fTemp250 * (1894.0 * fTemp252 + 2839.0 * fTemp253) + fTemp254 * (2645.0 * fTemp256 + 5717.0 * fTemp257)) + fTemp258 * (fTemp261 * (1894.0 * fTemp263 + 2839.0 * fTemp264) + fTemp265 * (2645.0 * fTemp267 + 5717.0 * fTemp268)));
			double fTemp405 = std::tan(fConst5 * fTemp404);
			double fTemp406 = fTemp405 * (fTemp275 - fRec282[1]) + fRec281[1];
			double fTemp407 = fTemp405 * (fTemp405 + fTemp281 / fTemp404) + 1.0;
			double fTemp408 = fTemp406 / fTemp407;
			fRec281[0] = 2.0 * fTemp408 - fRec281[1];
			fRec282[0] = fRec282[1] + 2.0 * (fTemp405 * fTemp406 / fTemp407);
			double fRec283 = fTemp408;
			double fTemp409 = fTemp240 * (fTemp248 * (fTemp250 * (1828.0 * fTemp252 + 2741.0 * fTemp253) + fTemp254 * (2498.0 * fTemp256 + 5496.0 * fTemp257)) + fTemp258 * (fTemp261 * (1828.0 * fTemp263 + 2741.0 * fTemp264) + fTemp265 * (2498.0 * fTemp267 + 5496.0 * fTemp268)));
			double fTemp410 = std::tan(fConst5 * fTemp409);
			double fTemp411 = fTemp410 * (fTemp275 - fRec285[1]) + fRec284[1];
			double fTemp412 = fTemp410 * (fTemp410 + fTemp281 / fTemp409) + 1.0;
			double fTemp413 = fTemp411 / fTemp412;
			fRec284[0] = 2.0 * fTemp413 - fRec284[1];
			fRec285[0] = fRec285[1] + 2.0 * (fTemp410 * fTemp411 / fTemp412);
			double fRec286 = fTemp413;
			double fTemp414 = fTemp240 * (fTemp248 * (fTemp250 * (1763.0 * fTemp252 + 2643.0 * fTemp253) + fTemp254 * (2351.0 * fTemp256 + 5056.0 * fTemp257)) + fTemp258 * (fTemp261 * (1763.0 * fTemp263 + 2643.0 * fTemp264) + fTemp265 * (2351.0 * fTemp267 + 5056.0 * fTemp268)));
			double fTemp415 = std::tan(fConst5 * fTemp414);
			double fTemp416 = fTemp415 * (fTemp275 - fRec288[1]) + fRec287[1];
			double fTemp417 = fTemp415 * (fTemp415 + fTemp281 / fTemp414) + 1.0;
			double fTemp418 = fTemp416 / fTemp417;
			fRec287[0] = 2.0 * fTemp418 - fRec287[1];
			fRec288[0] = fRec288[1] + 2.0 * (fTemp415 * fTemp416 / fTemp417);
			double fRec289 = fTemp418;
			double fTemp419 = fTemp240 * (fTemp248 * (fTemp250 * (1698.0 * fTemp252 + 2349.0 * fTemp253) + fTemp254 * (2273.0 * fTemp256 + 4617.0 * fTemp257)) + fTemp258 * (fTemp261 * (1698.0 * fTemp263 + 2349.0 * fTemp264) + fTemp265 * (2273.0 * fTemp267 + 4617.0 * fTemp268)));
			double fTemp420 = std::tan(fConst5 * fTemp419);
			double fTemp421 = fTemp420 * (fTemp275 - fRec291[1]) + fRec290[1];
			double fTemp422 = fTemp420 * (fTemp420 + fTemp281 / fTemp419) + 1.0;
			double fTemp423 = fTemp421 / fTemp422;
			fRec290[0] = 2.0 * fTemp423 - fRec290[1];
			fRec291[0] = fRec291[1] + 2.0 * (fTemp420 * fTemp421 / fTemp422);
			double fRec292 = fTemp423;
			double fTemp424 = fTemp240 * (fTemp248 * (fTemp250 * (1632.0 * fTemp252 + 2252.0 * fTemp253) + fTemp254 * (2204.0 * fTemp256 + 4177.0 * fTemp257)) + fTemp258 * (fTemp261 * (1632.0 * fTemp263 + 2252.0 * fTemp264) + fTemp265 * (2204.0 * fTemp267 + 4177.0 * fTemp268)));
			double fTemp425 = std::tan(fConst5 * fTemp424);
			double fTemp426 = fTemp425 * (fTemp275 - fRec294[1]) + fRec293[1];
			double fTemp427 = fTemp425 * (fTemp425 + fTemp281 / fTemp424) + 1.0;
			double fTemp428 = fTemp426 / fTemp427;
			fRec293[0] = 2.0 * fTemp428 - fRec293[1];
			fRec294[0] = fRec294[1] + 2.0 * (fTemp425 * fTemp426 / fTemp427);
			double fRec295 = fTemp428;
			double fTemp429 = fTemp240 * (fTemp248 * (fTemp250 * (2089.0 * fTemp252 + 3328.0 * fTemp253) + fTemp254 * (3.38e+03 * fTemp256 + 8574.0 * fTemp257)) + fTemp258 * (fTemp261 * (2089.0 * fTemp263 + 3328.0 * fTemp264) + fTemp265 * (3.38e+03 * fTemp267 + 8574.0 * fTemp268)));
			double fTemp430 = std::tan(fConst5 * fTemp429);
			double fTemp431 = fTemp430 * (fTemp275 - fRec297[1]) + fRec296[1];
			double fTemp432 = fTemp430 * (fTemp430 + fTemp281 / fTemp429) + 1.0;
			double fTemp433 = fTemp431 / fTemp432;
			fRec296[0] = 2.0 * fTemp433 - fRec296[1];
			fRec297[0] = fRec297[1] + 2.0 * (fTemp430 * fTemp431 / fTemp432);
			double fRec298 = fTemp433;
			double fTemp434 = fTemp240 * (fTemp248 * (fTemp250 * (2351.0 * fTemp252 + 4013.0 * fTemp253) + fTemp254 * (3527.0 * fTemp256 + 9672.0 * fTemp257)) + fTemp258 * (fTemp261 * (2351.0 * fTemp263 + 4013.0 * fTemp264) + fTemp265 * (3527.0 * fTemp267 + 9672.0 * fTemp268)));
			double fTemp435 = std::tan(fConst5 * fTemp434);
			double fTemp436 = fTemp435 * (fTemp275 - fRec300[1]) + fRec299[1];
			double fTemp437 = fTemp435 * (fTemp435 + fTemp281 / fTemp434) + 1.0;
			double fTemp438 = fTemp436 / fTemp437;
			fRec299[0] = 2.0 * fTemp438 - fRec299[1];
			fRec300[0] = fRec300[1] + 2.0 * (fTemp435 * fTemp436 / fTemp437);
			double fRec301 = fTemp438;
			fRec161[0] = 0.6366197723675814 * std::atan(0.03125 * (fRec183 * (fTemp248 * (fTemp250 * (0.03436227 * fTemp252 + 0.04838698 * fTemp253) + fTemp254 * (0.0250452 * fTemp256 + 0.00707754 * fTemp257)) + fTemp258 * (fTemp261 * (0.03436227 * fTemp263 + 0.04838698 * fTemp264) + fTemp265 * (0.0250452 * fTemp267 + 0.00707754 * fTemp268))) + fRec211 * (fTemp248 * (fTemp250 * (0.01922137 * fTemp252 + 0.00787687 * fTemp253) + fTemp254 * (0.25042786 * fTemp256 + 0.6674602 * fTemp257)) + fTemp258 * (fTemp261 * (0.01922137 * fTemp263 + 0.00787687 * fTemp264) + fTemp265 * (0.25042786 * fTemp267 + 0.6674602 * fTemp268))) + fRec214 * (fTemp248 * (fTemp250 * (0.05522969 * fTemp252 + 0.06051622 * fTemp253) + fTemp254 * (0.02470587 * fTemp256 + 0.01035828 * fTemp257)) + fTemp258 * (fTemp261 * (0.05522969 * fTemp263 + 0.06051622 * fTemp264) + fTemp265 * (0.02470587 * fTemp267 + 0.01035828 * fTemp268))) + fRec217 * (fTemp248 * (fTemp250 * (0.08153769 * fTemp252 + 0.02426847 * fTemp253) + fTemp254 * (0.49828005 * fTemp256 + 0.00749257 * fTemp257)) + fTemp258 * (fTemp261 * (0.08153769 * fTemp263 + 0.02426847 * fTemp264) + fTemp265 * (0.49828005 * fTemp267 + 0.00749257 * fTemp268))) + fRec220 * (fTemp248 * (fTemp250 * (fTemp252 + 0.09843679 * fTemp253) + fTemp254 * (fTemp257 + 0.0405712 * fTemp256)) + fTemp258 * (fTemp261 * (fTemp263 + 0.09843679 * fTemp264) + fTemp265 * (fTemp268 + 0.0405712 * fTemp267))) + fRec223 * (fTemp248 * (fTemp250 * (fTemp253 + 0.27707616 * fTemp252) + fTemp254 * (fTemp256 + 0.01216278 * fTemp257)) + fTemp258 * (fTemp261 * (fTemp264 + 0.27707616 * fTemp263) + fTemp265 * (fTemp267 + 0.01216278 * fTemp268))) + fRec226 * (fTemp248 * (fTemp250 * (0.04196492 * fTemp252 + 0.75217775 * fTemp253) + fTemp254 * (0.07116083 * fTemp256 + 0.01835863 * fTemp257)) + fTemp258 * (fTemp261 * (0.04196492 * fTemp263 + 0.75217775 * fTemp264) + fTemp265 * (0.07116083 * fTemp267 + 0.01835863 * fTemp268))) + fRec229 * (fTemp248 * (fTemp250 * (0.01985851 * fTemp252 + 0.00274825 * fTemp253) + fTemp254 * (0.28175268 * fTemp256 + 0.22375855 * fTemp257)) + fTemp258 * (fTemp261 * (0.01985851 * fTemp263 + 0.00274825 * fTemp264) + fTemp265 * (0.28175268 * fTemp267 + 0.22375855 * fTemp268))) + fRec232 * (fTemp248 * (fTemp250 * (0.03480883 * fTemp252 + 0.02102163 * fTemp253) + fTemp254 * (0.01626654 * fTemp256 + 0.03442368 * fTemp257)) + fTemp258 * (fTemp261 * (0.03480883 * fTemp263 + 0.02102163 * fTemp264) + fTemp265 * (0.01626654 * fTemp267 + 0.03442368 * fTemp268))) + fRec235 * (fTemp248 * (fTemp250 * (0.05834666 * fTemp252 + 0.01772408 * fTemp253) + fTemp254 * (0.14442907 * fTemp256 + 0.07338235 * fTemp257)) + fTemp258 * (fTemp261 * (0.05834666 * fTemp263 + 0.01772408 * fTemp264) + fTemp265 * (0.14442907 * fTemp267 + 0.07338235 * fTemp268))) + fRec238 * (fTemp248 * (fTemp250 * (0.02913938 * fTemp252 + 0.03638926 * fTemp253) + fTemp254 * (0.01228042 * fTemp256 + 0.08982961 * fTemp257)) + fTemp258 * (fTemp261 * (0.02913938 * fTemp263 + 0.03638926 * fTemp264) + fTemp265 * (0.01228042 * fTemp267 + 0.08982961 * fTemp268))) + fRec241 * (fTemp248 * (fTemp250 * (0.0550058 * fTemp252 + 0.02121633 * fTemp253) + fTemp254 * (0.2722688 * fTemp256 + 0.27821024 * fTemp257)) + fTemp258 * (fTemp261 * (0.0550058 * fTemp263 + 0.02121633 * fTemp264) + fTemp265 * (0.2722688 * fTemp267 + 0.27821024 * fTemp268))) + fRec244 * (fTemp248 * (fTemp250 * (0.03381146 * fTemp252 + 0.05363475 * fTemp253) + fTemp254 * (0.01573797 * fTemp256 + 0.64427134 * fTemp257)) + fTemp258 * (fTemp261 * (0.03381146 * fTemp263 + 0.05363475 * fTemp264) + fTemp265 * (0.01573797 * fTemp267 + 0.64427134 * fTemp268))) + fRec247 * (fTemp248 * (fTemp250 * (0.01797695 * fTemp252 + 0.0640251 * fTemp253) + fTemp254 * (0.54357606 * fTemp256 + 0.4053105 * fTemp257)) + fTemp258 * (fTemp261 * (0.01797695 * fTemp263 + 0.0640251 * fTemp264) + fTemp265 * (0.54357606 * fTemp267 + 0.4053105 * fTemp268))) + fRec250 * (fTemp248 * (fTemp250 * (0.03067041 * fTemp252 + 0.05785498 * fTemp253) + fTemp254 * (0.09954785 * fTemp256 + 0.62411215 * fTemp257)) + fTemp258 * (fTemp261 * (0.03067041 * fTemp263 + 0.05785498 * fTemp264) + fTemp265 * (0.09954785 * fTemp267 + 0.62411215 * fTemp268))) + fRec253 * (fTemp248 * (fTemp250 * (0.04640077 * fTemp252 + 0.01305707 * fTemp253) + fTemp254 * (0.06985491 * fTemp256 + 0.01631748 * fTemp257)) + fTemp258 * (fTemp261 * (0.04640077 * fTemp263 + 0.01305707 * fTemp264) + fTemp265 * (0.06985491 * fTemp267 + 0.01631748 * fTemp268))) + fRec256 * (fTemp248 * (fTemp250 * (0.0121161 * fTemp252 + 0.00709897 * fTemp253) + fTemp254 * (0.0343155 * fTemp256 + 0.02601317 * fTemp257)) + fTemp258 * (fTemp261 * (0.0121161 * fTemp263 + 0.00709897 * fTemp264) + fTemp265 * (0.0343155 * fTemp267 + 0.02601317 * fTemp268))) + fRec259 * (fTemp248 * (fTemp250 * (0.01668042 * fTemp252 + 0.01592137 * fTemp253) + fTemp254 * (0.01093969 * fTemp256 + 0.02061391 * fTemp257)) + fTemp258 * (fTemp261 * (0.01668042 * fTemp263 + 0.01592137 * fTemp264) + fTemp265 * (0.01093969 * fTemp267 + 0.02061391 * fTemp268))) + fRec262 * (fTemp248 * (fTemp250 * (0.00848029 * fTemp252 + 0.01670722 * fTemp253) + fTemp254 * (0.05126037 * fTemp256 + 0.03283333 * fTemp257)) + fTemp258 * (fTemp261 * (0.00848029 * fTemp263 + 0.01670722 * fTemp264) + fTemp265 * (0.05126037 * fTemp267 + 0.03283333 * fTemp268))) + fRec265 * (fTemp248 * (fTemp250 * (0.00496045 * fTemp252 + 0.02143791 * fTemp253) + fTemp254 * (0.07354127 * fTemp256 + 0.01222045 * fTemp257)) + fTemp258 * (fTemp261 * (0.00496045 * fTemp263 + 0.02143791 * fTemp264) + fTemp265 * (0.07354127 * fTemp267 + 0.01222045 * fTemp268))) + fRec268 * (fTemp248 * (fTemp250 * (0.00482074 * fTemp252 + 0.01863539 * fTemp253) + fTemp254 * (0.06191843 * fTemp256 + 0.03888326 * fTemp257)) + fTemp258 * (fTemp261 * (0.00482074 * fTemp263 + 0.01863539 * fTemp264) + fTemp265 * (0.06191843 * fTemp267 + 0.03888326 * fTemp268))) + fRec271 * (fTemp248 * (fTemp250 * (0.02735344 * fTemp252 + 0.02193515 * fTemp253) + fTemp254 * (0.07170723 * fTemp256 + 0.04759307 * fTemp257)) + fTemp258 * (fTemp261 * (0.02735344 * fTemp263 + 0.02193515 * fTemp264) + fTemp265 * (0.07170723 * fTemp267 + 0.04759307 * fTemp268))) + fRec274 * (fTemp248 * (fTemp250 * (0.02222397 * fTemp252 + 0.00886369 * fTemp253) + fTemp254 * (0.02115358 * fTemp256 + 0.02409027 * fTemp257)) + fTemp258 * (fTemp261 * (0.02222397 * fTemp263 + 0.00886369 * fTemp264) + fTemp265 * (0.02115358 * fTemp267 + 0.02409027 * fTemp268))) + fRec277 * (fTemp248 * (fTemp250 * (0.01158114 * fTemp252 + 0.00132724 * fTemp253) + fTemp254 * (0.01587526 * fTemp256 + 0.00969712 * fTemp257)) + fTemp258 * (fTemp261 * (0.01158114 * fTemp263 + 0.00132724 * fTemp264) + fTemp265 * (0.01587526 * fTemp267 + 0.00969712 * fTemp268))) + fRec280 * (fTemp248 * (fTemp250 * (0.00592071 * fTemp252 + 0.00126865 * fTemp253) + fTemp254 * (0.03127152 * fTemp256 + 0.02237106 * fTemp257)) + fTemp258 * (fTemp261 * (0.00592071 * fTemp263 + 0.00126865 * fTemp264) + fTemp265 * (0.03127152 * fTemp267 + 0.02237106 * fTemp268))) + fRec283 * (fTemp248 * (fTemp250 * (0.00722225 * fTemp252 + 0.00320751 * fTemp253) + fTemp254 * (0.01055565 * fTemp256 + 0.00841917 * fTemp257)) + fTemp258 * (fTemp261 * (0.00722225 * fTemp263 + 0.00320751 * fTemp264) + fTemp265 * (0.01055565 * fTemp267 + 0.00841917 * fTemp268))) + fRec286 * (fTemp248 * (fTemp250 * (0.01041008 * fTemp252 + 0.00333966 * fTemp253) + fTemp254 * (0.01134687 * fTemp256 + 0.01369543 * fTemp257)) + fTemp258 * (fTemp261 * (0.01041008 * fTemp263 + 0.00333966 * fTemp264) + fTemp265 * (0.01134687 * fTemp267 + 0.01369543 * fTemp268))) + fRec289 * (fTemp248 * (fTemp250 * (0.00722812 * fTemp252 + 0.00161424 * fTemp253) + fTemp254 * (0.01233555 * fTemp256 + 0.01528356 * fTemp257)) + fTemp258 * (fTemp261 * (0.00722812 * fTemp263 + 0.00161424 * fTemp264) + fTemp265 * (0.01233555 * fTemp267 + 0.01528356 * fTemp268))) + fRec292 * (fTemp248 * (fTemp250 * (0.00729633 * fTemp252 + 0.00190274 * fTemp253) + fTemp254 * (0.00656447 * fTemp256 + 0.00854136 * fTemp257)) + fTemp258 * (fTemp261 * (0.00729633 * fTemp263 + 0.00190274 * fTemp264) + fTemp265 * (0.00656447 * fTemp267 + 0.00854136 * fTemp268))) + fRec295 * (fTemp248 * (fTemp250 * (0.02313585 * fTemp252 + 0.00348521 * fTemp253) + fTemp254 * (0.09585942 * fTemp256 + 0.01776269 * fTemp257)) + fTemp258 * (fTemp261 * (0.02313585 * fTemp263 + 0.00348521 * fTemp264) + fTemp265 * (0.09585942 * fTemp267 + 0.01776269 * fTemp268))) + fRec298 * (fTemp248 * (fTemp250 * (0.00443968 * fTemp252 + 0.00152525 * fTemp253) + fTemp254 * (0.00962998 * fTemp256 + 0.00986048 * fTemp257)) + fTemp258 * (fTemp261 * (0.00443968 * fTemp263 + 0.00152525 * fTemp264) + fTemp265 * (0.00962998 * fTemp267 + 0.00986048 * fTemp268))) + fRec301 * (fTemp248 * (fTemp250 * (0.00282064 * fTemp252 + 0.00097757 * fTemp253) + fTemp254 * (0.0068168 * fTemp256 + 0.01255551 * fTemp257)) + fTemp258 * (fTemp261 * (0.00282064 * fTemp263 + 0.00097757 * fTemp264) + fTemp265 * (0.0068168 * fTemp267 + 0.01255551 * fTemp268)))));
			fRec4[0] = fRec161[0];
			fRec308[0] = std::fmod(fRec308[1], fConst0) + std::fabs(0.1 * fRec307[1]) + 0.1;
			int iTemp439 = (fConst1 * fRec308[0]) < (fConst1 * fRec308[1]);
			iVec18[0] = 101;
			iRec309[0] = (101 - iVec18[1]) % -2147483648 + (12345 - 59 * iRec309[1]);
			fRec307[0] = fRec307[1] * double(iVec0[1] - iTemp439) + (0.0 - 4.656612873077393e-10 * double(iRec309[0])) * double(iTemp439 + iTemp1);
			int iTemp440 = fRec307[0] == fRec307[1];
			fRec306[0] = fRec306[1] * double(iTemp440) + 0.125 * fTemp3 * double(1 - iTemp440);
			double fTemp441 = ((fRec306[0] != fRec306[1]) ? fConst4 : fRec304[1] + -1.0);
			fRec304[0] = fTemp441;
			fRec305[0] = ((fTemp441 > 0.0) ? fRec305[1] + (fRec306[0] - fRec305[1]) / fTemp441 : fRec306[0]);
			double fTemp442 = tanh(fRec13[0] + fSlow4 * std::sin(6.283185307179586 * fRec305[0])) + 1.0;
			fVbargraph14 = FAUSTFLOAT(5e+02 * fTemp442);
			fRec315[0] = std::fmod(fRec315[1], fConst0) + std::fabs(0.1 * fRec314[1]) + 0.1;
			int iTemp443 = (fConst1 * fRec315[0]) < (fConst1 * fRec315[1]);
			iVec19[0] = 73;
			iRec316[0] = (73 - iVec19[1]) % -2147483648 + (12345 - 59 * iRec316[1]);
			fRec314[0] = fRec314[1] * double(iVec0[1] - iTemp443) + (0.0 - 4.656612873077393e-10 * double(iRec316[0])) * double(iTemp443 + iTemp1);
			int iTemp444 = fRec314[0] == fRec314[1];
			fRec313[0] = fRec313[1] * double(iTemp444) + 0.125 * fTemp3 * double(1 - iTemp444);
			double fTemp445 = ((fRec313[0] != fRec313[1]) ? fConst4 : fRec311[1] + -1.0);
			fRec311[0] = fTemp445;
			fRec312[0] = ((fTemp445 > 0.0) ? fRec312[1] + (fRec313[0] - fRec312[1]) / fTemp445 : fRec313[0]);
			double fTemp446 = std::pow(5e+02, tanh(fRec21[0] + fSlow4 * std::sin(6.283185307179586 * fRec312[0])));
			fVbargraph15 = FAUSTFLOAT(1e+03 * fTemp446);
			fRec310[0] = fRec310[1] + fConst1 * fTemp446;
			fRec321[0] = std::fmod(fRec321[1], fConst0) + std::fabs(0.1 * fRec320[1]) + 0.1;
			int iTemp447 = (fConst1 * fRec321[0]) < (fConst1 * fRec321[1]);
			iVec20[0] = 97;
			iRec322[0] = (97 - iVec20[1]) % -2147483648 + (12345 - 59 * iRec322[1]);
			fRec320[0] = fRec320[1] * double(iVec0[1] - iTemp447) + (0.0 - 4.656612873077393e-10 * double(iRec322[0])) * double(iTemp447 + iTemp1);
			int iTemp448 = fRec320[0] == fRec320[1];
			fRec319[0] = fRec319[1] * double(iTemp448) + 0.125 * fTemp3 * double(1 - iTemp448);
			double fTemp449 = ((fRec319[0] != fRec319[1]) ? fConst4 : fRec317[1] + -1.0);
			fRec317[0] = fTemp449;
			fRec318[0] = ((fTemp449 > 0.0) ? fRec318[1] + (fRec319[0] - fRec318[1]) / fTemp449 : fRec319[0]);
			double fTemp450 = tanh(fRec28[0] + fSlow4 * std::sin(6.283185307179586 * fRec318[0])) + 1.0;
			fVbargraph16 = FAUSTFLOAT(5e+02 * fTemp450);
			double fTemp451 = (fTemp6 * 0.5 * fTemp442 + 1.0) * fRec302[1] + mydsp_faustpower3_f(fRec303[1]) + std::cos(fRec310[0]) * 0.5 * fTemp450;
			double fTemp452 = 0.0 - fTemp451;
			fVec21[0] = fTemp452;
			fRec302[0] = fTemp452;
			fRec330[0] = std::fmod(fRec330[1], fConst0) + std::fabs(0.1 * fRec329[1]) + 0.1;
			int iTemp453 = (fConst1 * fRec330[0]) < (fConst1 * fRec330[1]);
			iVec22[0] = 79;
			iRec331[0] = (79 - iVec22[1]) % -2147483648 + (12345 - 59 * iRec331[1]);
			fRec329[0] = fRec329[1] * double(iVec0[1] - iTemp453) + (0.0 - 4.656612873077393e-10 * double(iRec331[0])) * double(iTemp453 + iTemp1);
			int iTemp454 = fRec329[0] == fRec329[1];
			fRec328[0] = fRec328[1] * double(iTemp454) + 0.125 * fTemp3 * double(1 - iTemp454);
			double fTemp455 = ((fRec328[0] != fRec328[1]) ? fConst4 : fRec326[1] + -1.0);
			fRec326[0] = fTemp455;
			fRec327[0] = ((fTemp455 > 0.0) ? fRec327[1] + (fRec328[0] - fRec327[1]) / fTemp455 : fRec328[0]);
			double fTemp456 = 0.45 * (tanh(fRec38[0] + fSlow4 * std::sin(6.283185307179586 * fRec327[0])) + 1.0) + 0.1;
			fVbargraph17 = FAUSTFLOAT(1e+03 * fTemp456);
			double fTemp457 = fTemp456;
			fRec336[0] = std::fmod(fRec336[1], fConst0) + std::fabs(0.1 * fRec335[1]) + 0.1;
			int iTemp458 = (fConst1 * fRec336[0]) < (fConst1 * fRec336[1]);
			iVec23[0] = 83;
			iRec337[0] = (83 - iVec23[1]) % -2147483648 + (12345 - 59 * iRec337[1]);
			fRec335[0] = fRec335[1] * double(iVec0[1] - iTemp458) + (0.0 - 4.656612873077393e-10 * double(iRec337[0])) * double(iTemp458 + iTemp1);
			int iTemp459 = fRec335[0] == fRec335[1];
			fRec334[0] = fRec334[1] * double(iTemp459) + 0.125 * fTemp3 * double(1 - iTemp459);
			double fTemp460 = ((fRec334[0] != fRec334[1]) ? fConst4 : fRec332[1] + -1.0);
			fRec332[0] = fTemp460;
			fRec333[0] = ((fTemp460 > 0.0) ? fRec333[1] + (fRec334[0] - fRec333[1]) / fTemp460 : fRec334[0]);
			double fTemp461 = tanh(fRec45[0] + fSlow4 * std::sin(6.283185307179586 * fRec333[0])) + 1.0;
			fVbargraph18 = FAUSTFLOAT(5e+02 * fTemp461);
			double fTemp462 = 4.0 * 0.5 * fTemp461;
			int iTemp463 = int(fTemp462);
			double fTemp464 = double(iTemp463);
			double fTemp465 = fTemp464 + (1.0 - fTemp462);
			int iTemp466 = iTemp463 >= 2;
			double fTemp467 = double(1 - iTemp466);
			int iTemp468 = iTemp463 >= 1;
			double fTemp469 = double(1 - iTemp468);
			double fTemp470 = double(iTemp468);
			double fTemp471 = double(iTemp466);
			int iTemp472 = iTemp463 >= 3;
			double fTemp473 = double(1 - iTemp472);
			double fTemp474 = double(iTemp472);
			double fTemp475 = fTemp462 - fTemp464;
			int iTemp476 = iTemp463 + 1;
			int iTemp477 = iTemp476 >= 2;
			double fTemp478 = double(1 - iTemp477);
			int iTemp479 = iTemp476 >= 1;
			double fTemp480 = double(1 - iTemp479);
			double fTemp481 = double(iTemp479);
			double fTemp482 = double(iTemp477);
			int iTemp483 = iTemp476 >= 3;
			double fTemp484 = double(1 - iTemp483);
			double fTemp485 = double(iTemp483);
			double fTemp486 = fTemp457 * (fTemp465 * (fTemp467 * (588.0 * fTemp469 + 783.0 * fTemp470) + fTemp471 * (735.0 * fTemp473 + 879.0 * fTemp474)) + fTemp475 * (fTemp478 * (588.0 * fTemp480 + 783.0 * fTemp481) + fTemp482 * (735.0 * fTemp484 + 879.0 * fTemp485)));
			double fTemp487 = std::tan(fConst5 * fTemp486);
			fRec338[0] = 0.995 * fRec338[1] - (fTemp451 + fVec21[1]);
			fRec343[0] = std::fmod(fRec343[1], fConst0) + std::fabs(0.1 * fRec342[1]) + 0.1;
			int iTemp488 = (fConst1 * fRec343[0]) < (fConst1 * fRec343[1]);
			iVec24[0] = 103;
			iRec344[0] = (103 - iVec24[1]) % -2147483648 + (12345 - 59 * iRec344[1]);
			fRec342[0] = fRec342[1] * double(iVec0[1] - iTemp488) + (0.0 - 4.656612873077393e-10 * double(iRec344[0])) * double(iTemp488 + iTemp1);
			int iTemp489 = fRec342[0] == fRec342[1];
			fRec341[0] = fRec341[1] * double(iTemp489) + 0.125 * fTemp3 * double(1 - iTemp489);
			double fTemp490 = ((fRec341[0] != fRec341[1]) ? fConst4 : fRec339[1] + -1.0);
			fRec339[0] = fTemp490;
			fRec340[0] = ((fTemp490 > 0.0) ? fRec340[1] + (fRec341[0] - fRec340[1]) / fTemp490 : fRec341[0]);
			double fTemp491 = std::pow(1e+03, tanh(fRec53[0] + fSlow4 * std::sin(6.283185307179586 * fRec340[0])));
			fVbargraph19 = FAUSTFLOAT(fTemp491);
			double fTemp492 = fRec338[0] * fTemp491;
			double fTemp493 = fTemp487 * (fTemp492 - fRec324[1]) + fRec323[1];
			fRec349[0] = std::fmod(fRec349[1], fConst0) + std::fabs(0.1 * fRec348[1]) + 0.1;
			int iTemp494 = (fConst1 * fRec349[0]) < (fConst1 * fRec349[1]);
			iVec25[0] = 89;
			iRec350[0] = (89 - iVec25[1]) % -2147483648 + (12345 - 59 * iRec350[1]);
			fRec348[0] = fRec348[1] * double(iVec0[1] - iTemp494) + (0.0 - 4.656612873077393e-10 * double(iRec350[0])) * double(iTemp494 + iTemp1);
			int iTemp495 = fRec348[0] == fRec348[1];
			fRec347[0] = fRec347[1] * double(iTemp495) + 0.125 * fTemp3 * double(1 - iTemp495);
			double fTemp496 = ((fRec347[0] != fRec347[1]) ? fConst4 : fRec345[1] + -1.0);
			fRec345[0] = fTemp496;
			fRec346[0] = ((fTemp496 > 0.0) ? fRec346[1] + (fRec347[0] - fRec346[1]) / fTemp496 : fRec347[0]);
			double fTemp497 = std::pow(1e+02, tanh(fRec60[0] + fSlow4 * std::sin(6.283185307179586 * fRec346[0])));
			fVbargraph20 = FAUSTFLOAT(fTemp497);
			double fTemp498 = std::max<double>(2.220446049250313e-16, fTemp497);
			double fTemp499 = fTemp487 * (fTemp487 + fTemp498 / fTemp486) + 1.0;
			double fTemp500 = fTemp493 / fTemp499;
			fRec323[0] = 2.0 * fTemp500 - fRec323[1];
			fRec324[0] = fRec324[1] + 2.0 * (fTemp487 * fTemp493 / fTemp499);
			double fRec325 = fTemp500;
			double fTemp501 = fTemp457 * (fTemp465 * (fTemp467 * (522.0 * fTemp469 + 685.0 * fTemp470) + fTemp471 * (588.0 * fTemp473 + 659.0 * fTemp474)) + fTemp475 * (fTemp478 * (522.0 * fTemp480 + 685.0 * fTemp481) + fTemp482 * (588.0 * fTemp484 + 659.0 * fTemp485)));
			double fTemp502 = std::tan(fConst5 * fTemp501);
			double fTemp503 = fTemp502 * (fTemp492 - fRec352[1]) + fRec351[1];
			double fTemp504 = fTemp502 * (fTemp502 + fTemp498 / fTemp501) + 1.0;
			double fTemp505 = fTemp503 / fTemp504;
			fRec351[0] = 2.0 * fTemp505 - fRec351[1];
			fRec352[0] = fRec352[1] + 2.0 * (fTemp502 * fTemp503 / fTemp504);
			double fRec353 = fTemp505;
			double fTemp506 = fTemp457 * (fTemp465 * (fTemp467 * (457.0 * fTemp469 + 587.0 * fTemp470) + fTemp471 * (534.0 * fTemp473 + 538.0 * fTemp474)) + fTemp475 * (fTemp478 * (457.0 * fTemp480 + 587.0 * fTemp481) + fTemp482 * (534.0 * fTemp484 + 538.0 * fTemp485)));
			double fTemp507 = std::tan(fConst5 * fTemp506);
			double fTemp508 = fTemp507 * (fTemp492 - fRec355[1]) + fRec354[1];
			double fTemp509 = fTemp507 * (fTemp507 + fTemp498 / fTemp506) + 1.0;
			double fTemp510 = fTemp508 / fTemp509;
			fRec354[0] = 2.0 * fTemp510 - fRec354[1];
			fRec355[0] = fRec355[1] + 2.0 * (fTemp507 * fTemp508 / fTemp509);
			double fRec356 = fTemp510;
			double fTemp511 = fTemp457 * (fTemp465 * (fTemp467 * (392.0 * fTemp469 + 537.0 * fTemp470) + fTemp471 * (441.0 * fTemp473 + 439.0 * fTemp474)) + fTemp475 * (fTemp478 * (392.0 * fTemp480 + 537.0 * fTemp481) + fTemp482 * (441.0 * fTemp484 + 439.0 * fTemp485)));
			double fTemp512 = std::tan(fConst5 * fTemp511);
			double fTemp513 = fTemp512 * (fTemp492 - fRec358[1]) + fRec357[1];
			double fTemp514 = fTemp512 * (fTemp512 + fTemp498 / fTemp511) + 1.0;
			double fTemp515 = fTemp513 / fTemp514;
			fRec357[0] = 2.0 * fTemp515 - fRec357[1];
			fRec358[0] = fRec358[1] + 2.0 * (fTemp512 * fTemp513 / fTemp514);
			double fRec359 = fTemp515;
			double fTemp516 = fTemp457 * (fTemp465 * (fTemp467 * (326.0 * fTemp469 + 489.0 * fTemp470) + fTemp471 * (367.0 * fTemp473 + 368.0 * fTemp474)) + fTemp475 * (fTemp478 * (326.0 * fTemp480 + 489.0 * fTemp481) + fTemp482 * (367.0 * fTemp484 + 368.0 * fTemp485)));
			double fTemp517 = std::tan(fConst5 * fTemp516);
			double fTemp518 = fTemp517 * (fTemp492 - fRec361[1]) + fRec360[1];
			double fTemp519 = fTemp517 * (fTemp517 + fTemp498 / fTemp516) + 1.0;
			double fTemp520 = fTemp518 / fTemp519;
			fRec360[0] = 2.0 * fTemp520 - fRec360[1];
			fRec361[0] = fRec361[1] + 2.0 * (fTemp517 * fTemp518 / fTemp519);
			double fRec362 = fTemp520;
			double fTemp521 = fTemp457 * (fTemp465 * (fTemp467 * (261.0 * fTemp469 + 391.0 * fTemp470) + fTemp471 * (294.0 * fTemp473 + 309.0 * fTemp474)) + fTemp475 * (fTemp478 * (261.0 * fTemp480 + 391.0 * fTemp481) + fTemp482 * (294.0 * fTemp484 + 309.0 * fTemp485)));
			double fTemp522 = std::tan(fConst5 * fTemp521);
			double fTemp523 = fTemp522 * (fTemp492 - fRec364[1]) + fRec363[1];
			double fTemp524 = fTemp522 * (fTemp522 + fTemp498 / fTemp521) + 1.0;
			double fTemp525 = fTemp523 / fTemp524;
			fRec363[0] = 2.0 * fTemp525 - fRec363[1];
			fRec364[0] = fRec364[1] + 2.0 * (fTemp522 * fTemp523 / fTemp524);
			double fRec365 = fTemp525;
			double fTemp526 = fTemp457 * (fTemp465 * (fTemp467 * (196.0 * fTemp469 + 293.0 * fTemp470) + fTemp471 * (203.0 * fTemp473 + 2.2e+02 * fTemp474)) + fTemp475 * (fTemp478 * (196.0 * fTemp480 + 293.0 * fTemp481) + fTemp482 * (203.0 * fTemp484 + 2.2e+02 * fTemp485)));
			double fTemp527 = std::tan(fConst5 * fTemp526);
			double fTemp528 = fTemp527 * (fTemp492 - fRec367[1]) + fRec366[1];
			double fTemp529 = fTemp527 * (fTemp527 + fTemp498 / fTemp526) + 1.0;
			double fTemp530 = fTemp528 / fTemp529;
			fRec366[0] = 2.0 * fTemp530 - fRec366[1];
			fRec367[0] = fRec367[1] + 2.0 * (fTemp527 * fTemp528 / fTemp529);
			double fRec368 = fTemp530;
			double fTemp531 = fTemp457 * (fTemp465 * (fTemp467 * (131.0 * fTemp469 + 195.0 * fTemp470) + fTemp471 * (147.0 * fTemp473 + 1.3e+02 * fTemp474)) + fTemp475 * (fTemp478 * (131.0 * fTemp480 + 195.0 * fTemp481) + fTemp482 * (147.0 * fTemp484 + 1.3e+02 * fTemp485)));
			double fTemp532 = std::tan(fConst5 * fTemp531);
			double fTemp533 = fTemp532 * (fTemp492 - fRec370[1]) + fRec369[1];
			double fTemp534 = fTemp532 * (fTemp532 + fTemp498 / fTemp531) + 1.0;
			double fTemp535 = fTemp533 / fTemp534;
			fRec369[0] = 2.0 * fTemp535 - fRec369[1];
			fRec370[0] = fRec370[1] + 2.0 * (fTemp532 * fTemp533 / fTemp534);
			double fRec371 = fTemp535;
			double fTemp536 = (fTemp465 * ((65.0 * fTemp469 + 98.0 * fTemp470) * fTemp467 + (53.0 * fTemp473 + 5e+01 * fTemp474) * fTemp471) + fTemp475 * ((65.0 * fTemp480 + 98.0 * fTemp481) * fTemp478 + (53.0 * fTemp484 + 5e+01 * fTemp485) * fTemp482)) * fTemp457;
			double fTemp537 = std::tan(fConst5 * fTemp536);
			double fTemp538 = fTemp537 * (fTemp492 - fRec373[1]) + fRec372[1];
			double fTemp539 = fTemp537 * (fTemp537 + fTemp498 / fTemp536) + 1.0;
			double fTemp540 = fTemp538 / fTemp539;
			fRec372[0] = 2.0 * fTemp540 - fRec372[1];
			fRec373[0] = fRec373[1] + 2.0 * (fTemp537 * fTemp538 / fTemp539);
			double fRec374 = fTemp540;
			double fTemp541 = fTemp457 * (fTemp465 * (fTemp467 * (1175.0 * fTemp469 + 1664.0 * fTemp470) + fTemp471 * (1.47e+03 * fTemp473 + 2858.0 * fTemp474)) + fTemp475 * (fTemp478 * (1175.0 * fTemp480 + 1664.0 * fTemp481) + fTemp482 * (1.47e+03 * fTemp484 + 2858.0 * fTemp485)));
			double fTemp542 = std::tan(fConst5 * fTemp541);
			double fTemp543 = fTemp542 * (fTemp492 - fRec376[1]) + fRec375[1];
			double fTemp544 = fTemp542 * (fTemp542 + fTemp498 / fTemp541) + 1.0;
			double fTemp545 = fTemp543 / fTemp544;
			fRec375[0] = 2.0 * fTemp545 - fRec375[1];
			fRec376[0] = fRec376[1] + 2.0 * (fTemp542 * fTemp543 / fTemp544);
			double fRec377 = fTemp545;
			double fTemp546 = fTemp457 * (fTemp465 * (fTemp467 * (1.11e+03 * fTemp469 + 1566.0 * fTemp470) + fTemp471 * (1323.0 * fTemp473 + 2638.0 * fTemp474)) + fTemp475 * (fTemp478 * (1.11e+03 * fTemp480 + 1566.0 * fTemp481) + fTemp482 * (1323.0 * fTemp484 + 2638.0 * fTemp485)));
			double fTemp547 = std::tan(fConst5 * fTemp546);
			double fTemp548 = fTemp547 * (fTemp492 - fRec379[1]) + fRec378[1];
			double fTemp549 = fTemp547 * (fTemp547 + fTemp498 / fTemp546) + 1.0;
			double fTemp550 = fTemp548 / fTemp549;
			fRec378[0] = 2.0 * fTemp550 - fRec378[1];
			fRec379[0] = fRec379[1] + 2.0 * (fTemp547 * fTemp548 / fTemp549);
			double fRec380 = fTemp550;
			double fTemp551 = fTemp457 * (fTemp465 * (fTemp467 * (1045.0 * fTemp469 + 1468.0 * fTemp470) + fTemp471 * (1269.0 * fTemp473 + 2418.0 * fTemp474)) + fTemp475 * (fTemp478 * (1045.0 * fTemp480 + 1468.0 * fTemp481) + fTemp482 * (1269.0 * fTemp484 + 2418.0 * fTemp485)));
			double fTemp552 = std::tan(fConst5 * fTemp551);
			double fTemp553 = fTemp552 * (fTemp492 - fRec382[1]) + fRec381[1];
			double fTemp554 = fTemp552 * (fTemp552 + fTemp498 / fTemp551) + 1.0;
			double fTemp555 = fTemp553 / fTemp554;
			fRec381[0] = 2.0 * fTemp555 - fRec381[1];
			fRec382[0] = fRec382[1] + 2.0 * (fTemp552 * fTemp553 / fTemp554);
			double fRec383 = fTemp555;
			double fTemp556 = fTemp457 * (fTemp465 * (fTemp467 * (979.0 * fTemp469 + 1371.0 * fTemp470) + fTemp471 * (1175.0 * fTemp473 + 2198.0 * fTemp474)) + fTemp475 * (fTemp478 * (979.0 * fTemp480 + 1371.0 * fTemp481) + fTemp482 * (1175.0 * fTemp484 + 2198.0 * fTemp485)));
			double fTemp557 = std::tan(fConst5 * fTemp556);
			double fTemp558 = fTemp557 * (fTemp492 - fRec385[1]) + fRec384[1];
			double fTemp559 = fTemp557 * (fTemp557 + fTemp498 / fTemp556) + 1.0;
			double fTemp560 = fTemp558 / fTemp559;
			fRec384[0] = 2.0 * fTemp560 - fRec384[1];
			fRec385[0] = fRec385[1] + 2.0 * (fTemp557 * fTemp558 / fTemp559);
			double fRec386 = fTemp560;
			double fTemp561 = fTemp457 * (fTemp465 * (fTemp467 * (914.0 * fTemp469 + 1272.0 * fTemp470) + fTemp471 * (1078.0 * fTemp473 + 1978.0 * fTemp474)) + fTemp475 * (fTemp478 * (914.0 * fTemp480 + 1272.0 * fTemp481) + fTemp482 * (1078.0 * fTemp484 + 1978.0 * fTemp485)));
			double fTemp562 = std::tan(fConst5 * fTemp561);
			double fTemp563 = fTemp562 * (fTemp492 - fRec388[1]) + fRec387[1];
			double fTemp564 = fTemp562 * (fTemp562 + fTemp498 / fTemp561) + 1.0;
			double fTemp565 = fTemp563 / fTemp564;
			fRec387[0] = 2.0 * fTemp565 - fRec387[1];
			fRec388[0] = fRec388[1] + 2.0 * (fTemp562 * fTemp563 / fTemp564);
			double fRec389 = fTemp565;
			double fTemp566 = fTemp457 * (fTemp465 * (fTemp467 * (849.0 * fTemp469 + 1174.0 * fTemp470) + fTemp471 * (1028.0 * fTemp473 + 1759.0 * fTemp474)) + fTemp475 * (fTemp478 * (849.0 * fTemp480 + 1174.0 * fTemp481) + fTemp482 * (1028.0 * fTemp484 + 1759.0 * fTemp485)));
			double fTemp567 = std::tan(fConst5 * fTemp566);
			double fTemp568 = fTemp567 * (fTemp492 - fRec391[1]) + fRec390[1];
			double fTemp569 = fTemp567 * (fTemp567 + fTemp498 / fTemp566) + 1.0;
			double fTemp570 = fTemp568 / fTemp569;
			fRec390[0] = 2.0 * fTemp570 - fRec390[1];
			fRec391[0] = fRec391[1] + 2.0 * (fTemp567 * fTemp568 / fTemp569);
			double fRec392 = fTemp570;
			double fTemp571 = fTemp457 * (fTemp465 * (fTemp467 * (784.0 * fTemp469 + 1076.0 * fTemp470) + fTemp471 * (961.0 * fTemp473 + 1539.0 * fTemp474)) + fTemp475 * (fTemp478 * (784.0 * fTemp480 + 1076.0 * fTemp481) + fTemp482 * (961.0 * fTemp484 + 1539.0 * fTemp485)));
			double fTemp572 = std::tan(fConst5 * fTemp571);
			double fTemp573 = fTemp572 * (fTemp492 - fRec394[1]) + fRec393[1];
			double fTemp574 = fTemp572 * (fTemp572 + fTemp498 / fTemp571) + 1.0;
			double fTemp575 = fTemp573 / fTemp574;
			fRec393[0] = 2.0 * fTemp575 - fRec393[1];
			fRec394[0] = fRec394[1] + 2.0 * (fTemp572 * fTemp573 / fTemp574);
			double fRec395 = fTemp575;
			double fTemp576 = fTemp457 * (fTemp465 * (fTemp467 * (718.0 * fTemp469 + 979.0 * fTemp470) + fTemp471 * (882.0 * fTemp473 + 1319.0 * fTemp474)) + fTemp475 * (fTemp478 * (718.0 * fTemp480 + 979.0 * fTemp481) + fTemp482 * (882.0 * fTemp484 + 1319.0 * fTemp485)));
			double fTemp577 = std::tan(fConst5 * fTemp576);
			double fTemp578 = fTemp577 * (fTemp492 - fRec397[1]) + fRec396[1];
			double fTemp579 = fTemp577 * (fTemp577 + fTemp498 / fTemp576) + 1.0;
			double fTemp580 = fTemp578 / fTemp579;
			fRec396[0] = 2.0 * fTemp580 - fRec396[1];
			fRec397[0] = fRec397[1] + 2.0 * (fTemp577 * fTemp578 / fTemp579);
			double fRec398 = fTemp580;
			double fTemp581 = fTemp457 * (fTemp465 * (fTemp467 * (653.0 * fTemp469 + 8.8e+02 * fTemp470) + fTemp471 * (785.0 * fTemp473 + 1099.0 * fTemp474)) + fTemp475 * (fTemp478 * (653.0 * fTemp480 + 8.8e+02 * fTemp481) + fTemp482 * (785.0 * fTemp484 + 1099.0 * fTemp485)));
			double fTemp582 = std::tan(fConst5 * fTemp581);
			double fTemp583 = fTemp582 * (fTemp492 - fRec400[1]) + fRec399[1];
			double fTemp584 = fTemp582 * (fTemp582 + fTemp498 / fTemp581) + 1.0;
			double fTemp585 = fTemp583 / fTemp584;
			fRec399[0] = 2.0 * fTemp585 - fRec399[1];
			fRec400[0] = fRec400[1] + 2.0 * (fTemp582 * fTemp583 / fTemp584);
			double fRec401 = fTemp585;
			double fTemp586 = fTemp457 * (fTemp465 * (fTemp467 * (1698.0 * fTemp469 + 2349.0 * fTemp470) + fTemp471 * (2273.0 * fTemp473 + 4617.0 * fTemp474)) + fTemp475 * (fTemp478 * (1698.0 * fTemp480 + 2349.0 * fTemp481) + fTemp482 * (2273.0 * fTemp484 + 4617.0 * fTemp485)));
			double fTemp587 = std::tan(fConst5 * fTemp586);
			double fTemp588 = fTemp587 * (fTemp492 - fRec403[1]) + fRec402[1];
			double fTemp589 = fTemp587 * (fTemp587 + fTemp498 / fTemp586) + 1.0;
			double fTemp590 = fTemp588 / fTemp589;
			fRec402[0] = 2.0 * fTemp590 - fRec402[1];
			fRec403[0] = fRec403[1] + 2.0 * (fTemp587 * fTemp588 / fTemp589);
			double fRec404 = fTemp590;
			double fTemp591 = fTemp457 * (fTemp465 * (fTemp467 * (1632.0 * fTemp469 + 2252.0 * fTemp470) + fTemp471 * (2204.0 * fTemp473 + 4177.0 * fTemp474)) + fTemp475 * (fTemp478 * (1632.0 * fTemp480 + 2252.0 * fTemp481) + fTemp482 * (2204.0 * fTemp484 + 4177.0 * fTemp485)));
			double fTemp592 = std::tan(fConst5 * fTemp591);
			double fTemp593 = fTemp592 * (fTemp492 - fRec406[1]) + fRec405[1];
			double fTemp594 = fTemp592 * (fTemp592 + fTemp498 / fTemp591) + 1.0;
			double fTemp595 = fTemp593 / fTemp594;
			fRec405[0] = 2.0 * fTemp595 - fRec405[1];
			fRec406[0] = fRec406[1] + 2.0 * (fTemp592 * fTemp593 / fTemp594);
			double fRec407 = fTemp595;
			double fTemp596 = fTemp457 * (fTemp465 * (fTemp467 * (1567.0 * fTemp469 + 2153.0 * fTemp470) + fTemp471 * (2054.0 * fTemp473 + 3957.0 * fTemp474)) + fTemp475 * (fTemp478 * (1567.0 * fTemp480 + 2153.0 * fTemp481) + fTemp482 * (2054.0 * fTemp484 + 3957.0 * fTemp485)));
			double fTemp597 = std::tan(fConst5 * fTemp596);
			double fTemp598 = fTemp597 * (fTemp492 - fRec409[1]) + fRec408[1];
			double fTemp599 = fTemp597 * (fTemp597 + fTemp498 / fTemp596) + 1.0;
			double fTemp600 = fTemp598 / fTemp599;
			fRec408[0] = 2.0 * fTemp600 - fRec408[1];
			fRec409[0] = fRec409[1] + 2.0 * (fTemp597 * fTemp598 / fTemp599);
			double fRec410 = fTemp600;
			double fTemp601 = fTemp457 * (fTemp465 * (fTemp467 * (1502.0 * fTemp469 + 2056.0 * fTemp470) + fTemp471 * (1.91e+03 * fTemp473 + 3737.0 * fTemp474)) + fTemp475 * (fTemp478 * (1502.0 * fTemp480 + 2056.0 * fTemp481) + fTemp482 * (1.91e+03 * fTemp484 + 3737.0 * fTemp485)));
			double fTemp602 = std::tan(fConst5 * fTemp601);
			double fTemp603 = fTemp602 * (fTemp492 - fRec412[1]) + fRec411[1];
			double fTemp604 = fTemp602 * (fTemp602 + fTemp498 / fTemp601) + 1.0;
			double fTemp605 = fTemp603 / fTemp604;
			fRec411[0] = 2.0 * fTemp605 - fRec411[1];
			fRec412[0] = fRec412[1] + 2.0 * (fTemp602 * fTemp603 / fTemp604);
			double fRec413 = fTemp605;
			double fTemp606 = fTemp457 * (fTemp465 * (fTemp467 * (1371.0 * fTemp469 + 1958.0 * fTemp470) + fTemp471 * (1855.0 * fTemp473 + 3517.0 * fTemp474)) + fTemp475 * (fTemp478 * (1371.0 * fTemp480 + 1958.0 * fTemp481) + fTemp482 * (1855.0 * fTemp484 + 3517.0 * fTemp485)));
			double fTemp607 = std::tan(fConst5 * fTemp606);
			double fTemp608 = fTemp607 * (fTemp492 - fRec415[1]) + fRec414[1];
			double fTemp609 = fTemp607 * (fTemp607 + fTemp498 / fTemp606) + 1.0;
			double fTemp610 = fTemp608 / fTemp609;
			fRec414[0] = 2.0 * fTemp610 - fRec414[1];
			fRec415[0] = fRec415[1] + 2.0 * (fTemp607 * fTemp608 / fTemp609);
			double fRec416 = fTemp610;
			double fTemp611 = fTemp457 * (fTemp465 * (fTemp467 * (1306.0 * fTemp469 + 1.86e+03 * fTemp470) + fTemp471 * (1764.0 * fTemp473 + 3298.0 * fTemp474)) + fTemp475 * (fTemp478 * (1306.0 * fTemp480 + 1.86e+03 * fTemp481) + fTemp482 * (1764.0 * fTemp484 + 3298.0 * fTemp485)));
			double fTemp612 = std::tan(fConst5 * fTemp611);
			double fTemp613 = fTemp612 * (fTemp492 - fRec418[1]) + fRec417[1];
			double fTemp614 = fTemp612 * (fTemp612 + fTemp498 / fTemp611) + 1.0;
			double fTemp615 = fTemp613 / fTemp614;
			fRec417[0] = 2.0 * fTemp615 - fRec417[1];
			fRec418[0] = fRec418[1] + 2.0 * (fTemp612 * fTemp613 / fTemp614);
			double fRec419 = fTemp615;
			double fTemp616 = fTemp457 * (fTemp465 * (fTemp467 * (1241.0 * fTemp469 + 1762.0 * fTemp470) + fTemp471 * (1617.0 * fTemp473 + 3078.0 * fTemp474)) + fTemp475 * (fTemp478 * (1241.0 * fTemp480 + 1762.0 * fTemp481) + fTemp482 * (1617.0 * fTemp484 + 3078.0 * fTemp485)));
			double fTemp617 = std::tan(fConst5 * fTemp616);
			double fTemp618 = fTemp617 * (fTemp492 - fRec421[1]) + fRec420[1];
			double fTemp619 = fTemp617 * (fTemp617 + fTemp498 / fTemp616) + 1.0;
			double fTemp620 = fTemp618 / fTemp619;
			fRec420[0] = 2.0 * fTemp620 - fRec420[1];
			fRec421[0] = fRec421[1] + 2.0 * (fTemp617 * fTemp618 / fTemp619);
			double fRec422 = fTemp620;
			double fTemp621 = fTemp457 * (fTemp465 * (fTemp467 * (1763.0 * fTemp469 + 2643.0 * fTemp470) + fTemp471 * (2351.0 * fTemp473 + 5056.0 * fTemp474)) + fTemp475 * (fTemp478 * (1763.0 * fTemp480 + 2643.0 * fTemp481) + fTemp482 * (2351.0 * fTemp484 + 5056.0 * fTemp485)));
			double fTemp622 = std::tan(fConst5 * fTemp621);
			double fTemp623 = fTemp622 * (fTemp492 - fRec424[1]) + fRec423[1];
			double fTemp624 = fTemp622 * (fTemp622 + fTemp498 / fTemp621) + 1.0;
			double fTemp625 = fTemp623 / fTemp624;
			fRec423[0] = 2.0 * fTemp625 - fRec423[1];
			fRec424[0] = fRec424[1] + 2.0 * (fTemp622 * fTemp623 / fTemp624);
			double fRec425 = fTemp625;
			double fTemp626 = fTemp457 * (fTemp465 * (fTemp467 * (1828.0 * fTemp469 + 2741.0 * fTemp470) + fTemp471 * (2498.0 * fTemp473 + 5496.0 * fTemp474)) + fTemp475 * (fTemp478 * (1828.0 * fTemp480 + 2741.0 * fTemp481) + fTemp482 * (2498.0 * fTemp484 + 5496.0 * fTemp485)));
			double fTemp627 = std::tan(fConst5 * fTemp626);
			double fTemp628 = fTemp627 * (fTemp492 - fRec427[1]) + fRec426[1];
			double fTemp629 = fTemp627 * (fTemp627 + fTemp498 / fTemp626) + 1.0;
			double fTemp630 = fTemp628 / fTemp629;
			fRec426[0] = 2.0 * fTemp630 - fRec426[1];
			fRec427[0] = fRec427[1] + 2.0 * (fTemp627 * fTemp628 / fTemp629);
			double fRec428 = fTemp630;
			double fTemp631 = fTemp457 * (fTemp465 * (fTemp467 * (1894.0 * fTemp469 + 2839.0 * fTemp470) + fTemp471 * (2645.0 * fTemp473 + 5717.0 * fTemp474)) + fTemp475 * (fTemp478 * (1894.0 * fTemp480 + 2839.0 * fTemp481) + fTemp482 * (2645.0 * fTemp484 + 5717.0 * fTemp485)));
			double fTemp632 = std::tan(fConst5 * fTemp631);
			double fTemp633 = fTemp632 * (fTemp492 - fRec430[1]) + fRec429[1];
			double fTemp634 = fTemp632 * (fTemp632 + fTemp498 / fTemp631) + 1.0;
			double fTemp635 = fTemp633 / fTemp634;
			fRec429[0] = 2.0 * fTemp635 - fRec429[1];
			fRec430[0] = fRec430[1] + 2.0 * (fTemp632 * fTemp633 / fTemp634);
			double fRec431 = fTemp635;
			double fTemp636 = fTemp457 * (fTemp465 * (fTemp467 * (1959.0 * fTemp469 + 2937.0 * fTemp470) + fTemp471 * (2792.0 * fTemp473 + 7035.0 * fTemp474)) + fTemp475 * (fTemp478 * (1959.0 * fTemp480 + 2937.0 * fTemp481) + fTemp482 * (2792.0 * fTemp484 + 7035.0 * fTemp485)));
			double fTemp637 = std::tan(fConst5 * fTemp636);
			double fTemp638 = fTemp637 * (fTemp492 - fRec433[1]) + fRec432[1];
			double fTemp639 = fTemp637 * (fTemp637 + fTemp498 / fTemp636) + 1.0;
			double fTemp640 = fTemp638 / fTemp639;
			fRec432[0] = 2.0 * fTemp640 - fRec432[1];
			fRec433[0] = fRec433[1] + 2.0 * (fTemp637 * fTemp638 / fTemp639);
			double fRec434 = fTemp640;
			double fTemp641 = fTemp457 * (fTemp465 * (fTemp467 * (2024.0 * fTemp469 + 3.23e+03 * fTemp470) + fTemp471 * (3233.0 * fTemp473 + 7255.0 * fTemp474)) + fTemp475 * (fTemp478 * (2024.0 * fTemp480 + 3.23e+03 * fTemp481) + fTemp482 * (3233.0 * fTemp484 + 7255.0 * fTemp485)));
			double fTemp642 = std::tan(fConst5 * fTemp641);
			double fTemp643 = fTemp642 * (fTemp492 - fRec436[1]) + fRec435[1];
			double fTemp644 = fTemp642 * (fTemp642 + fTemp498 / fTemp641) + 1.0;
			double fTemp645 = fTemp643 / fTemp644;
			fRec435[0] = 2.0 * fTemp645 - fRec435[1];
			fRec436[0] = fRec436[1] + 2.0 * (fTemp642 * fTemp643 / fTemp644);
			double fRec437 = fTemp645;
			double fTemp646 = fTemp457 * (fTemp465 * (fTemp467 * (2089.0 * fTemp469 + 3328.0 * fTemp470) + fTemp471 * (3.38e+03 * fTemp473 + 8574.0 * fTemp474)) + fTemp475 * (fTemp478 * (2089.0 * fTemp480 + 3328.0 * fTemp481) + fTemp482 * (3.38e+03 * fTemp484 + 8574.0 * fTemp485)));
			double fTemp647 = std::tan(fConst5 * fTemp646);
			double fTemp648 = fTemp647 * (fTemp492 - fRec439[1]) + fRec438[1];
			double fTemp649 = fTemp647 * (fTemp647 + fTemp498 / fTemp646) + 1.0;
			double fTemp650 = fTemp648 / fTemp649;
			fRec438[0] = 2.0 * fTemp650 - fRec438[1];
			fRec439[0] = fRec439[1] + 2.0 * (fTemp647 * fTemp648 / fTemp649);
			double fRec440 = fTemp650;
			double fTemp651 = fTemp457 * (fTemp465 * (fTemp467 * (2351.0 * fTemp469 + 4013.0 * fTemp470) + fTemp471 * (3527.0 * fTemp473 + 9672.0 * fTemp474)) + fTemp475 * (fTemp478 * (2351.0 * fTemp480 + 4013.0 * fTemp481) + fTemp482 * (3527.0 * fTemp484 + 9672.0 * fTemp485)));
			double fTemp652 = std::tan(fConst5 * fTemp651);
			double fTemp653 = fTemp652 * (fTemp492 - fRec442[1]) + fRec441[1];
			double fTemp654 = fTemp652 * (fTemp652 + fTemp498 / fTemp651) + 1.0;
			double fTemp655 = fTemp653 / fTemp654;
			fRec441[0] = 2.0 * fTemp655 - fRec441[1];
			fRec442[0] = fRec442[1] + 2.0 * (fTemp652 * fTemp653 / fTemp654);
			double fRec443 = fTemp655;
			fRec303[0] = 0.6366197723675814 * std::atan(0.03125 * (fRec325 * (fTemp465 * (fTemp467 * (0.01797695 * fTemp469 + 0.0640251 * fTemp470) + fTemp471 * (0.54357606 * fTemp473 + 0.4053105 * fTemp474)) + fTemp475 * (fTemp478 * (0.01797695 * fTemp480 + 0.0640251 * fTemp481) + fTemp482 * (0.54357606 * fTemp484 + 0.4053105 * fTemp485))) + fRec353 * (fTemp465 * (fTemp467 * (0.03067041 * fTemp469 + 0.05785498 * fTemp470) + fTemp471 * (0.09954785 * fTemp473 + 0.62411215 * fTemp474)) + fTemp475 * (fTemp478 * (0.03067041 * fTemp480 + 0.05785498 * fTemp481) + fTemp482 * (0.09954785 * fTemp484 + 0.62411215 * fTemp485))) + fRec356 * (fTemp465 * (fTemp467 * (0.03436227 * fTemp469 + 0.04838698 * fTemp470) + fTemp471 * (0.0250452 * fTemp473 + 0.00707754 * fTemp474)) + fTemp475 * (fTemp478 * (0.03436227 * fTemp480 + 0.04838698 * fTemp481) + fTemp482 * (0.0250452 * fTemp484 + 0.00707754 * fTemp485))) + fRec359 * (fTemp465 * (fTemp467 * (0.01922137 * fTemp469 + 0.00787687 * fTemp470) + fTemp471 * (0.25042786 * fTemp473 + 0.6674602 * fTemp474)) + fTemp475 * (fTemp478 * (0.01922137 * fTemp480 + 0.00787687 * fTemp481) + fTemp482 * (0.25042786 * fTemp484 + 0.6674602 * fTemp485))) + fRec362 * (fTemp465 * (fTemp467 * (0.05522969 * fTemp469 + 0.06051622 * fTemp470) + fTemp471 * (0.02470587 * fTemp473 + 0.01035828 * fTemp474)) + fTemp475 * (fTemp478 * (0.05522969 * fTemp480 + 0.06051622 * fTemp481) + fTemp482 * (0.02470587 * fTemp484 + 0.01035828 * fTemp485))) + fRec365 * (fTemp465 * (fTemp467 * (0.08153769 * fTemp469 + 0.02426847 * fTemp470) + fTemp471 * (0.49828005 * fTemp473 + 0.00749257 * fTemp474)) + fTemp475 * (fTemp478 * (0.08153769 * fTemp480 + 0.02426847 * fTemp481) + fTemp482 * (0.49828005 * fTemp484 + 0.00749257 * fTemp485))) + fRec368 * (fTemp465 * (fTemp467 * (fTemp469 + 0.09843679 * fTemp470) + fTemp471 * (fTemp474 + 0.0405712 * fTemp473)) + fTemp475 * (fTemp478 * (fTemp480 + 0.09843679 * fTemp481) + fTemp482 * (fTemp485 + 0.0405712 * fTemp484))) + fRec371 * (fTemp465 * (fTemp467 * (fTemp470 + 0.27707616 * fTemp469) + fTemp471 * (fTemp473 + 0.01216278 * fTemp474)) + fTemp475 * (fTemp478 * (fTemp481 + 0.27707616 * fTemp480) + fTemp482 * (fTemp484 + 0.01216278 * fTemp485))) + fRec374 * (fTemp465 * (fTemp467 * (0.04196492 * fTemp469 + 0.75217775 * fTemp470) + fTemp471 * (0.07116083 * fTemp473 + 0.01835863 * fTemp474)) + fTemp475 * (fTemp478 * (0.04196492 * fTemp480 + 0.75217775 * fTemp481) + fTemp482 * (0.07116083 * fTemp484 + 0.01835863 * fTemp485))) + fRec377 * (fTemp465 * (fTemp467 * (0.00482074 * fTemp469 + 0.01863539 * fTemp470) + fTemp471 * (0.06191843 * fTemp473 + 0.03888326 * fTemp474)) + fTemp475 * (fTemp478 * (0.00482074 * fTemp480 + 0.01863539 * fTemp481) + fTemp482 * (0.06191843 * fTemp484 + 0.03888326 * fTemp485))) + fRec380 * (fTemp465 * (fTemp467 * (0.02735344 * fTemp469 + 0.02193515 * fTemp470) + fTemp471 * (0.07170723 * fTemp473 + 0.04759307 * fTemp474)) + fTemp475 * (fTemp478 * (0.02735344 * fTemp480 + 0.02193515 * fTemp481) + fTemp482 * (0.07170723 * fTemp484 + 0.04759307 * fTemp485))) + fRec383 * (fTemp465 * (fTemp467 * (0.02222397 * fTemp469 + 0.00886369 * fTemp470) + fTemp471 * (0.02115358 * fTemp473 + 0.02409027 * fTemp474)) + fTemp475 * (fTemp478 * (0.02222397 * fTemp480 + 0.00886369 * fTemp481) + fTemp482 * (0.02115358 * fTemp484 + 0.02409027 * fTemp485))) + fRec386 * (fTemp465 * (fTemp467 * (0.01985851 * fTemp469 + 0.00274825 * fTemp470) + fTemp471 * (0.28175268 * fTemp473 + 0.22375855 * fTemp474)) + fTemp475 * (fTemp478 * (0.01985851 * fTemp480 + 0.00274825 * fTemp481) + fTemp482 * (0.28175268 * fTemp484 + 0.22375855 * fTemp485))) + fRec389 * (fTemp465 * (fTemp467 * (0.03480883 * fTemp469 + 0.02102163 * fTemp470) + fTemp471 * (0.01626654 * fTemp473 + 0.03442368 * fTemp474)) + fTemp475 * (fTemp478 * (0.03480883 * fTemp480 + 0.02102163 * fTemp481) + fTemp482 * (0.01626654 * fTemp484 + 0.03442368 * fTemp485))) + fRec392 * (fTemp465 * (fTemp467 * (0.05834666 * fTemp469 + 0.01772408 * fTemp470) + fTemp471 * (0.14442907 * fTemp473 + 0.07338235 * fTemp474)) + fTemp475 * (fTemp478 * (0.05834666 * fTemp480 + 0.01772408 * fTemp481) + fTemp482 * (0.14442907 * fTemp484 + 0.07338235 * fTemp485))) + fRec395 * (fTemp465 * (fTemp467 * (0.02913938 * fTemp469 + 0.03638926 * fTemp470) + fTemp471 * (0.01228042 * fTemp473 + 0.08982961 * fTemp474)) + fTemp475 * (fTemp478 * (0.02913938 * fTemp480 + 0.03638926 * fTemp481) + fTemp482 * (0.01228042 * fTemp484 + 0.08982961 * fTemp485))) + fRec398 * (fTemp465 * (fTemp467 * (0.0550058 * fTemp469 + 0.02121633 * fTemp470) + fTemp471 * (0.2722688 * fTemp473 + 0.27821024 * fTemp474)) + fTemp475 * (fTemp478 * (0.0550058 * fTemp480 + 0.02121633 * fTemp481) + fTemp482 * (0.2722688 * fTemp484 + 0.27821024 * fTemp485))) + fRec401 * (fTemp465 * (fTemp467 * (0.03381146 * fTemp469 + 0.05363475 * fTemp470) + fTemp471 * (0.01573797 * fTemp473 + 0.64427134 * fTemp474)) + fTemp475 * (fTemp478 * (0.03381146 * fTemp480 + 0.05363475 * fTemp481) + fTemp482 * (0.01573797 * fTemp484 + 0.64427134 * fTemp485))) + fRec404 * (fTemp465 * (fTemp467 * (0.00729633 * fTemp469 + 0.00190274 * fTemp470) + fTemp471 * (0.00656447 * fTemp473 + 0.00854136 * fTemp474)) + fTemp475 * (fTemp478 * (0.00729633 * fTemp480 + 0.00190274 * fTemp481) + fTemp482 * (0.00656447 * fTemp484 + 0.00854136 * fTemp485))) + fRec407 * (fTemp465 * (fTemp467 * (0.02313585 * fTemp469 + 0.00348521 * fTemp470) + fTemp471 * (0.09585942 * fTemp473 + 0.01776269 * fTemp474)) + fTemp475 * (fTemp478 * (0.02313585 * fTemp480 + 0.00348521 * fTemp481) + fTemp482 * (0.09585942 * fTemp484 + 0.01776269 * fTemp485))) + fRec410 * (fTemp465 * (fTemp467 * (0.04640077 * fTemp469 + 0.01305707 * fTemp470) + fTemp471 * (0.06985491 * fTemp473 + 0.01631748 * fTemp474)) + fTemp475 * (fTemp478 * (0.04640077 * fTemp480 + 0.01305707 * fTemp481) + fTemp482 * (0.06985491 * fTemp484 + 0.01631748 * fTemp485))) + fRec413 * (fTemp465 * (fTemp467 * (0.0121161 * fTemp469 + 0.00709897 * fTemp470) + fTemp471 * (0.0343155 * fTemp473 + 0.02601317 * fTemp474)) + fTemp475 * (fTemp478 * (0.0121161 * fTemp480 + 0.00709897 * fTemp481) + fTemp482 * (0.0343155 * fTemp484 + 0.02601317 * fTemp485))) + fRec416 * (fTemp465 * (fTemp467 * (0.01668042 * fTemp469 + 0.01592137 * fTemp470) + fTemp471 * (0.01093969 * fTemp473 + 0.02061391 * fTemp474)) + fTemp475 * (fTemp478 * (0.01668042 * fTemp480 + 0.01592137 * fTemp481) + fTemp482 * (0.01093969 * fTemp484 + 0.02061391 * fTemp485))) + fRec419 * (fTemp465 * (fTemp467 * (0.00848029 * fTemp469 + 0.01670722 * fTemp470) + fTemp471 * (0.05126037 * fTemp473 + 0.03283333 * fTemp474)) + fTemp475 * (fTemp478 * (0.00848029 * fTemp480 + 0.01670722 * fTemp481) + fTemp482 * (0.05126037 * fTemp484 + 0.03283333 * fTemp485))) + fRec422 * (fTemp465 * (fTemp467 * (0.00496045 * fTemp469 + 0.02143791 * fTemp470) + fTemp471 * (0.07354127 * fTemp473 + 0.01222045 * fTemp474)) + fTemp475 * (fTemp478 * (0.00496045 * fTemp480 + 0.02143791 * fTemp481) + fTemp482 * (0.07354127 * fTemp484 + 0.01222045 * fTemp485))) + fRec425 * (fTemp465 * (fTemp467 * (0.00722812 * fTemp469 + 0.00161424 * fTemp470) + fTemp471 * (0.01233555 * fTemp473 + 0.01528356 * fTemp474)) + fTemp475 * (fTemp478 * (0.00722812 * fTemp480 + 0.00161424 * fTemp481) + fTemp482 * (0.01233555 * fTemp484 + 0.01528356 * fTemp485))) + fRec428 * (fTemp465 * (fTemp467 * (0.01041008 * fTemp469 + 0.00333966 * fTemp470) + fTemp471 * (0.01134687 * fTemp473 + 0.01369543 * fTemp474)) + fTemp475 * (fTemp478 * (0.01041008 * fTemp480 + 0.00333966 * fTemp481) + fTemp482 * (0.01134687 * fTemp484 + 0.01369543 * fTemp485))) + fRec431 * (fTemp465 * (fTemp467 * (0.00722225 * fTemp469 + 0.00320751 * fTemp470) + fTemp471 * (0.01055565 * fTemp473 + 0.00841917 * fTemp474)) + fTemp475 * (fTemp478 * (0.00722225 * fTemp480 + 0.00320751 * fTemp481) + fTemp482 * (0.01055565 * fTemp484 + 0.00841917 * fTemp485))) + fRec434 * (fTemp465 * (fTemp467 * (0.00592071 * fTemp469 + 0.00126865 * fTemp470) + fTemp471 * (0.03127152 * fTemp473 + 0.02237106 * fTemp474)) + fTemp475 * (fTemp478 * (0.00592071 * fTemp480 + 0.00126865 * fTemp481) + fTemp482 * (0.03127152 * fTemp484 + 0.02237106 * fTemp485))) + fRec437 * (fTemp465 * (fTemp467 * (0.01158114 * fTemp469 + 0.00132724 * fTemp470) + fTemp471 * (0.01587526 * fTemp473 + 0.00969712 * fTemp474)) + fTemp475 * (fTemp478 * (0.01158114 * fTemp480 + 0.00132724 * fTemp481) + fTemp482 * (0.01587526 * fTemp484 + 0.00969712 * fTemp485))) + fRec440 * (fTemp465 * (fTemp467 * (0.00443968 * fTemp469 + 0.00152525 * fTemp470) + fTemp471 * (0.00962998 * fTemp473 + 0.00986048 * fTemp474)) + fTemp475 * (fTemp478 * (0.00443968 * fTemp480 + 0.00152525 * fTemp481) + fTemp482 * (0.00962998 * fTemp484 + 0.00986048 * fTemp485))) + fRec443 * (fTemp465 * (fTemp467 * (0.00282064 * fTemp469 + 0.00097757 * fTemp470) + fTemp471 * (0.0068168 * fTemp473 + 0.01255551 * fTemp474)) + fTemp475 * (fTemp478 * (0.00282064 * fTemp480 + 0.00097757 * fTemp481) + fTemp482 * (0.0068168 * fTemp484 + 0.01255551 * fTemp485)))));
			fRec5[0] = fRec303[0];
			fRec450[0] = std::fmod(fRec450[1], fConst0) + std::fabs(0.1 * fRec449[1]) + 0.1;
			int iTemp656 = (fConst1 * fRec450[0]) < (fConst1 * fRec450[1]);
			iVec26[0] = 151;
			iRec451[0] = (151 - iVec26[1]) % -2147483648 + (12345 - 59 * iRec451[1]);
			fRec449[0] = fRec449[1] * double(iVec0[1] - iTemp656) + (0.0 - 4.656612873077393e-10 * double(iRec451[0])) * double(iTemp656 + iTemp1);
			int iTemp657 = fRec449[0] == fRec449[1];
			fRec448[0] = fRec448[1] * double(iTemp657) + 0.125 * fTemp3 * double(1 - iTemp657);
			double fTemp658 = ((fRec448[0] != fRec448[1]) ? fConst4 : fRec446[1] + -1.0);
			fRec446[0] = fTemp658;
			fRec447[0] = ((fTemp658 > 0.0) ? fRec447[1] + (fRec448[0] - fRec447[1]) / fTemp658 : fRec448[0]);
			double fTemp659 = tanh(fRec13[0] + fSlow4 * std::sin(6.283185307179586 * fRec447[0])) + 1.0;
			fVbargraph21 = FAUSTFLOAT(5e+02 * fTemp659);
			fRec457[0] = std::fmod(fRec457[1], fConst0) + std::fabs(0.1 * fRec456[1]) + 0.1;
			int iTemp660 = (fConst1 * fRec457[0]) < (fConst1 * fRec457[1]);
			iVec27[0] = 127;
			iRec458[0] = (127 - iVec27[1]) % -2147483648 + (12345 - 59 * iRec458[1]);
			fRec456[0] = fRec456[1] * double(iVec0[1] - iTemp660) + (0.0 - 4.656612873077393e-10 * double(iRec458[0])) * double(iTemp660 + iTemp1);
			int iTemp661 = fRec456[0] == fRec456[1];
			fRec455[0] = fRec455[1] * double(iTemp661) + 0.125 * fTemp3 * double(1 - iTemp661);
			double fTemp662 = ((fRec455[0] != fRec455[1]) ? fConst4 : fRec453[1] + -1.0);
			fRec453[0] = fTemp662;
			fRec454[0] = ((fTemp662 > 0.0) ? fRec454[1] + (fRec455[0] - fRec454[1]) / fTemp662 : fRec455[0]);
			double fTemp663 = std::pow(5e+02, tanh(fRec21[0] + fSlow4 * std::sin(6.283185307179586 * fRec454[0])));
			fVbargraph22 = FAUSTFLOAT(1e+03 * fTemp663);
			fRec452[0] = fRec452[1] + fConst1 * fTemp663;
			fRec463[0] = std::fmod(fRec463[1], fConst0) + std::fabs(0.1 * fRec462[1]) + 0.1;
			int iTemp664 = (fConst1 * fRec463[0]) < (fConst1 * fRec463[1]);
			iVec28[0] = 149;
			iRec464[0] = (149 - iVec28[1]) % -2147483648 + (12345 - 59 * iRec464[1]);
			fRec462[0] = fRec462[1] * double(iVec0[1] - iTemp664) + (0.0 - 4.656612873077393e-10 * double(iRec464[0])) * double(iTemp664 + iTemp1);
			int iTemp665 = fRec462[0] == fRec462[1];
			fRec461[0] = fRec461[1] * double(iTemp665) + 0.125 * fTemp3 * double(1 - iTemp665);
			double fTemp666 = ((fRec461[0] != fRec461[1]) ? fConst4 : fRec459[1] + -1.0);
			fRec459[0] = fTemp666;
			fRec460[0] = ((fTemp666 > 0.0) ? fRec460[1] + (fRec461[0] - fRec460[1]) / fTemp666 : fRec461[0]);
			double fTemp667 = tanh(fRec28[0] + fSlow4 * std::sin(6.283185307179586 * fRec460[0])) + 1.0;
			fVbargraph23 = FAUSTFLOAT(5e+02 * fTemp667);
			double fTemp668 = (fTemp6 * 0.5 * fTemp659 + 1.0) * fRec444[1] + mydsp_faustpower3_f(fRec445[1]) + std::cos(fRec452[0]) * 0.5 * fTemp667;
			double fTemp669 = 0.0 - fTemp668;
			fVec29[0] = fTemp669;
			fRec444[0] = fTemp669;
			fRec472[0] = std::fmod(fRec472[1], fConst0) + std::fabs(0.1 * fRec471[1]) + 0.1;
			int iTemp670 = (fConst1 * fRec472[0]) < (fConst1 * fRec472[1]);
			iVec30[0] = 131;
			iRec473[0] = (131 - iVec30[1]) % -2147483648 + (12345 - 59 * iRec473[1]);
			fRec471[0] = fRec471[1] * double(iVec0[1] - iTemp670) + (0.0 - 4.656612873077393e-10 * double(iRec473[0])) * double(iTemp670 + iTemp1);
			int iTemp671 = fRec471[0] == fRec471[1];
			fRec470[0] = fRec470[1] * double(iTemp671) + 0.125 * fTemp3 * double(1 - iTemp671);
			double fTemp672 = ((fRec470[0] != fRec470[1]) ? fConst4 : fRec468[1] + -1.0);
			fRec468[0] = fTemp672;
			fRec469[0] = ((fTemp672 > 0.0) ? fRec469[1] + (fRec470[0] - fRec469[1]) / fTemp672 : fRec470[0]);
			double fTemp673 = 0.45 * (tanh(fRec38[0] + fSlow4 * std::sin(6.283185307179586 * fRec469[0])) + 1.0) + 0.1;
			fVbargraph24 = FAUSTFLOAT(1e+03 * fTemp673);
			double fTemp674 = fTemp673;
			fRec478[0] = std::fmod(fRec478[1], fConst0) + std::fabs(0.1 * fRec477[1]) + 0.1;
			int iTemp675 = (fConst1 * fRec478[0]) < (fConst1 * fRec478[1]);
			iVec31[0] = 137;
			iRec479[0] = (137 - iVec31[1]) % -2147483648 + (12345 - 59 * iRec479[1]);
			fRec477[0] = fRec477[1] * double(iVec0[1] - iTemp675) + (0.0 - 4.656612873077393e-10 * double(iRec479[0])) * double(iTemp675 + iTemp1);
			int iTemp676 = fRec477[0] == fRec477[1];
			fRec476[0] = fRec476[1] * double(iTemp676) + 0.125 * fTemp3 * double(1 - iTemp676);
			double fTemp677 = ((fRec476[0] != fRec476[1]) ? fConst4 : fRec474[1] + -1.0);
			fRec474[0] = fTemp677;
			fRec475[0] = ((fTemp677 > 0.0) ? fRec475[1] + (fRec476[0] - fRec475[1]) / fTemp677 : fRec476[0]);
			double fTemp678 = tanh(fRec45[0] + fSlow4 * std::sin(6.283185307179586 * fRec475[0])) + 1.0;
			fVbargraph25 = FAUSTFLOAT(5e+02 * fTemp678);
			double fTemp679 = 4.0 * 0.5 * fTemp678;
			int iTemp680 = int(fTemp679);
			double fTemp681 = double(iTemp680);
			double fTemp682 = fTemp681 + (1.0 - fTemp679);
			int iTemp683 = iTemp680 >= 2;
			double fTemp684 = double(1 - iTemp683);
			int iTemp685 = iTemp680 >= 1;
			double fTemp686 = double(1 - iTemp685);
			double fTemp687 = double(iTemp685);
			double fTemp688 = double(iTemp683);
			int iTemp689 = iTemp680 >= 3;
			double fTemp690 = double(1 - iTemp689);
			double fTemp691 = double(iTemp689);
			double fTemp692 = fTemp679 - fTemp681;
			int iTemp693 = iTemp680 + 1;
			int iTemp694 = iTemp693 >= 2;
			double fTemp695 = double(1 - iTemp694);
			int iTemp696 = iTemp693 >= 1;
			double fTemp697 = double(1 - iTemp696);
			double fTemp698 = double(iTemp696);
			double fTemp699 = double(iTemp694);
			int iTemp700 = iTemp693 >= 3;
			double fTemp701 = double(1 - iTemp700);
			double fTemp702 = double(iTemp700);
			double fTemp703 = fTemp674 * (fTemp682 * (fTemp684 * (196.0 * fTemp686 + 293.0 * fTemp687) + fTemp688 * (203.0 * fTemp690 + 2.2e+02 * fTemp691)) + fTemp692 * (fTemp695 * (196.0 * fTemp697 + 293.0 * fTemp698) + fTemp699 * (203.0 * fTemp701 + 2.2e+02 * fTemp702)));
			double fTemp704 = std::tan(fConst5 * fTemp703);
			fRec480[0] = 0.995 * fRec480[1] - (fTemp668 + fVec29[1]);
			fRec485[0] = std::fmod(fRec485[1], fConst0) + std::fabs(0.1 * fRec484[1]) + 0.1;
			int iTemp705 = (fConst1 * fRec485[0]) < (fConst1 * fRec485[1]);
			iVec32[0] = 157;
			iRec486[0] = (157 - iVec32[1]) % -2147483648 + (12345 - 59 * iRec486[1]);
			fRec484[0] = fRec484[1] * double(iVec0[1] - iTemp705) + (0.0 - 4.656612873077393e-10 * double(iRec486[0])) * double(iTemp705 + iTemp1);
			int iTemp706 = fRec484[0] == fRec484[1];
			fRec483[0] = fRec483[1] * double(iTemp706) + 0.125 * fTemp3 * double(1 - iTemp706);
			double fTemp707 = ((fRec483[0] != fRec483[1]) ? fConst4 : fRec481[1] + -1.0);
			fRec481[0] = fTemp707;
			fRec482[0] = ((fTemp707 > 0.0) ? fRec482[1] + (fRec483[0] - fRec482[1]) / fTemp707 : fRec483[0]);
			double fTemp708 = std::pow(1e+03, tanh(fRec53[0] + fSlow4 * std::sin(6.283185307179586 * fRec482[0])));
			fVbargraph26 = FAUSTFLOAT(fTemp708);
			double fTemp709 = fRec480[0] * fTemp708;
			double fTemp710 = fTemp704 * (fTemp709 - fRec466[1]) + fRec465[1];
			fRec491[0] = std::fmod(fRec491[1], fConst0) + std::fabs(0.1 * fRec490[1]) + 0.1;
			int iTemp711 = (fConst1 * fRec491[0]) < (fConst1 * fRec491[1]);
			iVec33[0] = 139;
			iRec492[0] = (139 - iVec33[1]) % -2147483648 + (12345 - 59 * iRec492[1]);
			fRec490[0] = fRec490[1] * double(iVec0[1] - iTemp711) + (0.0 - 4.656612873077393e-10 * double(iRec492[0])) * double(iTemp711 + iTemp1);
			int iTemp712 = fRec490[0] == fRec490[1];
			fRec489[0] = fRec489[1] * double(iTemp712) + 0.125 * fTemp3 * double(1 - iTemp712);
			double fTemp713 = ((fRec489[0] != fRec489[1]) ? fConst4 : fRec487[1] + -1.0);
			fRec487[0] = fTemp713;
			fRec488[0] = ((fTemp713 > 0.0) ? fRec488[1] + (fRec489[0] - fRec488[1]) / fTemp713 : fRec489[0]);
			double fTemp714 = std::pow(1e+02, tanh(fRec60[0] + fSlow4 * std::sin(6.283185307179586 * fRec488[0])));
			fVbargraph27 = FAUSTFLOAT(fTemp714);
			double fTemp715 = std::max<double>(2.220446049250313e-16, fTemp714);
			double fTemp716 = fTemp704 * (fTemp704 + fTemp715 / fTemp703) + 1.0;
			double fTemp717 = fTemp710 / fTemp716;
			fRec465[0] = 2.0 * fTemp717 - fRec465[1];
			fRec466[0] = fRec466[1] + 2.0 * (fTemp704 * fTemp710 / fTemp716);
			double fRec467 = fTemp717;
			double fTemp718 = fTemp674 * (fTemp682 * (fTemp684 * (131.0 * fTemp686 + 195.0 * fTemp687) + fTemp688 * (147.0 * fTemp690 + 1.3e+02 * fTemp691)) + fTemp692 * (fTemp695 * (131.0 * fTemp697 + 195.0 * fTemp698) + fTemp699 * (147.0 * fTemp701 + 1.3e+02 * fTemp702)));
			double fTemp719 = std::tan(fConst5 * fTemp718);
			double fTemp720 = fTemp719 * (fTemp709 - fRec494[1]) + fRec493[1];
			double fTemp721 = fTemp719 * (fTemp719 + fTemp715 / fTemp718) + 1.0;
			double fTemp722 = fTemp720 / fTemp721;
			fRec493[0] = 2.0 * fTemp722 - fRec493[1];
			fRec494[0] = fRec494[1] + 2.0 * (fTemp719 * fTemp720 / fTemp721);
			double fRec495 = fTemp722;
			double fTemp723 = (fTemp682 * ((65.0 * fTemp686 + 98.0 * fTemp687) * fTemp684 + (53.0 * fTemp690 + 5e+01 * fTemp691) * fTemp688) + fTemp692 * ((65.0 * fTemp697 + 98.0 * fTemp698) * fTemp695 + (53.0 * fTemp701 + 5e+01 * fTemp702) * fTemp699)) * fTemp674;
			double fTemp724 = std::tan(fConst5 * fTemp723);
			double fTemp725 = fTemp724 * (fTemp709 - fRec497[1]) + fRec496[1];
			double fTemp726 = fTemp724 * (fTemp724 + fTemp715 / fTemp723) + 1.0;
			double fTemp727 = fTemp725 / fTemp726;
			fRec496[0] = 2.0 * fTemp727 - fRec496[1];
			fRec497[0] = fRec497[1] + 2.0 * (fTemp724 * fTemp725 / fTemp726);
			double fRec498 = fTemp727;
			double fTemp728 = fTemp674 * (fTemp682 * (fTemp684 * (784.0 * fTemp686 + 1076.0 * fTemp687) + fTemp688 * (961.0 * fTemp690 + 1539.0 * fTemp691)) + fTemp692 * (fTemp695 * (784.0 * fTemp697 + 1076.0 * fTemp698) + fTemp699 * (961.0 * fTemp701 + 1539.0 * fTemp702)));
			double fTemp729 = std::tan(fConst5 * fTemp728);
			double fTemp730 = fTemp729 * (fTemp709 - fRec500[1]) + fRec499[1];
			double fTemp731 = fTemp729 * (fTemp729 + fTemp715 / fTemp728) + 1.0;
			double fTemp732 = fTemp730 / fTemp731;
			fRec499[0] = 2.0 * fTemp732 - fRec499[1];
			fRec500[0] = fRec500[1] + 2.0 * (fTemp729 * fTemp730 / fTemp731);
			double fRec501 = fTemp732;
			double fTemp733 = fTemp674 * (fTemp682 * (fTemp684 * (718.0 * fTemp686 + 979.0 * fTemp687) + fTemp688 * (882.0 * fTemp690 + 1319.0 * fTemp691)) + fTemp692 * (fTemp695 * (718.0 * fTemp697 + 979.0 * fTemp698) + fTemp699 * (882.0 * fTemp701 + 1319.0 * fTemp702)));
			double fTemp734 = std::tan(fConst5 * fTemp733);
			double fTemp735 = fTemp734 * (fTemp709 - fRec503[1]) + fRec502[1];
			double fTemp736 = fTemp734 * (fTemp734 + fTemp715 / fTemp733) + 1.0;
			double fTemp737 = fTemp735 / fTemp736;
			fRec502[0] = 2.0 * fTemp737 - fRec502[1];
			fRec503[0] = fRec503[1] + 2.0 * (fTemp734 * fTemp735 / fTemp736);
			double fRec504 = fTemp737;
			double fTemp738 = fTemp674 * (fTemp682 * (fTemp684 * (653.0 * fTemp686 + 8.8e+02 * fTemp687) + fTemp688 * (785.0 * fTemp690 + 1099.0 * fTemp691)) + fTemp692 * (fTemp695 * (653.0 * fTemp697 + 8.8e+02 * fTemp698) + fTemp699 * (785.0 * fTemp701 + 1099.0 * fTemp702)));
			double fTemp739 = std::tan(fConst5 * fTemp738);
			double fTemp740 = fTemp739 * (fTemp709 - fRec506[1]) + fRec505[1];
			double fTemp741 = fTemp739 * (fTemp739 + fTemp715 / fTemp738) + 1.0;
			double fTemp742 = fTemp740 / fTemp741;
			fRec505[0] = 2.0 * fTemp742 - fRec505[1];
			fRec506[0] = fRec506[1] + 2.0 * (fTemp739 * fTemp740 / fTemp741);
			double fRec507 = fTemp742;
			double fTemp743 = fTemp674 * (fTemp682 * (fTemp684 * (588.0 * fTemp686 + 783.0 * fTemp687) + fTemp688 * (735.0 * fTemp690 + 879.0 * fTemp691)) + fTemp692 * (fTemp695 * (588.0 * fTemp697 + 783.0 * fTemp698) + fTemp699 * (735.0 * fTemp701 + 879.0 * fTemp702)));
			double fTemp744 = std::tan(fConst5 * fTemp743);
			double fTemp745 = fTemp744 * (fTemp709 - fRec509[1]) + fRec508[1];
			double fTemp746 = fTemp744 * (fTemp744 + fTemp715 / fTemp743) + 1.0;
			double fTemp747 = fTemp745 / fTemp746;
			fRec508[0] = 2.0 * fTemp747 - fRec508[1];
			fRec509[0] = fRec509[1] + 2.0 * (fTemp744 * fTemp745 / fTemp746);
			double fRec510 = fTemp747;
			double fTemp748 = fTemp674 * (fTemp682 * (fTemp684 * (522.0 * fTemp686 + 685.0 * fTemp687) + fTemp688 * (588.0 * fTemp690 + 659.0 * fTemp691)) + fTemp692 * (fTemp695 * (522.0 * fTemp697 + 685.0 * fTemp698) + fTemp699 * (588.0 * fTemp701 + 659.0 * fTemp702)));
			double fTemp749 = std::tan(fConst5 * fTemp748);
			double fTemp750 = fTemp749 * (fTemp709 - fRec512[1]) + fRec511[1];
			double fTemp751 = fTemp749 * (fTemp749 + fTemp715 / fTemp748) + 1.0;
			double fTemp752 = fTemp750 / fTemp751;
			fRec511[0] = 2.0 * fTemp752 - fRec511[1];
			fRec512[0] = fRec512[1] + 2.0 * (fTemp749 * fTemp750 / fTemp751);
			double fRec513 = fTemp752;
			double fTemp753 = fTemp674 * (fTemp682 * (fTemp684 * (457.0 * fTemp686 + 587.0 * fTemp687) + fTemp688 * (534.0 * fTemp690 + 538.0 * fTemp691)) + fTemp692 * (fTemp695 * (457.0 * fTemp697 + 587.0 * fTemp698) + fTemp699 * (534.0 * fTemp701 + 538.0 * fTemp702)));
			double fTemp754 = std::tan(fConst5 * fTemp753);
			double fTemp755 = fTemp754 * (fTemp709 - fRec515[1]) + fRec514[1];
			double fTemp756 = fTemp754 * (fTemp754 + fTemp715 / fTemp753) + 1.0;
			double fTemp757 = fTemp755 / fTemp756;
			fRec514[0] = 2.0 * fTemp757 - fRec514[1];
			fRec515[0] = fRec515[1] + 2.0 * (fTemp754 * fTemp755 / fTemp756);
			double fRec516 = fTemp757;
			double fTemp758 = fTemp674 * (fTemp682 * (fTemp684 * (392.0 * fTemp686 + 537.0 * fTemp687) + fTemp688 * (441.0 * fTemp690 + 439.0 * fTemp691)) + fTemp692 * (fTemp695 * (392.0 * fTemp697 + 537.0 * fTemp698) + fTemp699 * (441.0 * fTemp701 + 439.0 * fTemp702)));
			double fTemp759 = std::tan(fConst5 * fTemp758);
			double fTemp760 = fTemp759 * (fTemp709 - fRec518[1]) + fRec517[1];
			double fTemp761 = fTemp759 * (fTemp759 + fTemp715 / fTemp758) + 1.0;
			double fTemp762 = fTemp760 / fTemp761;
			fRec517[0] = 2.0 * fTemp762 - fRec517[1];
			fRec518[0] = fRec518[1] + 2.0 * (fTemp759 * fTemp760 / fTemp761);
			double fRec519 = fTemp762;
			double fTemp763 = fTemp674 * (fTemp682 * (fTemp684 * (326.0 * fTemp686 + 489.0 * fTemp687) + fTemp688 * (367.0 * fTemp690 + 368.0 * fTemp691)) + fTemp692 * (fTemp695 * (326.0 * fTemp697 + 489.0 * fTemp698) + fTemp699 * (367.0 * fTemp701 + 368.0 * fTemp702)));
			double fTemp764 = std::tan(fConst5 * fTemp763);
			double fTemp765 = fTemp764 * (fTemp709 - fRec521[1]) + fRec520[1];
			double fTemp766 = fTemp764 * (fTemp764 + fTemp715 / fTemp763) + 1.0;
			double fTemp767 = fTemp765 / fTemp766;
			fRec520[0] = 2.0 * fTemp767 - fRec520[1];
			fRec521[0] = fRec521[1] + 2.0 * (fTemp764 * fTemp765 / fTemp766);
			double fRec522 = fTemp767;
			double fTemp768 = fTemp674 * (fTemp682 * (fTemp684 * (261.0 * fTemp686 + 391.0 * fTemp687) + fTemp688 * (294.0 * fTemp690 + 309.0 * fTemp691)) + fTemp692 * (fTemp695 * (261.0 * fTemp697 + 391.0 * fTemp698) + fTemp699 * (294.0 * fTemp701 + 309.0 * fTemp702)));
			double fTemp769 = std::tan(fConst5 * fTemp768);
			double fTemp770 = fTemp769 * (fTemp709 - fRec524[1]) + fRec523[1];
			double fTemp771 = fTemp769 * (fTemp769 + fTemp715 / fTemp768) + 1.0;
			double fTemp772 = fTemp770 / fTemp771;
			fRec523[0] = 2.0 * fTemp772 - fRec523[1];
			fRec524[0] = fRec524[1] + 2.0 * (fTemp769 * fTemp770 / fTemp771);
			double fRec525 = fTemp772;
			double fTemp773 = fTemp674 * (fTemp682 * (fTemp684 * (1306.0 * fTemp686 + 1.86e+03 * fTemp687) + fTemp688 * (1764.0 * fTemp690 + 3298.0 * fTemp691)) + fTemp692 * (fTemp695 * (1306.0 * fTemp697 + 1.86e+03 * fTemp698) + fTemp699 * (1764.0 * fTemp701 + 3298.0 * fTemp702)));
			double fTemp774 = std::tan(fConst5 * fTemp773);
			double fTemp775 = fTemp774 * (fTemp709 - fRec527[1]) + fRec526[1];
			double fTemp776 = fTemp774 * (fTemp774 + fTemp715 / fTemp773) + 1.0;
			double fTemp777 = fTemp775 / fTemp776;
			fRec526[0] = 2.0 * fTemp777 - fRec526[1];
			fRec527[0] = fRec527[1] + 2.0 * (fTemp774 * fTemp775 / fTemp776);
			double fRec528 = fTemp777;
			double fTemp778 = fTemp674 * (fTemp682 * (fTemp684 * (1241.0 * fTemp686 + 1762.0 * fTemp687) + fTemp688 * (1617.0 * fTemp690 + 3078.0 * fTemp691)) + fTemp692 * (fTemp695 * (1241.0 * fTemp697 + 1762.0 * fTemp698) + fTemp699 * (1617.0 * fTemp701 + 3078.0 * fTemp702)));
			double fTemp779 = std::tan(fConst5 * fTemp778);
			double fTemp780 = fTemp779 * (fTemp709 - fRec530[1]) + fRec529[1];
			double fTemp781 = fTemp779 * (fTemp779 + fTemp715 / fTemp778) + 1.0;
			double fTemp782 = fTemp780 / fTemp781;
			fRec529[0] = 2.0 * fTemp782 - fRec529[1];
			fRec530[0] = fRec530[1] + 2.0 * (fTemp779 * fTemp780 / fTemp781);
			double fRec531 = fTemp782;
			double fTemp783 = fTemp674 * (fTemp682 * (fTemp684 * (1175.0 * fTemp686 + 1664.0 * fTemp687) + fTemp688 * (1.47e+03 * fTemp690 + 2858.0 * fTemp691)) + fTemp692 * (fTemp695 * (1175.0 * fTemp697 + 1664.0 * fTemp698) + fTemp699 * (1.47e+03 * fTemp701 + 2858.0 * fTemp702)));
			double fTemp784 = std::tan(fConst5 * fTemp783);
			double fTemp785 = fTemp784 * (fTemp709 - fRec533[1]) + fRec532[1];
			double fTemp786 = fTemp784 * (fTemp784 + fTemp715 / fTemp783) + 1.0;
			double fTemp787 = fTemp785 / fTemp786;
			fRec532[0] = 2.0 * fTemp787 - fRec532[1];
			fRec533[0] = fRec533[1] + 2.0 * (fTemp784 * fTemp785 / fTemp786);
			double fRec534 = fTemp787;
			double fTemp788 = fTemp674 * (fTemp682 * (fTemp684 * (1.11e+03 * fTemp686 + 1566.0 * fTemp687) + fTemp688 * (1323.0 * fTemp690 + 2638.0 * fTemp691)) + fTemp692 * (fTemp695 * (1.11e+03 * fTemp697 + 1566.0 * fTemp698) + fTemp699 * (1323.0 * fTemp701 + 2638.0 * fTemp702)));
			double fTemp789 = std::tan(fConst5 * fTemp788);
			double fTemp790 = fTemp789 * (fTemp709 - fRec536[1]) + fRec535[1];
			double fTemp791 = fTemp789 * (fTemp789 + fTemp715 / fTemp788) + 1.0;
			double fTemp792 = fTemp790 / fTemp791;
			fRec535[0] = 2.0 * fTemp792 - fRec535[1];
			fRec536[0] = fRec536[1] + 2.0 * (fTemp789 * fTemp790 / fTemp791);
			double fRec537 = fTemp792;
			double fTemp793 = fTemp674 * (fTemp682 * (fTemp684 * (1045.0 * fTemp686 + 1468.0 * fTemp687) + fTemp688 * (1269.0 * fTemp690 + 2418.0 * fTemp691)) + fTemp692 * (fTemp695 * (1045.0 * fTemp697 + 1468.0 * fTemp698) + fTemp699 * (1269.0 * fTemp701 + 2418.0 * fTemp702)));
			double fTemp794 = std::tan(fConst5 * fTemp793);
			double fTemp795 = fTemp794 * (fTemp709 - fRec539[1]) + fRec538[1];
			double fTemp796 = fTemp794 * (fTemp794 + fTemp715 / fTemp793) + 1.0;
			double fTemp797 = fTemp795 / fTemp796;
			fRec538[0] = 2.0 * fTemp797 - fRec538[1];
			fRec539[0] = fRec539[1] + 2.0 * (fTemp794 * fTemp795 / fTemp796);
			double fRec540 = fTemp797;
			double fTemp798 = fTemp674 * (fTemp682 * (fTemp684 * (979.0 * fTemp686 + 1371.0 * fTemp687) + fTemp688 * (1175.0 * fTemp690 + 2198.0 * fTemp691)) + fTemp692 * (fTemp695 * (979.0 * fTemp697 + 1371.0 * fTemp698) + fTemp699 * (1175.0 * fTemp701 + 2198.0 * fTemp702)));
			double fTemp799 = std::tan(fConst5 * fTemp798);
			double fTemp800 = fTemp799 * (fTemp709 - fRec542[1]) + fRec541[1];
			double fTemp801 = fTemp799 * (fTemp799 + fTemp715 / fTemp798) + 1.0;
			double fTemp802 = fTemp800 / fTemp801;
			fRec541[0] = 2.0 * fTemp802 - fRec541[1];
			fRec542[0] = fRec542[1] + 2.0 * (fTemp799 * fTemp800 / fTemp801);
			double fRec543 = fTemp802;
			double fTemp803 = fTemp674 * (fTemp682 * (fTemp684 * (914.0 * fTemp686 + 1272.0 * fTemp687) + fTemp688 * (1078.0 * fTemp690 + 1978.0 * fTemp691)) + fTemp692 * (fTemp695 * (914.0 * fTemp697 + 1272.0 * fTemp698) + fTemp699 * (1078.0 * fTemp701 + 1978.0 * fTemp702)));
			double fTemp804 = std::tan(fConst5 * fTemp803);
			double fTemp805 = fTemp804 * (fTemp709 - fRec545[1]) + fRec544[1];
			double fTemp806 = fTemp804 * (fTemp804 + fTemp715 / fTemp803) + 1.0;
			double fTemp807 = fTemp805 / fTemp806;
			fRec544[0] = 2.0 * fTemp807 - fRec544[1];
			fRec545[0] = fRec545[1] + 2.0 * (fTemp804 * fTemp805 / fTemp806);
			double fRec546 = fTemp807;
			double fTemp808 = fTemp674 * (fTemp682 * (fTemp684 * (849.0 * fTemp686 + 1174.0 * fTemp687) + fTemp688 * (1028.0 * fTemp690 + 1759.0 * fTemp691)) + fTemp692 * (fTemp695 * (849.0 * fTemp697 + 1174.0 * fTemp698) + fTemp699 * (1028.0 * fTemp701 + 1759.0 * fTemp702)));
			double fTemp809 = std::tan(fConst5 * fTemp808);
			double fTemp810 = fTemp809 * (fTemp709 - fRec548[1]) + fRec547[1];
			double fTemp811 = fTemp809 * (fTemp809 + fTemp715 / fTemp808) + 1.0;
			double fTemp812 = fTemp810 / fTemp811;
			fRec547[0] = 2.0 * fTemp812 - fRec547[1];
			fRec548[0] = fRec548[1] + 2.0 * (fTemp809 * fTemp810 / fTemp811);
			double fRec549 = fTemp812;
			double fTemp813 = fTemp674 * (fTemp682 * (fTemp684 * (1828.0 * fTemp686 + 2741.0 * fTemp687) + fTemp688 * (2498.0 * fTemp690 + 5496.0 * fTemp691)) + fTemp692 * (fTemp695 * (1828.0 * fTemp697 + 2741.0 * fTemp698) + fTemp699 * (2498.0 * fTemp701 + 5496.0 * fTemp702)));
			double fTemp814 = std::tan(fConst5 * fTemp813);
			double fTemp815 = fTemp814 * (fTemp709 - fRec551[1]) + fRec550[1];
			double fTemp816 = fTemp814 * (fTemp814 + fTemp715 / fTemp813) + 1.0;
			double fTemp817 = fTemp815 / fTemp816;
			fRec550[0] = 2.0 * fTemp817 - fRec550[1];
			fRec551[0] = fRec551[1] + 2.0 * (fTemp814 * fTemp815 / fTemp816);
			double fRec552 = fTemp817;
			double fTemp818 = fTemp674 * (fTemp682 * (fTemp684 * (1763.0 * fTemp686 + 2643.0 * fTemp687) + fTemp688 * (2351.0 * fTemp690 + 5056.0 * fTemp691)) + fTemp692 * (fTemp695 * (1763.0 * fTemp697 + 2643.0 * fTemp698) + fTemp699 * (2351.0 * fTemp701 + 5056.0 * fTemp702)));
			double fTemp819 = std::tan(fConst5 * fTemp818);
			double fTemp820 = fTemp819 * (fTemp709 - fRec554[1]) + fRec553[1];
			double fTemp821 = fTemp819 * (fTemp819 + fTemp715 / fTemp818) + 1.0;
			double fTemp822 = fTemp820 / fTemp821;
			fRec553[0] = 2.0 * fTemp822 - fRec553[1];
			fRec554[0] = fRec554[1] + 2.0 * (fTemp819 * fTemp820 / fTemp821);
			double fRec555 = fTemp822;
			double fTemp823 = fTemp674 * (fTemp682 * (fTemp684 * (1698.0 * fTemp686 + 2349.0 * fTemp687) + fTemp688 * (2273.0 * fTemp690 + 4617.0 * fTemp691)) + fTemp692 * (fTemp695 * (1698.0 * fTemp697 + 2349.0 * fTemp698) + fTemp699 * (2273.0 * fTemp701 + 4617.0 * fTemp702)));
			double fTemp824 = std::tan(fConst5 * fTemp823);
			double fTemp825 = fTemp824 * (fTemp709 - fRec557[1]) + fRec556[1];
			double fTemp826 = fTemp824 * (fTemp824 + fTemp715 / fTemp823) + 1.0;
			double fTemp827 = fTemp825 / fTemp826;
			fRec556[0] = 2.0 * fTemp827 - fRec556[1];
			fRec557[0] = fRec557[1] + 2.0 * (fTemp824 * fTemp825 / fTemp826);
			double fRec558 = fTemp827;
			double fTemp828 = fTemp674 * (fTemp682 * (fTemp684 * (1632.0 * fTemp686 + 2252.0 * fTemp687) + fTemp688 * (2204.0 * fTemp690 + 4177.0 * fTemp691)) + fTemp692 * (fTemp695 * (1632.0 * fTemp697 + 2252.0 * fTemp698) + fTemp699 * (2204.0 * fTemp701 + 4177.0 * fTemp702)));
			double fTemp829 = std::tan(fConst5 * fTemp828);
			double fTemp830 = fTemp829 * (fTemp709 - fRec560[1]) + fRec559[1];
			double fTemp831 = fTemp829 * (fTemp829 + fTemp715 / fTemp828) + 1.0;
			double fTemp832 = fTemp830 / fTemp831;
			fRec559[0] = 2.0 * fTemp832 - fRec559[1];
			fRec560[0] = fRec560[1] + 2.0 * (fTemp829 * fTemp830 / fTemp831);
			double fRec561 = fTemp832;
			double fTemp833 = fTemp674 * (fTemp682 * (fTemp684 * (1567.0 * fTemp686 + 2153.0 * fTemp687) + fTemp688 * (2054.0 * fTemp690 + 3957.0 * fTemp691)) + fTemp692 * (fTemp695 * (1567.0 * fTemp697 + 2153.0 * fTemp698) + fTemp699 * (2054.0 * fTemp701 + 3957.0 * fTemp702)));
			double fTemp834 = std::tan(fConst5 * fTemp833);
			double fTemp835 = fTemp834 * (fTemp709 - fRec563[1]) + fRec562[1];
			double fTemp836 = fTemp834 * (fTemp834 + fTemp715 / fTemp833) + 1.0;
			double fTemp837 = fTemp835 / fTemp836;
			fRec562[0] = 2.0 * fTemp837 - fRec562[1];
			fRec563[0] = fRec563[1] + 2.0 * (fTemp834 * fTemp835 / fTemp836);
			double fRec564 = fTemp837;
			double fTemp838 = fTemp674 * (fTemp682 * (fTemp684 * (1502.0 * fTemp686 + 2056.0 * fTemp687) + fTemp688 * (1.91e+03 * fTemp690 + 3737.0 * fTemp691)) + fTemp692 * (fTemp695 * (1502.0 * fTemp697 + 2056.0 * fTemp698) + fTemp699 * (1.91e+03 * fTemp701 + 3737.0 * fTemp702)));
			double fTemp839 = std::tan(fConst5 * fTemp838);
			double fTemp840 = fTemp839 * (fTemp709 - fRec566[1]) + fRec565[1];
			double fTemp841 = fTemp839 * (fTemp839 + fTemp715 / fTemp838) + 1.0;
			double fTemp842 = fTemp840 / fTemp841;
			fRec565[0] = 2.0 * fTemp842 - fRec565[1];
			fRec566[0] = fRec566[1] + 2.0 * (fTemp839 * fTemp840 / fTemp841);
			double fRec567 = fTemp842;
			double fTemp843 = fTemp674 * (fTemp682 * (fTemp684 * (1371.0 * fTemp686 + 1958.0 * fTemp687) + fTemp688 * (1855.0 * fTemp690 + 3517.0 * fTemp691)) + fTemp692 * (fTemp695 * (1371.0 * fTemp697 + 1958.0 * fTemp698) + fTemp699 * (1855.0 * fTemp701 + 3517.0 * fTemp702)));
			double fTemp844 = std::tan(fConst5 * fTemp843);
			double fTemp845 = fTemp844 * (fTemp709 - fRec569[1]) + fRec568[1];
			double fTemp846 = fTemp844 * (fTemp844 + fTemp715 / fTemp843) + 1.0;
			double fTemp847 = fTemp845 / fTemp846;
			fRec568[0] = 2.0 * fTemp847 - fRec568[1];
			fRec569[0] = fRec569[1] + 2.0 * (fTemp844 * fTemp845 / fTemp846);
			double fRec570 = fTemp847;
			double fTemp848 = fTemp674 * (fTemp682 * (fTemp684 * (1894.0 * fTemp686 + 2839.0 * fTemp687) + fTemp688 * (2645.0 * fTemp690 + 5717.0 * fTemp691)) + fTemp692 * (fTemp695 * (1894.0 * fTemp697 + 2839.0 * fTemp698) + fTemp699 * (2645.0 * fTemp701 + 5717.0 * fTemp702)));
			double fTemp849 = std::tan(fConst5 * fTemp848);
			double fTemp850 = fTemp849 * (fTemp709 - fRec572[1]) + fRec571[1];
			double fTemp851 = fTemp849 * (fTemp849 + fTemp715 / fTemp848) + 1.0;
			double fTemp852 = fTemp850 / fTemp851;
			fRec571[0] = 2.0 * fTemp852 - fRec571[1];
			fRec572[0] = fRec572[1] + 2.0 * (fTemp849 * fTemp850 / fTemp851);
			double fRec573 = fTemp852;
			double fTemp853 = fTemp674 * (fTemp682 * (fTemp684 * (1959.0 * fTemp686 + 2937.0 * fTemp687) + fTemp688 * (2792.0 * fTemp690 + 7035.0 * fTemp691)) + fTemp692 * (fTemp695 * (1959.0 * fTemp697 + 2937.0 * fTemp698) + fTemp699 * (2792.0 * fTemp701 + 7035.0 * fTemp702)));
			double fTemp854 = std::tan(fConst5 * fTemp853);
			double fTemp855 = fTemp854 * (fTemp709 - fRec575[1]) + fRec574[1];
			double fTemp856 = fTemp854 * (fTemp854 + fTemp715 / fTemp853) + 1.0;
			double fTemp857 = fTemp855 / fTemp856;
			fRec574[0] = 2.0 * fTemp857 - fRec574[1];
			fRec575[0] = fRec575[1] + 2.0 * (fTemp854 * fTemp855 / fTemp856);
			double fRec576 = fTemp857;
			double fTemp858 = fTemp674 * (fTemp682 * (fTemp684 * (2024.0 * fTemp686 + 3.23e+03 * fTemp687) + fTemp688 * (3233.0 * fTemp690 + 7255.0 * fTemp691)) + fTemp692 * (fTemp695 * (2024.0 * fTemp697 + 3.23e+03 * fTemp698) + fTemp699 * (3233.0 * fTemp701 + 7255.0 * fTemp702)));
			double fTemp859 = std::tan(fConst5 * fTemp858);
			double fTemp860 = fTemp859 * (fTemp709 - fRec578[1]) + fRec577[1];
			double fTemp861 = fTemp859 * (fTemp859 + fTemp715 / fTemp858) + 1.0;
			double fTemp862 = fTemp860 / fTemp861;
			fRec577[0] = 2.0 * fTemp862 - fRec577[1];
			fRec578[0] = fRec578[1] + 2.0 * (fTemp859 * fTemp860 / fTemp861);
			double fRec579 = fTemp862;
			double fTemp863 = fTemp674 * (fTemp682 * (fTemp684 * (2089.0 * fTemp686 + 3328.0 * fTemp687) + fTemp688 * (3.38e+03 * fTemp690 + 8574.0 * fTemp691)) + fTemp692 * (fTemp695 * (2089.0 * fTemp697 + 3328.0 * fTemp698) + fTemp699 * (3.38e+03 * fTemp701 + 8574.0 * fTemp702)));
			double fTemp864 = std::tan(fConst5 * fTemp863);
			double fTemp865 = fTemp864 * (fTemp709 - fRec581[1]) + fRec580[1];
			double fTemp866 = fTemp864 * (fTemp864 + fTemp715 / fTemp863) + 1.0;
			double fTemp867 = fTemp865 / fTemp866;
			fRec580[0] = 2.0 * fTemp867 - fRec580[1];
			fRec581[0] = fRec581[1] + 2.0 * (fTemp864 * fTemp865 / fTemp866);
			double fRec582 = fTemp867;
			double fTemp868 = fTemp674 * (fTemp682 * (fTemp684 * (2351.0 * fTemp686 + 4013.0 * fTemp687) + fTemp688 * (3527.0 * fTemp690 + 9672.0 * fTemp691)) + fTemp692 * (fTemp695 * (2351.0 * fTemp697 + 4013.0 * fTemp698) + fTemp699 * (3527.0 * fTemp701 + 9672.0 * fTemp702)));
			double fTemp869 = std::tan(fConst5 * fTemp868);
			double fTemp870 = fTemp869 * (fTemp709 - fRec584[1]) + fRec583[1];
			double fTemp871 = fTemp869 * (fTemp869 + fTemp715 / fTemp868) + 1.0;
			double fTemp872 = fTemp870 / fTemp871;
			fRec583[0] = 2.0 * fTemp872 - fRec583[1];
			fRec584[0] = fRec584[1] + 2.0 * (fTemp869 * fTemp870 / fTemp871);
			double fRec585 = fTemp872;
			fRec445[0] = 0.6366197723675814 * std::atan(0.03125 * (fRec467 * (fTemp682 * (fTemp684 * (fTemp686 + 0.09843679 * fTemp687) + fTemp688 * (fTemp691 + 0.0405712 * fTemp690)) + fTemp692 * (fTemp695 * (fTemp697 + 0.09843679 * fTemp698) + fTemp699 * (fTemp702 + 0.0405712 * fTemp701))) + fRec495 * (fTemp682 * (fTemp684 * (fTemp687 + 0.27707616 * fTemp686) + fTemp688 * (fTemp690 + 0.01216278 * fTemp691)) + fTemp692 * (fTemp695 * (fTemp698 + 0.27707616 * fTemp697) + fTemp699 * (fTemp701 + 0.01216278 * fTemp702))) + fRec498 * (fTemp682 * (fTemp684 * (0.04196492 * fTemp686 + 0.75217775 * fTemp687) + fTemp688 * (0.07116083 * fTemp690 + 0.01835863 * fTemp691)) + fTemp692 * (fTemp695 * (0.04196492 * fTemp697 + 0.75217775 * fTemp698) + fTemp699 * (0.07116083 * fTemp701 + 0.01835863 * fTemp702))) + fRec501 * (fTemp682 * (fTemp684 * (0.02913938 * fTemp686 + 0.03638926 * fTemp687) + fTemp688 * (0.01228042 * fTemp690 + 0.08982961 * fTemp691)) + fTemp692 * (fTemp695 * (0.02913938 * fTemp697 + 0.03638926 * fTemp698) + fTemp699 * (0.01228042 * fTemp701 + 0.08982961 * fTemp702))) + fRec504 * (fTemp682 * (fTemp684 * (0.0550058 * fTemp686 + 0.02121633 * fTemp687) + fTemp688 * (0.2722688 * fTemp690 + 0.27821024 * fTemp691)) + fTemp692 * (fTemp695 * (0.0550058 * fTemp697 + 0.02121633 * fTemp698) + fTemp699 * (0.2722688 * fTemp701 + 0.27821024 * fTemp702))) + fRec507 * (fTemp682 * (fTemp684 * (0.03381146 * fTemp686 + 0.05363475 * fTemp687) + fTemp688 * (0.01573797 * fTemp690 + 0.64427134 * fTemp691)) + fTemp692 * (fTemp695 * (0.03381146 * fTemp697 + 0.05363475 * fTemp698) + fTemp699 * (0.01573797 * fTemp701 + 0.64427134 * fTemp702))) + fRec510 * (fTemp682 * (fTemp684 * (0.01797695 * fTemp686 + 0.0640251 * fTemp687) + fTemp688 * (0.54357606 * fTemp690 + 0.4053105 * fTemp691)) + fTemp692 * (fTemp695 * (0.01797695 * fTemp697 + 0.0640251 * fTemp698) + fTemp699 * (0.54357606 * fTemp701 + 0.4053105 * fTemp702))) + fRec513 * (fTemp682 * (fTemp684 * (0.03067041 * fTemp686 + 0.05785498 * fTemp687) + fTemp688 * (0.09954785 * fTemp690 + 0.62411215 * fTemp691)) + fTemp692 * (fTemp695 * (0.03067041 * fTemp697 + 0.05785498 * fTemp698) + fTemp699 * (0.09954785 * fTemp701 + 0.62411215 * fTemp702))) + fRec516 * (fTemp682 * (fTemp684 * (0.03436227 * fTemp686 + 0.04838698 * fTemp687) + fTemp688 * (0.0250452 * fTemp690 + 0.00707754 * fTemp691)) + fTemp692 * (fTemp695 * (0.03436227 * fTemp697 + 0.04838698 * fTemp698) + fTemp699 * (0.0250452 * fTemp701 + 0.00707754 * fTemp702))) + fRec519 * (fTemp682 * (fTemp684 * (0.01922137 * fTemp686 + 0.00787687 * fTemp687) + fTemp688 * (0.25042786 * fTemp690 + 0.6674602 * fTemp691)) + fTemp692 * (fTemp695 * (0.01922137 * fTemp697 + 0.00787687 * fTemp698) + fTemp699 * (0.25042786 * fTemp701 + 0.6674602 * fTemp702))) + fRec522 * (fTemp682 * (fTemp684 * (0.05522969 * fTemp686 + 0.06051622 * fTemp687) + fTemp688 * (0.02470587 * fTemp690 + 0.01035828 * fTemp691)) + fTemp692 * (fTemp695 * (0.05522969 * fTemp697 + 0.06051622 * fTemp698) + fTemp699 * (0.02470587 * fTemp701 + 0.01035828 * fTemp702))) + fRec525 * (fTemp682 * (fTemp684 * (0.08153769 * fTemp686 + 0.02426847 * fTemp687) + fTemp688 * (0.49828005 * fTemp690 + 0.00749257 * fTemp691)) + fTemp692 * (fTemp695 * (0.08153769 * fTemp697 + 0.02426847 * fTemp698) + fTemp699 * (0.49828005 * fTemp701 + 0.00749257 * fTemp702))) + fRec528 * (fTemp682 * (fTemp684 * (0.00848029 * fTemp686 + 0.01670722 * fTemp687) + fTemp688 * (0.05126037 * fTemp690 + 0.03283333 * fTemp691)) + fTemp692 * (fTemp695 * (0.00848029 * fTemp697 + 0.01670722 * fTemp698) + fTemp699 * (0.05126037 * fTemp701 + 0.03283333 * fTemp702))) + fRec531 * (fTemp682 * (fTemp684 * (0.00496045 * fTemp686 + 0.02143791 * fTemp687) + fTemp688 * (0.07354127 * fTemp690 + 0.01222045 * fTemp691)) + fTemp692 * (fTemp695 * (0.00496045 * fTemp697 + 0.02143791 * fTemp698) + fTemp699 * (0.07354127 * fTemp701 + 0.01222045 * fTemp702))) + fRec534 * (fTemp682 * (fTemp684 * (0.00482074 * fTemp686 + 0.01863539 * fTemp687) + fTemp688 * (0.06191843 * fTemp690 + 0.03888326 * fTemp691)) + fTemp692 * (fTemp695 * (0.00482074 * fTemp697 + 0.01863539 * fTemp698) + fTemp699 * (0.06191843 * fTemp701 + 0.03888326 * fTemp702))) + fRec537 * (fTemp682 * (fTemp684 * (0.02735344 * fTemp686 + 0.02193515 * fTemp687) + fTemp688 * (0.07170723 * fTemp690 + 0.04759307 * fTemp691)) + fTemp692 * (fTemp695 * (0.02735344 * fTemp697 + 0.02193515 * fTemp698) + fTemp699 * (0.07170723 * fTemp701 + 0.04759307 * fTemp702))) + fRec540 * (fTemp682 * (fTemp684 * (0.02222397 * fTemp686 + 0.00886369 * fTemp687) + fTemp688 * (0.02115358 * fTemp690 + 0.02409027 * fTemp691)) + fTemp692 * (fTemp695 * (0.02222397 * fTemp697 + 0.00886369 * fTemp698) + fTemp699 * (0.02115358 * fTemp701 + 0.02409027 * fTemp702))) + fRec543 * (fTemp682 * (fTemp684 * (0.01985851 * fTemp686 + 0.00274825 * fTemp687) + fTemp688 * (0.28175268 * fTemp690 + 0.22375855 * fTemp691)) + fTemp692 * (fTemp695 * (0.01985851 * fTemp697 + 0.00274825 * fTemp698) + fTemp699 * (0.28175268 * fTemp701 + 0.22375855 * fTemp702))) + fRec546 * (fTemp682 * (fTemp684 * (0.03480883 * fTemp686 + 0.02102163 * fTemp687) + fTemp688 * (0.01626654 * fTemp690 + 0.03442368 * fTemp691)) + fTemp692 * (fTemp695 * (0.03480883 * fTemp697 + 0.02102163 * fTemp698) + fTemp699 * (0.01626654 * fTemp701 + 0.03442368 * fTemp702))) + fRec549 * (fTemp682 * (fTemp684 * (0.05834666 * fTemp686 + 0.01772408 * fTemp687) + fTemp688 * (0.14442907 * fTemp690 + 0.07338235 * fTemp691)) + fTemp692 * (fTemp695 * (0.05834666 * fTemp697 + 0.01772408 * fTemp698) + fTemp699 * (0.14442907 * fTemp701 + 0.07338235 * fTemp702))) + fRec552 * (fTemp682 * (fTemp684 * (0.01041008 * fTemp686 + 0.00333966 * fTemp687) + fTemp688 * (0.01134687 * fTemp690 + 0.01369543 * fTemp691)) + fTemp692 * (fTemp695 * (0.01041008 * fTemp697 + 0.00333966 * fTemp698) + fTemp699 * (0.01134687 * fTemp701 + 0.01369543 * fTemp702))) + fRec555 * (fTemp682 * (fTemp684 * (0.00722812 * fTemp686 + 0.00161424 * fTemp687) + fTemp688 * (0.01233555 * fTemp690 + 0.01528356 * fTemp691)) + fTemp692 * (fTemp695 * (0.00722812 * fTemp697 + 0.00161424 * fTemp698) + fTemp699 * (0.01233555 * fTemp701 + 0.01528356 * fTemp702))) + fRec558 * (fTemp682 * (fTemp684 * (0.00729633 * fTemp686 + 0.00190274 * fTemp687) + fTemp688 * (0.00656447 * fTemp690 + 0.00854136 * fTemp691)) + fTemp692 * (fTemp695 * (0.00729633 * fTemp697 + 0.00190274 * fTemp698) + fTemp699 * (0.00656447 * fTemp701 + 0.00854136 * fTemp702))) + fRec561 * (fTemp682 * (fTemp684 * (0.02313585 * fTemp686 + 0.00348521 * fTemp687) + fTemp688 * (0.09585942 * fTemp690 + 0.01776269 * fTemp691)) + fTemp692 * (fTemp695 * (0.02313585 * fTemp697 + 0.00348521 * fTemp698) + fTemp699 * (0.09585942 * fTemp701 + 0.01776269 * fTemp702))) + fRec564 * (fTemp682 * (fTemp684 * (0.04640077 * fTemp686 + 0.01305707 * fTemp687) + fTemp688 * (0.06985491 * fTemp690 + 0.01631748 * fTemp691)) + fTemp692 * (fTemp695 * (0.04640077 * fTemp697 + 0.01305707 * fTemp698) + fTemp699 * (0.06985491 * fTemp701 + 0.01631748 * fTemp702))) + fRec567 * (fTemp682 * (fTemp684 * (0.0121161 * fTemp686 + 0.00709897 * fTemp687) + fTemp688 * (0.0343155 * fTemp690 + 0.02601317 * fTemp691)) + fTemp692 * (fTemp695 * (0.0121161 * fTemp697 + 0.00709897 * fTemp698) + fTemp699 * (0.0343155 * fTemp701 + 0.02601317 * fTemp702))) + fRec570 * (fTemp682 * (fTemp684 * (0.01668042 * fTemp686 + 0.01592137 * fTemp687) + fTemp688 * (0.01093969 * fTemp690 + 0.02061391 * fTemp691)) + fTemp692 * (fTemp695 * (0.01668042 * fTemp697 + 0.01592137 * fTemp698) + fTemp699 * (0.01093969 * fTemp701 + 0.02061391 * fTemp702))) + fRec573 * (fTemp682 * (fTemp684 * (0.00722225 * fTemp686 + 0.00320751 * fTemp687) + fTemp688 * (0.01055565 * fTemp690 + 0.00841917 * fTemp691)) + fTemp692 * (fTemp695 * (0.00722225 * fTemp697 + 0.00320751 * fTemp698) + fTemp699 * (0.01055565 * fTemp701 + 0.00841917 * fTemp702))) + fRec576 * (fTemp682 * (fTemp684 * (0.00592071 * fTemp686 + 0.00126865 * fTemp687) + fTemp688 * (0.03127152 * fTemp690 + 0.02237106 * fTemp691)) + fTemp692 * (fTemp695 * (0.00592071 * fTemp697 + 0.00126865 * fTemp698) + fTemp699 * (0.03127152 * fTemp701 + 0.02237106 * fTemp702))) + fRec579 * (fTemp682 * (fTemp684 * (0.01158114 * fTemp686 + 0.00132724 * fTemp687) + fTemp688 * (0.01587526 * fTemp690 + 0.00969712 * fTemp691)) + fTemp692 * (fTemp695 * (0.01158114 * fTemp697 + 0.00132724 * fTemp698) + fTemp699 * (0.01587526 * fTemp701 + 0.00969712 * fTemp702))) + fRec582 * (fTemp682 * (fTemp684 * (0.00443968 * fTemp686 + 0.00152525 * fTemp687) + fTemp688 * (0.00962998 * fTemp690 + 0.00986048 * fTemp691)) + fTemp692 * (fTemp695 * (0.00443968 * fTemp697 + 0.00152525 * fTemp698) + fTemp699 * (0.00962998 * fTemp701 + 0.00986048 * fTemp702))) + fRec585 * (fTemp682 * (fTemp684 * (0.00282064 * fTemp686 + 0.00097757 * fTemp687) + fTemp688 * (0.0068168 * fTemp690 + 0.01255551 * fTemp691)) + fTemp692 * (fTemp695 * (0.00282064 * fTemp697 + 0.00097757 * fTemp698) + fTemp699 * (0.0068168 * fTemp701 + 0.01255551 * fTemp702)))));
			fRec6[0] = fRec445[0];
			fRec592[0] = std::fmod(fRec592[1], fConst0) + std::fabs(0.1 * fRec591[1]) + 0.1;
			int iTemp873 = (fConst1 * fRec592[0]) < (fConst1 * fRec592[1]);
			iVec34[0] = 199;
			iRec593[0] = (199 - iVec34[1]) % -2147483648 + (12345 - 59 * iRec593[1]);
			fRec591[0] = fRec591[1] * double(iVec0[1] - iTemp873) + (0.0 - 4.656612873077393e-10 * double(iRec593[0])) * double(iTemp873 + iTemp1);
			int iTemp874 = fRec591[0] == fRec591[1];
			fRec590[0] = fRec590[1] * double(iTemp874) + 0.125 * fTemp3 * double(1 - iTemp874);
			double fTemp875 = ((fRec590[0] != fRec590[1]) ? fConst4 : fRec588[1] + -1.0);
			fRec588[0] = fTemp875;
			fRec589[0] = ((fTemp875 > 0.0) ? fRec589[1] + (fRec590[0] - fRec589[1]) / fTemp875 : fRec590[0]);
			double fTemp876 = tanh(fRec13[0] + fSlow4 * std::sin(6.283185307179586 * fRec589[0])) + 1.0;
			fVbargraph28 = FAUSTFLOAT(5e+02 * fTemp876);
			double fTemp877 = (fTemp6 * 0.5 * fTemp876 + 1.0) * fRec586[1];
			double fTemp878 = mydsp_faustpower3_f(fRec587[1]);
			fRec599[0] = std::fmod(fRec599[1], fConst0) + std::fabs(0.1 * fRec598[1]) + 0.1;
			int iTemp879 = (fConst1 * fRec599[0]) < (fConst1 * fRec599[1]);
			iVec35[0] = 179;
			iRec600[0] = (179 - iVec35[1]) % -2147483648 + (12345 - 59 * iRec600[1]);
			fRec598[0] = fRec598[1] * double(iVec0[1] - iTemp879) + (0.0 - 4.656612873077393e-10 * double(iRec600[0])) * double(iTemp879 + iTemp1);
			int iTemp880 = fRec598[0] == fRec598[1];
			fRec597[0] = fRec597[1] * double(iTemp880) + 0.125 * fTemp3 * double(1 - iTemp880);
			double fTemp881 = ((fRec597[0] != fRec597[1]) ? fConst4 : fRec595[1] + -1.0);
			fRec595[0] = fTemp881;
			fRec596[0] = ((fTemp881 > 0.0) ? fRec596[1] + (fRec597[0] - fRec596[1]) / fTemp881 : fRec597[0]);
			double fTemp882 = std::pow(5e+02, tanh(fRec21[0] + fSlow4 * std::sin(6.283185307179586 * fRec596[0])));
			fVbargraph29 = FAUSTFLOAT(1e+03 * fTemp882);
			fRec594[0] = fRec594[1] + fConst1 * fTemp882;
			fRec605[0] = std::fmod(fRec605[1], fConst0) + std::fabs(0.1 * fRec604[1]) + 0.1;
			int iTemp883 = (fConst1 * fRec605[0]) < (fConst1 * fRec605[1]);
			iVec36[0] = 197;
			iRec606[0] = (197 - iVec36[1]) % -2147483648 + (12345 - 59 * iRec606[1]);
			fRec604[0] = fRec604[1] * double(iVec0[1] - iTemp883) + (0.0 - 4.656612873077393e-10 * double(iRec606[0])) * double(iTemp883 + iTemp1);
			int iTemp884 = fRec604[0] == fRec604[1];
			fRec603[0] = fRec603[1] * double(iTemp884) + 0.125 * fTemp3 * double(1 - iTemp884);
			double fTemp885 = ((fRec603[0] != fRec603[1]) ? fConst4 : fRec601[1] + -1.0);
			fRec601[0] = fTemp885;
			fRec602[0] = ((fTemp885 > 0.0) ? fRec602[1] + (fRec603[0] - fRec602[1]) / fTemp885 : fRec603[0]);
			double fTemp886 = tanh(fRec28[0] + fSlow4 * std::sin(6.283185307179586 * fRec602[0])) + 1.0;
			fVbargraph30 = FAUSTFLOAT(5e+02 * fTemp886);
			double fTemp887 = std::cos(fRec594[0]) * 0.5 * fTemp886;
			double fTemp888 = 0.0 - (fTemp877 + fTemp878 + fTemp887);
			fVec37[0] = fTemp888;
			fRec586[0] = fTemp888;
			fRec614[0] = std::fmod(fRec614[1], fConst0) + std::fabs(0.1 * fRec613[1]) + 0.1;
			int iTemp889 = (fConst1 * fRec614[0]) < (fConst1 * fRec614[1]);
			iVec38[0] = 181;
			iRec615[0] = (181 - iVec38[1]) % -2147483648 + (12345 - 59 * iRec615[1]);
			fRec613[0] = fRec613[1] * double(iVec0[1] - iTemp889) + (0.0 - 4.656612873077393e-10 * double(iRec615[0])) * double(iTemp889 + iTemp1);
			int iTemp890 = fRec613[0] == fRec613[1];
			fRec612[0] = fRec612[1] * double(iTemp890) + 0.125 * fTemp3 * double(1 - iTemp890);
			double fTemp891 = ((fRec612[0] != fRec612[1]) ? fConst4 : fRec610[1] + -1.0);
			fRec610[0] = fTemp891;
			fRec611[0] = ((fTemp891 > 0.0) ? fRec611[1] + (fRec612[0] - fRec611[1]) / fTemp891 : fRec612[0]);
			double fTemp892 = 0.45 * (tanh(fRec38[0] + fSlow4 * std::sin(6.283185307179586 * fRec611[0])) + 1.0) + 0.1;
			fVbargraph31 = FAUSTFLOAT(1e+03 * fTemp892);
			double fTemp893 = fTemp892;
			fRec620[0] = std::fmod(fRec620[1], fConst0) + std::fabs(0.1 * fRec619[1]) + 0.1;
			int iTemp894 = (fConst1 * fRec620[0]) < (fConst1 * fRec620[1]);
			iVec39[0] = 191;
			iRec621[0] = (191 - iVec39[1]) % -2147483648 + (12345 - 59 * iRec621[1]);
			fRec619[0] = fRec619[1] * double(iVec0[1] - iTemp894) + (0.0 - 4.656612873077393e-10 * double(iRec621[0])) * double(iTemp894 + iTemp1);
			int iTemp895 = fRec619[0] == fRec619[1];
			fRec618[0] = fRec618[1] * double(iTemp895) + 0.125 * fTemp3 * double(1 - iTemp895);
			double fTemp896 = ((fRec618[0] != fRec618[1]) ? fConst4 : fRec616[1] + -1.0);
			fRec616[0] = fTemp896;
			fRec617[0] = ((fTemp896 > 0.0) ? fRec617[1] + (fRec618[0] - fRec617[1]) / fTemp896 : fRec618[0]);
			double fTemp897 = tanh(fRec45[0] + fSlow4 * std::sin(6.283185307179586 * fRec617[0])) + 1.0;
			fVbargraph32 = FAUSTFLOAT(5e+02 * fTemp897);
			double fTemp898 = 4.0 * 0.5 * fTemp897;
			int iTemp899 = int(fTemp898);
			double fTemp900 = double(iTemp899);
			double fTemp901 = fTemp900 + (1.0 - fTemp898);
			int iTemp902 = iTemp899 >= 2;
			double fTemp903 = double(1 - iTemp902);
			int iTemp904 = iTemp899 >= 1;
			double fTemp905 = double(1 - iTemp904);
			double fTemp906 = double(iTemp904);
			double fTemp907 = double(iTemp902);
			int iTemp908 = iTemp899 >= 3;
			double fTemp909 = double(1 - iTemp908);
			double fTemp910 = double(iTemp908);
			double fTemp911 = fTemp898 - fTemp900;
			int iTemp912 = iTemp899 + 1;
			int iTemp913 = iTemp912 >= 2;
			double fTemp914 = double(1 - iTemp913);
			int iTemp915 = iTemp912 >= 1;
			double fTemp916 = double(1 - iTemp915);
			double fTemp917 = double(iTemp915);
			double fTemp918 = double(iTemp913);
			int iTemp919 = iTemp912 >= 3;
			double fTemp920 = double(1 - iTemp919);
			double fTemp921 = double(iTemp919);
			double fTemp922 = fTemp893 * (fTemp901 * (fTemp903 * (392.0 * fTemp905 + 537.0 * fTemp906) + fTemp907 * (441.0 * fTemp909 + 439.0 * fTemp910)) + fTemp911 * (fTemp914 * (392.0 * fTemp916 + 537.0 * fTemp917) + fTemp918 * (441.0 * fTemp920 + 439.0 * fTemp921)));
			double fTemp923 = std::tan(fConst5 * fTemp922);
			fRec622[0] = 0.995 * fRec622[1] - (fTemp887 + fTemp878 + fTemp877 + fVec37[1]);
			fRec627[0] = std::fmod(fRec627[1], fConst0) + std::fabs(0.1 * fRec626[1]) + 0.1;
			int iTemp924 = (fConst1 * fRec627[0]) < (fConst1 * fRec627[1]);
			iVec40[0] = 211;
			iRec628[0] = (211 - iVec40[1]) % -2147483648 + (12345 - 59 * iRec628[1]);
			fRec626[0] = fRec626[1] * double(iVec0[1] - iTemp924) + (0.0 - 4.656612873077393e-10 * double(iRec628[0])) * double(iTemp924 + iTemp1);
			int iTemp925 = fRec626[0] == fRec626[1];
			fRec625[0] = fRec625[1] * double(iTemp925) + 0.125 * fTemp3 * double(1 - iTemp925);
			double fTemp926 = ((fRec625[0] != fRec625[1]) ? fConst4 : fRec623[1] + -1.0);
			fRec623[0] = fTemp926;
			fRec624[0] = ((fTemp926 > 0.0) ? fRec624[1] + (fRec625[0] - fRec624[1]) / fTemp926 : fRec625[0]);
			double fTemp927 = std::pow(1e+03, tanh(fRec53[0] + fSlow4 * std::sin(6.283185307179586 * fRec624[0])));
			fVbargraph33 = FAUSTFLOAT(fTemp927);
			double fTemp928 = fRec622[0] * fTemp927;
			double fTemp929 = fTemp923 * (fTemp928 - fRec608[1]) + fRec607[1];
			fRec633[0] = std::fmod(fRec633[1], fConst0) + std::fabs(0.1 * fRec632[1]) + 0.1;
			int iTemp930 = (fConst1 * fRec633[0]) < (fConst1 * fRec633[1]);
			iVec41[0] = 193;
			iRec634[0] = (193 - iVec41[1]) % -2147483648 + (12345 - 59 * iRec634[1]);
			fRec632[0] = fRec632[1] * double(iVec0[1] - iTemp930) + (0.0 - 4.656612873077393e-10 * double(iRec634[0])) * double(iTemp930 + iTemp1);
			int iTemp931 = fRec632[0] == fRec632[1];
			fRec631[0] = fRec631[1] * double(iTemp931) + 0.125 * fTemp3 * double(1 - iTemp931);
			double fTemp932 = ((fRec631[0] != fRec631[1]) ? fConst4 : fRec629[1] + -1.0);
			fRec629[0] = fTemp932;
			fRec630[0] = ((fTemp932 > 0.0) ? fRec630[1] + (fRec631[0] - fRec630[1]) / fTemp932 : fRec631[0]);
			double fTemp933 = std::pow(1e+02, tanh(fRec60[0] + fSlow4 * std::sin(6.283185307179586 * fRec630[0])));
			fVbargraph34 = FAUSTFLOAT(fTemp933);
			double fTemp934 = std::max<double>(2.220446049250313e-16, fTemp933);
			double fTemp935 = fTemp923 * (fTemp923 + fTemp934 / fTemp922) + 1.0;
			double fTemp936 = fTemp929 / fTemp935;
			fRec607[0] = 2.0 * fTemp936 - fRec607[1];
			fRec608[0] = fRec608[1] + 2.0 * (fTemp923 * fTemp929 / fTemp935);
			double fRec609 = fTemp936;
			double fTemp937 = fTemp893 * (fTemp901 * (fTemp903 * (326.0 * fTemp905 + 489.0 * fTemp906) + fTemp907 * (367.0 * fTemp909 + 368.0 * fTemp910)) + fTemp911 * (fTemp914 * (326.0 * fTemp916 + 489.0 * fTemp917) + fTemp918 * (367.0 * fTemp920 + 368.0 * fTemp921)));
			double fTemp938 = std::tan(fConst5 * fTemp937);
			double fTemp939 = fTemp938 * (fTemp928 - fRec636[1]) + fRec635[1];
			double fTemp940 = fTemp938 * (fTemp938 + fTemp934 / fTemp937) + 1.0;
			double fTemp941 = fTemp939 / fTemp940;
			fRec635[0] = 2.0 * fTemp941 - fRec635[1];
			fRec636[0] = fRec636[1] + 2.0 * (fTemp938 * fTemp939 / fTemp940);
			double fRec637 = fTemp941;
			double fTemp942 = fTemp893 * (fTemp901 * (fTemp903 * (261.0 * fTemp905 + 391.0 * fTemp906) + fTemp907 * (294.0 * fTemp909 + 309.0 * fTemp910)) + fTemp911 * (fTemp914 * (261.0 * fTemp916 + 391.0 * fTemp917) + fTemp918 * (294.0 * fTemp920 + 309.0 * fTemp921)));
			double fTemp943 = std::tan(fConst5 * fTemp942);
			double fTemp944 = fTemp943 * (fTemp928 - fRec639[1]) + fRec638[1];
			double fTemp945 = fTemp943 * (fTemp943 + fTemp934 / fTemp942) + 1.0;
			double fTemp946 = fTemp944 / fTemp945;
			fRec638[0] = 2.0 * fTemp946 - fRec638[1];
			fRec639[0] = fRec639[1] + 2.0 * (fTemp943 * fTemp944 / fTemp945);
			double fRec640 = fTemp946;
			double fTemp947 = fTemp893 * (fTemp901 * (fTemp903 * (196.0 * fTemp905 + 293.0 * fTemp906) + fTemp907 * (203.0 * fTemp909 + 2.2e+02 * fTemp910)) + fTemp911 * (fTemp914 * (196.0 * fTemp916 + 293.0 * fTemp917) + fTemp918 * (203.0 * fTemp920 + 2.2e+02 * fTemp921)));
			double fTemp948 = std::tan(fConst5 * fTemp947);
			double fTemp949 = fTemp948 * (fTemp928 - fRec642[1]) + fRec641[1];
			double fTemp950 = fTemp948 * (fTemp948 + fTemp934 / fTemp947) + 1.0;
			double fTemp951 = fTemp949 / fTemp950;
			fRec641[0] = 2.0 * fTemp951 - fRec641[1];
			fRec642[0] = fRec642[1] + 2.0 * (fTemp948 * fTemp949 / fTemp950);
			double fRec643 = fTemp951;
			double fTemp952 = fTemp893 * (fTemp901 * (fTemp903 * (131.0 * fTemp905 + 195.0 * fTemp906) + fTemp907 * (147.0 * fTemp909 + 1.3e+02 * fTemp910)) + fTemp911 * (fTemp914 * (131.0 * fTemp916 + 195.0 * fTemp917) + fTemp918 * (147.0 * fTemp920 + 1.3e+02 * fTemp921)));
			double fTemp953 = std::tan(fConst5 * fTemp952);
			double fTemp954 = fTemp953 * (fTemp928 - fRec645[1]) + fRec644[1];
			double fTemp955 = fTemp953 * (fTemp953 + fTemp934 / fTemp952) + 1.0;
			double fTemp956 = fTemp954 / fTemp955;
			fRec644[0] = 2.0 * fTemp956 - fRec644[1];
			fRec645[0] = fRec645[1] + 2.0 * (fTemp953 * fTemp954 / fTemp955);
			double fRec646 = fTemp956;
			double fTemp957 = (fTemp901 * ((65.0 * fTemp905 + 98.0 * fTemp906) * fTemp903 + (53.0 * fTemp909 + 5e+01 * fTemp910) * fTemp907) + fTemp911 * ((65.0 * fTemp916 + 98.0 * fTemp917) * fTemp914 + (53.0 * fTemp920 + 5e+01 * fTemp921) * fTemp918)) * fTemp893;
			double fTemp958 = std::tan(fConst5 * fTemp957);
			double fTemp959 = fTemp958 * (fTemp928 - fRec648[1]) + fRec647[1];
			double fTemp960 = fTemp958 * (fTemp958 + fTemp934 / fTemp957) + 1.0;
			double fTemp961 = fTemp959 / fTemp960;
			fRec647[0] = 2.0 * fTemp961 - fRec647[1];
			fRec648[0] = fRec648[1] + 2.0 * (fTemp958 * fTemp959 / fTemp960);
			double fRec649 = fTemp961;
			double fTemp962 = fTemp893 * (fTemp901 * (fTemp903 * (914.0 * fTemp905 + 1272.0 * fTemp906) + fTemp907 * (1078.0 * fTemp909 + 1978.0 * fTemp910)) + fTemp911 * (fTemp914 * (914.0 * fTemp916 + 1272.0 * fTemp917) + fTemp918 * (1078.0 * fTemp920 + 1978.0 * fTemp921)));
			double fTemp963 = std::tan(fConst5 * fTemp962);
			double fTemp964 = fTemp963 * (fTemp928 - fRec651[1]) + fRec650[1];
			double fTemp965 = fTemp963 * (fTemp963 + fTemp934 / fTemp962) + 1.0;
			double fTemp966 = fTemp964 / fTemp965;
			fRec650[0] = 2.0 * fTemp966 - fRec650[1];
			fRec651[0] = fRec651[1] + 2.0 * (fTemp963 * fTemp964 / fTemp965);
			double fRec652 = fTemp966;
			double fTemp967 = fTemp893 * (fTemp901 * (fTemp903 * (849.0 * fTemp905 + 1174.0 * fTemp906) + fTemp907 * (1028.0 * fTemp909 + 1759.0 * fTemp910)) + fTemp911 * (fTemp914 * (849.0 * fTemp916 + 1174.0 * fTemp917) + fTemp918 * (1028.0 * fTemp920 + 1759.0 * fTemp921)));
			double fTemp968 = std::tan(fConst5 * fTemp967);
			double fTemp969 = fTemp968 * (fTemp928 - fRec654[1]) + fRec653[1];
			double fTemp970 = fTemp968 * (fTemp968 + fTemp934 / fTemp967) + 1.0;
			double fTemp971 = fTemp969 / fTemp970;
			fRec653[0] = 2.0 * fTemp971 - fRec653[1];
			fRec654[0] = fRec654[1] + 2.0 * (fTemp968 * fTemp969 / fTemp970);
			double fRec655 = fTemp971;
			double fTemp972 = fTemp893 * (fTemp901 * (fTemp903 * (784.0 * fTemp905 + 1076.0 * fTemp906) + fTemp907 * (961.0 * fTemp909 + 1539.0 * fTemp910)) + fTemp911 * (fTemp914 * (784.0 * fTemp916 + 1076.0 * fTemp917) + fTemp918 * (961.0 * fTemp920 + 1539.0 * fTemp921)));
			double fTemp973 = std::tan(fConst5 * fTemp972);
			double fTemp974 = fTemp973 * (fTemp928 - fRec657[1]) + fRec656[1];
			double fTemp975 = fTemp973 * (fTemp973 + fTemp934 / fTemp972) + 1.0;
			double fTemp976 = fTemp974 / fTemp975;
			fRec656[0] = 2.0 * fTemp976 - fRec656[1];
			fRec657[0] = fRec657[1] + 2.0 * (fTemp973 * fTemp974 / fTemp975);
			double fRec658 = fTemp976;
			double fTemp977 = fTemp893 * (fTemp901 * (fTemp903 * (718.0 * fTemp905 + 979.0 * fTemp906) + fTemp907 * (882.0 * fTemp909 + 1319.0 * fTemp910)) + fTemp911 * (fTemp914 * (718.0 * fTemp916 + 979.0 * fTemp917) + fTemp918 * (882.0 * fTemp920 + 1319.0 * fTemp921)));
			double fTemp978 = std::tan(fConst5 * fTemp977);
			double fTemp979 = fTemp978 * (fTemp928 - fRec660[1]) + fRec659[1];
			double fTemp980 = fTemp978 * (fTemp978 + fTemp934 / fTemp977) + 1.0;
			double fTemp981 = fTemp979 / fTemp980;
			fRec659[0] = 2.0 * fTemp981 - fRec659[1];
			fRec660[0] = fRec660[1] + 2.0 * (fTemp978 * fTemp979 / fTemp980);
			double fRec661 = fTemp981;
			double fTemp982 = fTemp893 * (fTemp901 * (fTemp903 * (653.0 * fTemp905 + 8.8e+02 * fTemp906) + fTemp907 * (785.0 * fTemp909 + 1099.0 * fTemp910)) + fTemp911 * (fTemp914 * (653.0 * fTemp916 + 8.8e+02 * fTemp917) + fTemp918 * (785.0 * fTemp920 + 1099.0 * fTemp921)));
			double fTemp983 = std::tan(fConst5 * fTemp982);
			double fTemp984 = fTemp983 * (fTemp928 - fRec663[1]) + fRec662[1];
			double fTemp985 = fTemp983 * (fTemp983 + fTemp934 / fTemp982) + 1.0;
			double fTemp986 = fTemp984 / fTemp985;
			fRec662[0] = 2.0 * fTemp986 - fRec662[1];
			fRec663[0] = fRec663[1] + 2.0 * (fTemp983 * fTemp984 / fTemp985);
			double fRec664 = fTemp986;
			double fTemp987 = fTemp893 * (fTemp901 * (fTemp903 * (588.0 * fTemp905 + 783.0 * fTemp906) + fTemp907 * (735.0 * fTemp909 + 879.0 * fTemp910)) + fTemp911 * (fTemp914 * (588.0 * fTemp916 + 783.0 * fTemp917) + fTemp918 * (735.0 * fTemp920 + 879.0 * fTemp921)));
			double fTemp988 = std::tan(fConst5 * fTemp987);
			double fTemp989 = fTemp988 * (fTemp928 - fRec666[1]) + fRec665[1];
			double fTemp990 = fTemp988 * (fTemp988 + fTemp934 / fTemp987) + 1.0;
			double fTemp991 = fTemp989 / fTemp990;
			fRec665[0] = 2.0 * fTemp991 - fRec665[1];
			fRec666[0] = fRec666[1] + 2.0 * (fTemp988 * fTemp989 / fTemp990);
			double fRec667 = fTemp991;
			double fTemp992 = fTemp893 * (fTemp901 * (fTemp903 * (522.0 * fTemp905 + 685.0 * fTemp906) + fTemp907 * (588.0 * fTemp909 + 659.0 * fTemp910)) + fTemp911 * (fTemp914 * (522.0 * fTemp916 + 685.0 * fTemp917) + fTemp918 * (588.0 * fTemp920 + 659.0 * fTemp921)));
			double fTemp993 = std::tan(fConst5 * fTemp992);
			double fTemp994 = fTemp993 * (fTemp928 - fRec669[1]) + fRec668[1];
			double fTemp995 = fTemp993 * (fTemp993 + fTemp934 / fTemp992) + 1.0;
			double fTemp996 = fTemp994 / fTemp995;
			fRec668[0] = 2.0 * fTemp996 - fRec668[1];
			fRec669[0] = fRec669[1] + 2.0 * (fTemp993 * fTemp994 / fTemp995);
			double fRec670 = fTemp996;
			double fTemp997 = fTemp893 * (fTemp901 * (fTemp903 * (457.0 * fTemp905 + 587.0 * fTemp906) + fTemp907 * (534.0 * fTemp909 + 538.0 * fTemp910)) + fTemp911 * (fTemp914 * (457.0 * fTemp916 + 587.0 * fTemp917) + fTemp918 * (534.0 * fTemp920 + 538.0 * fTemp921)));
			double fTemp998 = std::tan(fConst5 * fTemp997);
			double fTemp999 = fTemp998 * (fTemp928 - fRec672[1]) + fRec671[1];
			double fTemp1000 = fTemp998 * (fTemp998 + fTemp934 / fTemp997) + 1.0;
			double fTemp1001 = fTemp999 / fTemp1000;
			fRec671[0] = 2.0 * fTemp1001 - fRec671[1];
			fRec672[0] = fRec672[1] + 2.0 * (fTemp998 * fTemp999 / fTemp1000);
			double fRec673 = fTemp1001;
			double fTemp1002 = fTemp893 * (fTemp901 * (fTemp903 * (1502.0 * fTemp905 + 2056.0 * fTemp906) + fTemp907 * (1.91e+03 * fTemp909 + 3737.0 * fTemp910)) + fTemp911 * (fTemp914 * (1502.0 * fTemp916 + 2056.0 * fTemp917) + fTemp918 * (1.91e+03 * fTemp920 + 3737.0 * fTemp921)));
			double fTemp1003 = std::tan(fConst5 * fTemp1002);
			double fTemp1004 = fTemp1003 * (fTemp928 - fRec675[1]) + fRec674[1];
			double fTemp1005 = fTemp1003 * (fTemp1003 + fTemp934 / fTemp1002) + 1.0;
			double fTemp1006 = fTemp1004 / fTemp1005;
			fRec674[0] = 2.0 * fTemp1006 - fRec674[1];
			fRec675[0] = fRec675[1] + 2.0 * (fTemp1003 * fTemp1004 / fTemp1005);
			double fRec676 = fTemp1006;
			double fTemp1007 = fTemp893 * (fTemp901 * (fTemp903 * (1371.0 * fTemp905 + 1958.0 * fTemp906) + fTemp907 * (1855.0 * fTemp909 + 3517.0 * fTemp910)) + fTemp911 * (fTemp914 * (1371.0 * fTemp916 + 1958.0 * fTemp917) + fTemp918 * (1855.0 * fTemp920 + 3517.0 * fTemp921)));
			double fTemp1008 = std::tan(fConst5 * fTemp1007);
			double fTemp1009 = fTemp1008 * (fTemp928 - fRec678[1]) + fRec677[1];
			double fTemp1010 = fTemp1008 * (fTemp1008 + fTemp934 / fTemp1007) + 1.0;
			double fTemp1011 = fTemp1009 / fTemp1010;
			fRec677[0] = 2.0 * fTemp1011 - fRec677[1];
			fRec678[0] = fRec678[1] + 2.0 * (fTemp1008 * fTemp1009 / fTemp1010);
			double fRec679 = fTemp1011;
			double fTemp1012 = fTemp893 * (fTemp901 * (fTemp903 * (1306.0 * fTemp905 + 1.86e+03 * fTemp906) + fTemp907 * (1764.0 * fTemp909 + 3298.0 * fTemp910)) + fTemp911 * (fTemp914 * (1306.0 * fTemp916 + 1.86e+03 * fTemp917) + fTemp918 * (1764.0 * fTemp920 + 3298.0 * fTemp921)));
			double fTemp1013 = std::tan(fConst5 * fTemp1012);
			double fTemp1014 = fTemp1013 * (fTemp928 - fRec681[1]) + fRec680[1];
			double fTemp1015 = fTemp1013 * (fTemp1013 + fTemp934 / fTemp1012) + 1.0;
			double fTemp1016 = fTemp1014 / fTemp1015;
			fRec680[0] = 2.0 * fTemp1016 - fRec680[1];
			fRec681[0] = fRec681[1] + 2.0 * (fTemp1013 * fTemp1014 / fTemp1015);
			double fRec682 = fTemp1016;
			double fTemp1017 = fTemp893 * (fTemp901 * (fTemp903 * (1241.0 * fTemp905 + 1762.0 * fTemp906) + fTemp907 * (1617.0 * fTemp909 + 3078.0 * fTemp910)) + fTemp911 * (fTemp914 * (1241.0 * fTemp916 + 1762.0 * fTemp917) + fTemp918 * (1617.0 * fTemp920 + 3078.0 * fTemp921)));
			double fTemp1018 = std::tan(fConst5 * fTemp1017);
			double fTemp1019 = fTemp1018 * (fTemp928 - fRec684[1]) + fRec683[1];
			double fTemp1020 = fTemp1018 * (fTemp1018 + fTemp934 / fTemp1017) + 1.0;
			double fTemp1021 = fTemp1019 / fTemp1020;
			fRec683[0] = 2.0 * fTemp1021 - fRec683[1];
			fRec684[0] = fRec684[1] + 2.0 * (fTemp1018 * fTemp1019 / fTemp1020);
			double fRec685 = fTemp1021;
			double fTemp1022 = fTemp893 * (fTemp901 * (fTemp903 * (1175.0 * fTemp905 + 1664.0 * fTemp906) + fTemp907 * (1.47e+03 * fTemp909 + 2858.0 * fTemp910)) + fTemp911 * (fTemp914 * (1175.0 * fTemp916 + 1664.0 * fTemp917) + fTemp918 * (1.47e+03 * fTemp920 + 2858.0 * fTemp921)));
			double fTemp1023 = std::tan(fConst5 * fTemp1022);
			double fTemp1024 = fTemp1023 * (fTemp928 - fRec687[1]) + fRec686[1];
			double fTemp1025 = fTemp1023 * (fTemp1023 + fTemp934 / fTemp1022) + 1.0;
			double fTemp1026 = fTemp1024 / fTemp1025;
			fRec686[0] = 2.0 * fTemp1026 - fRec686[1];
			fRec687[0] = fRec687[1] + 2.0 * (fTemp1023 * fTemp1024 / fTemp1025);
			double fRec688 = fTemp1026;
			double fTemp1027 = fTemp893 * (fTemp901 * (fTemp903 * (1.11e+03 * fTemp905 + 1566.0 * fTemp906) + fTemp907 * (1323.0 * fTemp909 + 2638.0 * fTemp910)) + fTemp911 * (fTemp914 * (1.11e+03 * fTemp916 + 1566.0 * fTemp917) + fTemp918 * (1323.0 * fTemp920 + 2638.0 * fTemp921)));
			double fTemp1028 = std::tan(fConst5 * fTemp1027);
			double fTemp1029 = fTemp1028 * (fTemp928 - fRec690[1]) + fRec689[1];
			double fTemp1030 = fTemp1028 * (fTemp1028 + fTemp934 / fTemp1027) + 1.0;
			double fTemp1031 = fTemp1029 / fTemp1030;
			fRec689[0] = 2.0 * fTemp1031 - fRec689[1];
			fRec690[0] = fRec690[1] + 2.0 * (fTemp1028 * fTemp1029 / fTemp1030);
			double fRec691 = fTemp1031;
			double fTemp1032 = fTemp893 * (fTemp901 * (fTemp903 * (1045.0 * fTemp905 + 1468.0 * fTemp906) + fTemp907 * (1269.0 * fTemp909 + 2418.0 * fTemp910)) + fTemp911 * (fTemp914 * (1045.0 * fTemp916 + 1468.0 * fTemp917) + fTemp918 * (1269.0 * fTemp920 + 2418.0 * fTemp921)));
			double fTemp1033 = std::tan(fConst5 * fTemp1032);
			double fTemp1034 = fTemp1033 * (fTemp928 - fRec693[1]) + fRec692[1];
			double fTemp1035 = fTemp1033 * (fTemp1033 + fTemp934 / fTemp1032) + 1.0;
			double fTemp1036 = fTemp1034 / fTemp1035;
			fRec692[0] = 2.0 * fTemp1036 - fRec692[1];
			fRec693[0] = fRec693[1] + 2.0 * (fTemp1033 * fTemp1034 / fTemp1035);
			double fRec694 = fTemp1036;
			double fTemp1037 = fTemp893 * (fTemp901 * (fTemp903 * (979.0 * fTemp905 + 1371.0 * fTemp906) + fTemp907 * (1175.0 * fTemp909 + 2198.0 * fTemp910)) + fTemp911 * (fTemp914 * (979.0 * fTemp916 + 1371.0 * fTemp917) + fTemp918 * (1175.0 * fTemp920 + 2198.0 * fTemp921)));
			double fTemp1038 = std::tan(fConst5 * fTemp1037);
			double fTemp1039 = fTemp1038 * (fTemp928 - fRec696[1]) + fRec695[1];
			double fTemp1040 = fTemp1038 * (fTemp1038 + fTemp934 / fTemp1037) + 1.0;
			double fTemp1041 = fTemp1039 / fTemp1040;
			fRec695[0] = 2.0 * fTemp1041 - fRec695[1];
			fRec696[0] = fRec696[1] + 2.0 * (fTemp1038 * fTemp1039 / fTemp1040);
			double fRec697 = fTemp1041;
			double fTemp1042 = fTemp893 * (fTemp901 * (fTemp903 * (1959.0 * fTemp905 + 2937.0 * fTemp906) + fTemp907 * (2792.0 * fTemp909 + 7035.0 * fTemp910)) + fTemp911 * (fTemp914 * (1959.0 * fTemp916 + 2937.0 * fTemp917) + fTemp918 * (2792.0 * fTemp920 + 7035.0 * fTemp921)));
			double fTemp1043 = std::tan(fConst5 * fTemp1042);
			double fTemp1044 = fTemp1043 * (fTemp928 - fRec699[1]) + fRec698[1];
			double fTemp1045 = fTemp1043 * (fTemp1043 + fTemp934 / fTemp1042) + 1.0;
			double fTemp1046 = fTemp1044 / fTemp1045;
			fRec698[0] = 2.0 * fTemp1046 - fRec698[1];
			fRec699[0] = fRec699[1] + 2.0 * (fTemp1043 * fTemp1044 / fTemp1045);
			double fRec700 = fTemp1046;
			double fTemp1047 = fTemp893 * (fTemp901 * (fTemp903 * (1894.0 * fTemp905 + 2839.0 * fTemp906) + fTemp907 * (2645.0 * fTemp909 + 5717.0 * fTemp910)) + fTemp911 * (fTemp914 * (1894.0 * fTemp916 + 2839.0 * fTemp917) + fTemp918 * (2645.0 * fTemp920 + 5717.0 * fTemp921)));
			double fTemp1048 = std::tan(fConst5 * fTemp1047);
			double fTemp1049 = fTemp1048 * (fTemp928 - fRec702[1]) + fRec701[1];
			double fTemp1050 = fTemp1048 * (fTemp1048 + fTemp934 / fTemp1047) + 1.0;
			double fTemp1051 = fTemp1049 / fTemp1050;
			fRec701[0] = 2.0 * fTemp1051 - fRec701[1];
			fRec702[0] = fRec702[1] + 2.0 * (fTemp1048 * fTemp1049 / fTemp1050);
			double fRec703 = fTemp1051;
			double fTemp1052 = fTemp893 * (fTemp901 * (fTemp903 * (1828.0 * fTemp905 + 2741.0 * fTemp906) + fTemp907 * (2498.0 * fTemp909 + 5496.0 * fTemp910)) + fTemp911 * (fTemp914 * (1828.0 * fTemp916 + 2741.0 * fTemp917) + fTemp918 * (2498.0 * fTemp920 + 5496.0 * fTemp921)));
			double fTemp1053 = std::tan(fConst5 * fTemp1052);
			double fTemp1054 = fTemp1053 * (fTemp928 - fRec705[1]) + fRec704[1];
			double fTemp1055 = fTemp1053 * (fTemp1053 + fTemp934 / fTemp1052) + 1.0;
			double fTemp1056 = fTemp1054 / fTemp1055;
			fRec704[0] = 2.0 * fTemp1056 - fRec704[1];
			fRec705[0] = fRec705[1] + 2.0 * (fTemp1053 * fTemp1054 / fTemp1055);
			double fRec706 = fTemp1056;
			double fTemp1057 = fTemp893 * (fTemp901 * (fTemp903 * (1763.0 * fTemp905 + 2643.0 * fTemp906) + fTemp907 * (2351.0 * fTemp909 + 5056.0 * fTemp910)) + fTemp911 * (fTemp914 * (1763.0 * fTemp916 + 2643.0 * fTemp917) + fTemp918 * (2351.0 * fTemp920 + 5056.0 * fTemp921)));
			double fTemp1058 = std::tan(fConst5 * fTemp1057);
			double fTemp1059 = fTemp1058 * (fTemp928 - fRec708[1]) + fRec707[1];
			double fTemp1060 = fTemp1058 * (fTemp1058 + fTemp934 / fTemp1057) + 1.0;
			double fTemp1061 = fTemp1059 / fTemp1060;
			fRec707[0] = 2.0 * fTemp1061 - fRec707[1];
			fRec708[0] = fRec708[1] + 2.0 * (fTemp1058 * fTemp1059 / fTemp1060);
			double fRec709 = fTemp1061;
			double fTemp1062 = fTemp893 * (fTemp901 * (fTemp903 * (1698.0 * fTemp905 + 2349.0 * fTemp906) + fTemp907 * (2273.0 * fTemp909 + 4617.0 * fTemp910)) + fTemp911 * (fTemp914 * (1698.0 * fTemp916 + 2349.0 * fTemp917) + fTemp918 * (2273.0 * fTemp920 + 4617.0 * fTemp921)));
			double fTemp1063 = std::tan(fConst5 * fTemp1062);
			double fTemp1064 = fTemp1063 * (fTemp928 - fRec711[1]) + fRec710[1];
			double fTemp1065 = fTemp1063 * (fTemp1063 + fTemp934 / fTemp1062) + 1.0;
			double fTemp1066 = fTemp1064 / fTemp1065;
			fRec710[0] = 2.0 * fTemp1066 - fRec710[1];
			fRec711[0] = fRec711[1] + 2.0 * (fTemp1063 * fTemp1064 / fTemp1065);
			double fRec712 = fTemp1066;
			double fTemp1067 = fTemp893 * (fTemp901 * (fTemp903 * (1632.0 * fTemp905 + 2252.0 * fTemp906) + fTemp907 * (2204.0 * fTemp909 + 4177.0 * fTemp910)) + fTemp911 * (fTemp914 * (1632.0 * fTemp916 + 2252.0 * fTemp917) + fTemp918 * (2204.0 * fTemp920 + 4177.0 * fTemp921)));
			double fTemp1068 = std::tan(fConst5 * fTemp1067);
			double fTemp1069 = fTemp1068 * (fTemp928 - fRec714[1]) + fRec713[1];
			double fTemp1070 = fTemp1068 * (fTemp1068 + fTemp934 / fTemp1067) + 1.0;
			double fTemp1071 = fTemp1069 / fTemp1070;
			fRec713[0] = 2.0 * fTemp1071 - fRec713[1];
			fRec714[0] = fRec714[1] + 2.0 * (fTemp1068 * fTemp1069 / fTemp1070);
			double fRec715 = fTemp1071;
			double fTemp1072 = fTemp893 * (fTemp901 * (fTemp903 * (1567.0 * fTemp905 + 2153.0 * fTemp906) + fTemp907 * (2054.0 * fTemp909 + 3957.0 * fTemp910)) + fTemp911 * (fTemp914 * (1567.0 * fTemp916 + 2153.0 * fTemp917) + fTemp918 * (2054.0 * fTemp920 + 3957.0 * fTemp921)));
			double fTemp1073 = std::tan(fConst5 * fTemp1072);
			double fTemp1074 = fTemp1073 * (fTemp928 - fRec717[1]) + fRec716[1];
			double fTemp1075 = fTemp1073 * (fTemp1073 + fTemp934 / fTemp1072) + 1.0;
			double fTemp1076 = fTemp1074 / fTemp1075;
			fRec716[0] = 2.0 * fTemp1076 - fRec716[1];
			fRec717[0] = fRec717[1] + 2.0 * (fTemp1073 * fTemp1074 / fTemp1075);
			double fRec718 = fTemp1076;
			double fTemp1077 = fTemp893 * (fTemp901 * (fTemp903 * (2024.0 * fTemp905 + 3.23e+03 * fTemp906) + fTemp907 * (3233.0 * fTemp909 + 7255.0 * fTemp910)) + fTemp911 * (fTemp914 * (2024.0 * fTemp916 + 3.23e+03 * fTemp917) + fTemp918 * (3233.0 * fTemp920 + 7255.0 * fTemp921)));
			double fTemp1078 = std::tan(fConst5 * fTemp1077);
			double fTemp1079 = fTemp1078 * (fTemp928 - fRec720[1]) + fRec719[1];
			double fTemp1080 = fTemp1078 * (fTemp1078 + fTemp934 / fTemp1077) + 1.0;
			double fTemp1081 = fTemp1079 / fTemp1080;
			fRec719[0] = 2.0 * fTemp1081 - fRec719[1];
			fRec720[0] = fRec720[1] + 2.0 * (fTemp1078 * fTemp1079 / fTemp1080);
			double fRec721 = fTemp1081;
			double fTemp1082 = fTemp893 * (fTemp901 * (fTemp903 * (2089.0 * fTemp905 + 3328.0 * fTemp906) + fTemp907 * (3.38e+03 * fTemp909 + 8574.0 * fTemp910)) + fTemp911 * (fTemp914 * (2089.0 * fTemp916 + 3328.0 * fTemp917) + fTemp918 * (3.38e+03 * fTemp920 + 8574.0 * fTemp921)));
			double fTemp1083 = std::tan(fConst5 * fTemp1082);
			double fTemp1084 = fTemp1083 * (fTemp928 - fRec723[1]) + fRec722[1];
			double fTemp1085 = fTemp1083 * (fTemp1083 + fTemp934 / fTemp1082) + 1.0;
			double fTemp1086 = fTemp1084 / fTemp1085;
			fRec722[0] = 2.0 * fTemp1086 - fRec722[1];
			fRec723[0] = fRec723[1] + 2.0 * (fTemp1083 * fTemp1084 / fTemp1085);
			double fRec724 = fTemp1086;
			double fTemp1087 = fTemp893 * (fTemp901 * (fTemp903 * (2351.0 * fTemp905 + 4013.0 * fTemp906) + fTemp907 * (3527.0 * fTemp909 + 9672.0 * fTemp910)) + fTemp911 * (fTemp914 * (2351.0 * fTemp916 + 4013.0 * fTemp917) + fTemp918 * (3527.0 * fTemp920 + 9672.0 * fTemp921)));
			double fTemp1088 = std::tan(fConst5 * fTemp1087);
			double fTemp1089 = fTemp1088 * (fTemp928 - fRec726[1]) + fRec725[1];
			double fTemp1090 = fTemp1088 * (fTemp1088 + fTemp934 / fTemp1087) + 1.0;
			double fTemp1091 = fTemp1089 / fTemp1090;
			fRec725[0] = 2.0 * fTemp1091 - fRec725[1];
			fRec726[0] = fRec726[1] + 2.0 * (fTemp1088 * fTemp1089 / fTemp1090);
			double fRec727 = fTemp1091;
			fRec587[0] = 0.6366197723675814 * std::atan(0.03125 * (fRec609 * (fTemp901 * (fTemp903 * (0.01922137 * fTemp905 + 0.00787687 * fTemp906) + fTemp907 * (0.25042786 * fTemp909 + 0.6674602 * fTemp910)) + fTemp911 * (fTemp914 * (0.01922137 * fTemp916 + 0.00787687 * fTemp917) + fTemp918 * (0.25042786 * fTemp920 + 0.6674602 * fTemp921))) + fRec637 * (fTemp901 * (fTemp903 * (0.05522969 * fTemp905 + 0.06051622 * fTemp906) + fTemp907 * (0.02470587 * fTemp909 + 0.01035828 * fTemp910)) + fTemp911 * (fTemp914 * (0.05522969 * fTemp916 + 0.06051622 * fTemp917) + fTemp918 * (0.02470587 * fTemp920 + 0.01035828 * fTemp921))) + fRec640 * (fTemp901 * (fTemp903 * (0.08153769 * fTemp905 + 0.02426847 * fTemp906) + fTemp907 * (0.49828005 * fTemp909 + 0.00749257 * fTemp910)) + fTemp911 * (fTemp914 * (0.08153769 * fTemp916 + 0.02426847 * fTemp917) + fTemp918 * (0.49828005 * fTemp920 + 0.00749257 * fTemp921))) + fRec643 * (fTemp901 * (fTemp903 * (fTemp905 + 0.09843679 * fTemp906) + fTemp907 * (fTemp910 + 0.0405712 * fTemp909)) + fTemp911 * (fTemp914 * (fTemp916 + 0.09843679 * fTemp917) + fTemp918 * (fTemp921 + 0.0405712 * fTemp920))) + fRec646 * (fTemp901 * (fTemp903 * (fTemp906 + 0.27707616 * fTemp905) + fTemp907 * (fTemp909 + 0.01216278 * fTemp910)) + fTemp911 * (fTemp914 * (fTemp917 + 0.27707616 * fTemp916) + fTemp918 * (fTemp920 + 0.01216278 * fTemp921))) + fRec649 * (fTemp901 * (fTemp903 * (0.04196492 * fTemp905 + 0.75217775 * fTemp906) + fTemp907 * (0.07116083 * fTemp909 + 0.01835863 * fTemp910)) + fTemp911 * (fTemp914 * (0.04196492 * fTemp916 + 0.75217775 * fTemp917) + fTemp918 * (0.07116083 * fTemp920 + 0.01835863 * fTemp921))) + fRec652 * (fTemp901 * (fTemp903 * (0.03480883 * fTemp905 + 0.02102163 * fTemp906) + fTemp907 * (0.01626654 * fTemp909 + 0.03442368 * fTemp910)) + fTemp911 * (fTemp914 * (0.03480883 * fTemp916 + 0.02102163 * fTemp917) + fTemp918 * (0.01626654 * fTemp920 + 0.03442368 * fTemp921))) + fRec655 * (fTemp901 * (fTemp903 * (0.05834666 * fTemp905 + 0.01772408 * fTemp906) + fTemp907 * (0.14442907 * fTemp909 + 0.07338235 * fTemp910)) + fTemp911 * (fTemp914 * (0.05834666 * fTemp916 + 0.01772408 * fTemp917) + fTemp918 * (0.14442907 * fTemp920 + 0.07338235 * fTemp921))) + fRec658 * (fTemp901 * (fTemp903 * (0.02913938 * fTemp905 + 0.03638926 * fTemp906) + fTemp907 * (0.01228042 * fTemp909 + 0.08982961 * fTemp910)) + fTemp911 * (fTemp914 * (0.02913938 * fTemp916 + 0.03638926 * fTemp917) + fTemp918 * (0.01228042 * fTemp920 + 0.08982961 * fTemp921))) + fRec661 * (fTemp901 * (fTemp903 * (0.0550058 * fTemp905 + 0.02121633 * fTemp906) + fTemp907 * (0.2722688 * fTemp909 + 0.27821024 * fTemp910)) + fTemp911 * (fTemp914 * (0.0550058 * fTemp916 + 0.02121633 * fTemp917) + fTemp918 * (0.2722688 * fTemp920 + 0.27821024 * fTemp921))) + fRec664 * (fTemp901 * (fTemp903 * (0.03381146 * fTemp905 + 0.05363475 * fTemp906) + fTemp907 * (0.01573797 * fTemp909 + 0.64427134 * fTemp910)) + fTemp911 * (fTemp914 * (0.03381146 * fTemp916 + 0.05363475 * fTemp917) + fTemp918 * (0.01573797 * fTemp920 + 0.64427134 * fTemp921))) + fRec667 * (fTemp901 * (fTemp903 * (0.01797695 * fTemp905 + 0.0640251 * fTemp906) + fTemp907 * (0.54357606 * fTemp909 + 0.4053105 * fTemp910)) + fTemp911 * (fTemp914 * (0.01797695 * fTemp916 + 0.0640251 * fTemp917) + fTemp918 * (0.54357606 * fTemp920 + 0.4053105 * fTemp921))) + fRec670 * (fTemp901 * (fTemp903 * (0.03067041 * fTemp905 + 0.05785498 * fTemp906) + fTemp907 * (0.09954785 * fTemp909 + 0.62411215 * fTemp910)) + fTemp911 * (fTemp914 * (0.03067041 * fTemp916 + 0.05785498 * fTemp917) + fTemp918 * (0.09954785 * fTemp920 + 0.62411215 * fTemp921))) + fRec673 * (fTemp901 * (fTemp903 * (0.03436227 * fTemp905 + 0.04838698 * fTemp906) + fTemp907 * (0.0250452 * fTemp909 + 0.00707754 * fTemp910)) + fTemp911 * (fTemp914 * (0.03436227 * fTemp916 + 0.04838698 * fTemp917) + fTemp918 * (0.0250452 * fTemp920 + 0.00707754 * fTemp921))) + fRec676 * (fTemp901 * (fTemp903 * (0.0121161 * fTemp905 + 0.00709897 * fTemp906) + fTemp907 * (0.0343155 * fTemp909 + 0.02601317 * fTemp910)) + fTemp911 * (fTemp914 * (0.0121161 * fTemp916 + 0.00709897 * fTemp917) + fTemp918 * (0.0343155 * fTemp920 + 0.02601317 * fTemp921))) + fRec679 * (fTemp901 * (fTemp903 * (0.01668042 * fTemp905 + 0.01592137 * fTemp906) + fTemp907 * (0.01093969 * fTemp909 + 0.02061391 * fTemp910)) + fTemp911 * (fTemp914 * (0.01668042 * fTemp916 + 0.01592137 * fTemp917) + fTemp918 * (0.01093969 * fTemp920 + 0.02061391 * fTemp921))) + fRec682 * (fTemp901 * (fTemp903 * (0.00848029 * fTemp905 + 0.01670722 * fTemp906) + fTemp907 * (0.05126037 * fTemp909 + 0.03283333 * fTemp910)) + fTemp911 * (fTemp914 * (0.00848029 * fTemp916 + 0.01670722 * fTemp917) + fTemp918 * (0.05126037 * fTemp920 + 0.03283333 * fTemp921))) + fRec685 * (fTemp901 * (fTemp903 * (0.00496045 * fTemp905 + 0.02143791 * fTemp906) + fTemp907 * (0.07354127 * fTemp909 + 0.01222045 * fTemp910)) + fTemp911 * (fTemp914 * (0.00496045 * fTemp916 + 0.02143791 * fTemp917) + fTemp918 * (0.07354127 * fTemp920 + 0.01222045 * fTemp921))) + fRec688 * (fTemp901 * (fTemp903 * (0.00482074 * fTemp905 + 0.01863539 * fTemp906) + fTemp907 * (0.06191843 * fTemp909 + 0.03888326 * fTemp910)) + fTemp911 * (fTemp914 * (0.00482074 * fTemp916 + 0.01863539 * fTemp917) + fTemp918 * (0.06191843 * fTemp920 + 0.03888326 * fTemp921))) + fRec691 * (fTemp901 * (fTemp903 * (0.02735344 * fTemp905 + 0.02193515 * fTemp906) + fTemp907 * (0.07170723 * fTemp909 + 0.04759307 * fTemp910)) + fTemp911 * (fTemp914 * (0.02735344 * fTemp916 + 0.02193515 * fTemp917) + fTemp918 * (0.07170723 * fTemp920 + 0.04759307 * fTemp921))) + fRec694 * (fTemp901 * (fTemp903 * (0.02222397 * fTemp905 + 0.00886369 * fTemp906) + fTemp907 * (0.02115358 * fTemp909 + 0.02409027 * fTemp910)) + fTemp911 * (fTemp914 * (0.02222397 * fTemp916 + 0.00886369 * fTemp917) + fTemp918 * (0.02115358 * fTemp920 + 0.02409027 * fTemp921))) + fRec697 * (fTemp901 * (fTemp903 * (0.01985851 * fTemp905 + 0.00274825 * fTemp906) + fTemp907 * (0.28175268 * fTemp909 + 0.22375855 * fTemp910)) + fTemp911 * (fTemp914 * (0.01985851 * fTemp916 + 0.00274825 * fTemp917) + fTemp918 * (0.28175268 * fTemp920 + 0.22375855 * fTemp921))) + fRec700 * (fTemp901 * (fTemp903 * (0.00592071 * fTemp905 + 0.00126865 * fTemp906) + fTemp907 * (0.03127152 * fTemp909 + 0.02237106 * fTemp910)) + fTemp911 * (fTemp914 * (0.00592071 * fTemp916 + 0.00126865 * fTemp917) + fTemp918 * (0.03127152 * fTemp920 + 0.02237106 * fTemp921))) + fRec703 * (fTemp901 * (fTemp903 * (0.00722225 * fTemp905 + 0.00320751 * fTemp906) + fTemp907 * (0.01055565 * fTemp909 + 0.00841917 * fTemp910)) + fTemp911 * (fTemp914 * (0.00722225 * fTemp916 + 0.00320751 * fTemp917) + fTemp918 * (0.01055565 * fTemp920 + 0.00841917 * fTemp921))) + fRec706 * (fTemp901 * (fTemp903 * (0.01041008 * fTemp905 + 0.00333966 * fTemp906) + fTemp907 * (0.01134687 * fTemp909 + 0.01369543 * fTemp910)) + fTemp911 * (fTemp914 * (0.01041008 * fTemp916 + 0.00333966 * fTemp917) + fTemp918 * (0.01134687 * fTemp920 + 0.01369543 * fTemp921))) + fRec709 * (fTemp901 * (fTemp903 * (0.00722812 * fTemp905 + 0.00161424 * fTemp906) + fTemp907 * (0.01233555 * fTemp909 + 0.01528356 * fTemp910)) + fTemp911 * (fTemp914 * (0.00722812 * fTemp916 + 0.00161424 * fTemp917) + fTemp918 * (0.01233555 * fTemp920 + 0.01528356 * fTemp921))) + fRec712 * (fTemp901 * (fTemp903 * (0.00729633 * fTemp905 + 0.00190274 * fTemp906) + fTemp907 * (0.00656447 * fTemp909 + 0.00854136 * fTemp910)) + fTemp911 * (fTemp914 * (0.00729633 * fTemp916 + 0.00190274 * fTemp917) + fTemp918 * (0.00656447 * fTemp920 + 0.00854136 * fTemp921))) + fRec715 * (fTemp901 * (fTemp903 * (0.02313585 * fTemp905 + 0.00348521 * fTemp906) + fTemp907 * (0.09585942 * fTemp909 + 0.01776269 * fTemp910)) + fTemp911 * (fTemp914 * (0.02313585 * fTemp916 + 0.00348521 * fTemp917) + fTemp918 * (0.09585942 * fTemp920 + 0.01776269 * fTemp921))) + fRec718 * (fTemp901 * (fTemp903 * (0.04640077 * fTemp905 + 0.01305707 * fTemp906) + fTemp907 * (0.06985491 * fTemp909 + 0.01631748 * fTemp910)) + fTemp911 * (fTemp914 * (0.04640077 * fTemp916 + 0.01305707 * fTemp917) + fTemp918 * (0.06985491 * fTemp920 + 0.01631748 * fTemp921))) + fRec721 * (fTemp901 * (fTemp903 * (0.01158114 * fTemp905 + 0.00132724 * fTemp906) + fTemp907 * (0.01587526 * fTemp909 + 0.00969712 * fTemp910)) + fTemp911 * (fTemp914 * (0.01158114 * fTemp916 + 0.00132724 * fTemp917) + fTemp918 * (0.01587526 * fTemp920 + 0.00969712 * fTemp921))) + fRec724 * (fTemp901 * (fTemp903 * (0.00443968 * fTemp905 + 0.00152525 * fTemp906) + fTemp907 * (0.00962998 * fTemp909 + 0.00986048 * fTemp910)) + fTemp911 * (fTemp914 * (0.00443968 * fTemp916 + 0.00152525 * fTemp917) + fTemp918 * (0.00962998 * fTemp920 + 0.00986048 * fTemp921))) + fRec727 * (fTemp901 * (fTemp903 * (0.00282064 * fTemp905 + 0.00097757 * fTemp906) + fTemp907 * (0.0068168 * fTemp909 + 0.01255551 * fTemp910)) + fTemp911 * (fTemp914 * (0.00282064 * fTemp916 + 0.00097757 * fTemp917) + fTemp918 * (0.0068168 * fTemp920 + 0.01255551 * fTemp921)))));
			fRec7[0] = fRec587[0];
			fRec734[0] = std::fmod(fRec734[1], fConst0) + std::fabs(0.1 * fRec733[1]) + 0.1;
			int iTemp1092 = (fConst1 * fRec734[0]) < (fConst1 * fRec734[1]);
			iVec42[0] = 263;
			iRec735[0] = (263 - iVec42[1]) % -2147483648 + (12345 - 59 * iRec735[1]);
			fRec733[0] = fRec733[1] * double(iVec0[1] - iTemp1092) + (0.0 - 4.656612873077393e-10 * double(iRec735[0])) * double(iTemp1092 + iTemp1);
			int iTemp1093 = fRec733[0] == fRec733[1];
			fRec732[0] = fRec732[1] * double(iTemp1093) + 0.125 * fTemp3 * double(1 - iTemp1093);
			double fTemp1094 = ((fRec732[0] != fRec732[1]) ? fConst4 : fRec730[1] + -1.0);
			fRec730[0] = fTemp1094;
			fRec731[0] = ((fTemp1094 > 0.0) ? fRec731[1] + (fRec732[0] - fRec731[1]) / fTemp1094 : fRec732[0]);
			double fTemp1095 = tanh(fRec13[0] + fSlow4 * std::sin(6.283185307179586 * fRec731[0])) + 1.0;
			fVbargraph35 = FAUSTFLOAT(5e+02 * fTemp1095);
			fRec741[0] = std::fmod(fRec741[1], fConst0) + std::fabs(0.1 * fRec740[1]) + 0.1;
			int iTemp1096 = (fConst1 * fRec741[0]) < (fConst1 * fRec741[1]);
			iVec43[0] = 233;
			iRec742[0] = (233 - iVec43[1]) % -2147483648 + (12345 - 59 * iRec742[1]);
			fRec740[0] = fRec740[1] * double(iVec0[1] - iTemp1096) + (0.0 - 4.656612873077393e-10 * double(iRec742[0])) * double(iTemp1096 + iTemp1);
			int iTemp1097 = fRec740[0] == fRec740[1];
			fRec739[0] = fRec739[1] * double(iTemp1097) + 0.125 * fTemp3 * double(1 - iTemp1097);
			double fTemp1098 = ((fRec739[0] != fRec739[1]) ? fConst4 : fRec737[1] + -1.0);
			fRec737[0] = fTemp1098;
			fRec738[0] = ((fTemp1098 > 0.0) ? fRec738[1] + (fRec739[0] - fRec738[1]) / fTemp1098 : fRec739[0]);
			double fTemp1099 = std::pow(5e+02, tanh(fRec21[0] + fSlow4 * std::sin(6.283185307179586 * fRec738[0])));
			fVbargraph36 = FAUSTFLOAT(1e+03 * fTemp1099);
			fRec736[0] = fRec736[1] + fConst1 * fTemp1099;
			fRec747[0] = std::fmod(fRec747[1], fConst0) + std::fabs(0.1 * fRec746[1]) + 0.1;
			int iTemp1100 = (fConst1 * fRec747[0]) < (fConst1 * fRec747[1]);
			iVec44[0] = 257;
			iRec748[0] = (257 - iVec44[1]) % -2147483648 + (12345 - 59 * iRec748[1]);
			fRec746[0] = fRec746[1] * double(iVec0[1] - iTemp1100) + (0.0 - 4.656612873077393e-10 * double(iRec748[0])) * double(iTemp1100 + iTemp1);
			int iTemp1101 = fRec746[0] == fRec746[1];
			fRec745[0] = fRec745[1] * double(iTemp1101) + 0.125 * fTemp3 * double(1 - iTemp1101);
			double fTemp1102 = ((fRec745[0] != fRec745[1]) ? fConst4 : fRec743[1] + -1.0);
			fRec743[0] = fTemp1102;
			fRec744[0] = ((fTemp1102 > 0.0) ? fRec744[1] + (fRec745[0] - fRec744[1]) / fTemp1102 : fRec745[0]);
			double fTemp1103 = tanh(fRec28[0] + fSlow4 * std::sin(6.283185307179586 * fRec744[0])) + 1.0;
			fVbargraph37 = FAUSTFLOAT(5e+02 * fTemp1103);
			double fTemp1104 = (fTemp6 * 0.5 * fTemp1095 + 1.0) * fRec728[1] + mydsp_faustpower3_f(fRec729[1]) + std::cos(fRec736[0]) * 0.5 * fTemp1103;
			double fTemp1105 = 0.0 - fTemp1104;
			fVec45[0] = fTemp1105;
			fRec728[0] = fTemp1105;
			fRec756[0] = std::fmod(fRec756[1], fConst0) + std::fabs(0.1 * fRec755[1]) + 0.1;
			int iTemp1106 = (fConst1 * fRec756[0]) < (fConst1 * fRec756[1]);
			iVec46[0] = 239;
			iRec757[0] = (239 - iVec46[1]) % -2147483648 + (12345 - 59 * iRec757[1]);
			fRec755[0] = fRec755[1] * double(iVec0[1] - iTemp1106) + (0.0 - 4.656612873077393e-10 * double(iRec757[0])) * double(iTemp1106 + iTemp1);
			int iTemp1107 = fRec755[0] == fRec755[1];
			fRec754[0] = fRec754[1] * double(iTemp1107) + 0.125 * fTemp3 * double(1 - iTemp1107);
			double fTemp1108 = ((fRec754[0] != fRec754[1]) ? fConst4 : fRec752[1] + -1.0);
			fRec752[0] = fTemp1108;
			fRec753[0] = ((fTemp1108 > 0.0) ? fRec753[1] + (fRec754[0] - fRec753[1]) / fTemp1108 : fRec754[0]);
			double fTemp1109 = 0.45 * (tanh(fRec38[0] + fSlow4 * std::sin(6.283185307179586 * fRec753[0])) + 1.0) + 0.1;
			fVbargraph38 = FAUSTFLOAT(1e+03 * fTemp1109);
			double fTemp1110 = fTemp1109;
			fRec762[0] = std::fmod(fRec762[1], fConst0) + std::fabs(0.1 * fRec761[1]) + 0.1;
			int iTemp1111 = (fConst1 * fRec762[0]) < (fConst1 * fRec762[1]);
			iVec47[0] = 241;
			iRec763[0] = (241 - iVec47[1]) % -2147483648 + (12345 - 59 * iRec763[1]);
			fRec761[0] = fRec761[1] * double(iVec0[1] - iTemp1111) + (0.0 - 4.656612873077393e-10 * double(iRec763[0])) * double(iTemp1111 + iTemp1);
			int iTemp1112 = fRec761[0] == fRec761[1];
			fRec760[0] = fRec760[1] * double(iTemp1112) + 0.125 * fTemp3 * double(1 - iTemp1112);
			double fTemp1113 = ((fRec760[0] != fRec760[1]) ? fConst4 : fRec758[1] + -1.0);
			fRec758[0] = fTemp1113;
			fRec759[0] = ((fTemp1113 > 0.0) ? fRec759[1] + (fRec760[0] - fRec759[1]) / fTemp1113 : fRec760[0]);
			double fTemp1114 = tanh(fRec45[0] + fSlow4 * std::sin(6.283185307179586 * fRec759[0])) + 1.0;
			fVbargraph39 = FAUSTFLOAT(5e+02 * fTemp1114);
			double fTemp1115 = 4.0 * 0.5 * fTemp1114;
			int iTemp1116 = int(fTemp1115);
			double fTemp1117 = double(iTemp1116);
			double fTemp1118 = fTemp1117 + (1.0 - fTemp1115);
			int iTemp1119 = iTemp1116 >= 2;
			double fTemp1120 = double(1 - iTemp1119);
			int iTemp1121 = iTemp1116 >= 1;
			double fTemp1122 = double(1 - iTemp1121);
			double fTemp1123 = double(iTemp1121);
			double fTemp1124 = double(iTemp1119);
			int iTemp1125 = iTemp1116 >= 3;
			double fTemp1126 = double(1 - iTemp1125);
			double fTemp1127 = double(iTemp1125);
			double fTemp1128 = fTemp1115 - fTemp1117;
			int iTemp1129 = iTemp1116 + 1;
			int iTemp1130 = iTemp1129 >= 2;
			double fTemp1131 = double(1 - iTemp1130);
			int iTemp1132 = iTemp1129 >= 1;
			double fTemp1133 = double(1 - iTemp1132);
			double fTemp1134 = double(iTemp1132);
			double fTemp1135 = double(iTemp1130);
			int iTemp1136 = iTemp1129 >= 3;
			double fTemp1137 = double(1 - iTemp1136);
			double fTemp1138 = double(iTemp1136);
			double fTemp1139 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1698.0 * fTemp1122 + 2349.0 * fTemp1123) + fTemp1124 * (2273.0 * fTemp1126 + 4617.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1698.0 * fTemp1133 + 2349.0 * fTemp1134) + fTemp1135 * (2273.0 * fTemp1137 + 4617.0 * fTemp1138)));
			double fTemp1140 = std::tan(fConst5 * fTemp1139);
			fRec764[0] = 0.995 * fRec764[1] - (fTemp1104 + fVec45[1]);
			fRec769[0] = std::fmod(fRec769[1], fConst0) + std::fabs(0.1 * fRec768[1]) + 0.1;
			int iTemp1141 = (fConst1 * fRec769[0]) < (fConst1 * fRec769[1]);
			iVec48[0] = 269;
			iRec770[0] = (269 - iVec48[1]) % -2147483648 + (12345 - 59 * iRec770[1]);
			fRec768[0] = fRec768[1] * double(iVec0[1] - iTemp1141) + (0.0 - 4.656612873077393e-10 * double(iRec770[0])) * double(iTemp1141 + iTemp1);
			int iTemp1142 = fRec768[0] == fRec768[1];
			fRec767[0] = fRec767[1] * double(iTemp1142) + 0.125 * fTemp3 * double(1 - iTemp1142);
			double fTemp1143 = ((fRec767[0] != fRec767[1]) ? fConst4 : fRec765[1] + -1.0);
			fRec765[0] = fTemp1143;
			fRec766[0] = ((fTemp1143 > 0.0) ? fRec766[1] + (fRec767[0] - fRec766[1]) / fTemp1143 : fRec767[0]);
			double fTemp1144 = std::pow(1e+03, tanh(fRec53[0] + fSlow4 * std::sin(6.283185307179586 * fRec766[0])));
			fVbargraph40 = FAUSTFLOAT(fTemp1144);
			double fTemp1145 = fRec764[0] * fTemp1144;
			double fTemp1146 = fTemp1140 * (fTemp1145 - fRec750[1]) + fRec749[1];
			fRec775[0] = std::fmod(fRec775[1], fConst0) + std::fabs(0.1 * fRec774[1]) + 0.1;
			int iTemp1147 = (fConst1 * fRec775[0]) < (fConst1 * fRec775[1]);
			iVec49[0] = 251;
			iRec776[0] = (251 - iVec49[1]) % -2147483648 + (12345 - 59 * iRec776[1]);
			fRec774[0] = fRec774[1] * double(iVec0[1] - iTemp1147) + (0.0 - 4.656612873077393e-10 * double(iRec776[0])) * double(iTemp1147 + iTemp1);
			int iTemp1148 = fRec774[0] == fRec774[1];
			fRec773[0] = fRec773[1] * double(iTemp1148) + 0.125 * fTemp3 * double(1 - iTemp1148);
			double fTemp1149 = ((fRec773[0] != fRec773[1]) ? fConst4 : fRec771[1] + -1.0);
			fRec771[0] = fTemp1149;
			fRec772[0] = ((fTemp1149 > 0.0) ? fRec772[1] + (fRec773[0] - fRec772[1]) / fTemp1149 : fRec773[0]);
			double fTemp1150 = std::pow(1e+02, tanh(fRec60[0] + fSlow4 * std::sin(6.283185307179586 * fRec772[0])));
			fVbargraph41 = FAUSTFLOAT(fTemp1150);
			double fTemp1151 = std::max<double>(2.220446049250313e-16, fTemp1150);
			double fTemp1152 = fTemp1140 * (fTemp1140 + fTemp1151 / fTemp1139) + 1.0;
			double fTemp1153 = fTemp1146 / fTemp1152;
			fRec749[0] = 2.0 * fTemp1153 - fRec749[1];
			fRec750[0] = fRec750[1] + 2.0 * (fTemp1140 * fTemp1146 / fTemp1152);
			double fRec751 = fTemp1153;
			double fTemp1154 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1632.0 * fTemp1122 + 2252.0 * fTemp1123) + fTemp1124 * (2204.0 * fTemp1126 + 4177.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1632.0 * fTemp1133 + 2252.0 * fTemp1134) + fTemp1135 * (2204.0 * fTemp1137 + 4177.0 * fTemp1138)));
			double fTemp1155 = std::tan(fConst5 * fTemp1154);
			double fTemp1156 = fTemp1155 * (fTemp1145 - fRec778[1]) + fRec777[1];
			double fTemp1157 = fTemp1155 * (fTemp1155 + fTemp1151 / fTemp1154) + 1.0;
			double fTemp1158 = fTemp1156 / fTemp1157;
			fRec777[0] = 2.0 * fTemp1158 - fRec777[1];
			fRec778[0] = fRec778[1] + 2.0 * (fTemp1155 * fTemp1156 / fTemp1157);
			double fRec779 = fTemp1158;
			double fTemp1159 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1567.0 * fTemp1122 + 2153.0 * fTemp1123) + fTemp1124 * (2054.0 * fTemp1126 + 3957.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1567.0 * fTemp1133 + 2153.0 * fTemp1134) + fTemp1135 * (2054.0 * fTemp1137 + 3957.0 * fTemp1138)));
			double fTemp1160 = std::tan(fConst5 * fTemp1159);
			double fTemp1161 = fTemp1160 * (fTemp1145 - fRec781[1]) + fRec780[1];
			double fTemp1162 = fTemp1160 * (fTemp1160 + fTemp1151 / fTemp1159) + 1.0;
			double fTemp1163 = fTemp1161 / fTemp1162;
			fRec780[0] = 2.0 * fTemp1163 - fRec780[1];
			fRec781[0] = fRec781[1] + 2.0 * (fTemp1160 * fTemp1161 / fTemp1162);
			double fRec782 = fTemp1163;
			double fTemp1164 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1502.0 * fTemp1122 + 2056.0 * fTemp1123) + fTemp1124 * (1.91e+03 * fTemp1126 + 3737.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1502.0 * fTemp1133 + 2056.0 * fTemp1134) + fTemp1135 * (1.91e+03 * fTemp1137 + 3737.0 * fTemp1138)));
			double fTemp1165 = std::tan(fConst5 * fTemp1164);
			double fTemp1166 = fTemp1165 * (fTemp1145 - fRec784[1]) + fRec783[1];
			double fTemp1167 = fTemp1165 * (fTemp1165 + fTemp1151 / fTemp1164) + 1.0;
			double fTemp1168 = fTemp1166 / fTemp1167;
			fRec783[0] = 2.0 * fTemp1168 - fRec783[1];
			fRec784[0] = fRec784[1] + 2.0 * (fTemp1165 * fTemp1166 / fTemp1167);
			double fRec785 = fTemp1168;
			double fTemp1169 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1371.0 * fTemp1122 + 1958.0 * fTemp1123) + fTemp1124 * (1855.0 * fTemp1126 + 3517.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1371.0 * fTemp1133 + 1958.0 * fTemp1134) + fTemp1135 * (1855.0 * fTemp1137 + 3517.0 * fTemp1138)));
			double fTemp1170 = std::tan(fConst5 * fTemp1169);
			double fTemp1171 = fTemp1170 * (fTemp1145 - fRec787[1]) + fRec786[1];
			double fTemp1172 = fTemp1170 * (fTemp1170 + fTemp1151 / fTemp1169) + 1.0;
			double fTemp1173 = fTemp1171 / fTemp1172;
			fRec786[0] = 2.0 * fTemp1173 - fRec786[1];
			fRec787[0] = fRec787[1] + 2.0 * (fTemp1170 * fTemp1171 / fTemp1172);
			double fRec788 = fTemp1173;
			double fTemp1174 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1306.0 * fTemp1122 + 1.86e+03 * fTemp1123) + fTemp1124 * (1764.0 * fTemp1126 + 3298.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1306.0 * fTemp1133 + 1.86e+03 * fTemp1134) + fTemp1135 * (1764.0 * fTemp1137 + 3298.0 * fTemp1138)));
			double fTemp1175 = std::tan(fConst5 * fTemp1174);
			double fTemp1176 = fTemp1175 * (fTemp1145 - fRec790[1]) + fRec789[1];
			double fTemp1177 = fTemp1175 * (fTemp1175 + fTemp1151 / fTemp1174) + 1.0;
			double fTemp1178 = fTemp1176 / fTemp1177;
			fRec789[0] = 2.0 * fTemp1178 - fRec789[1];
			fRec790[0] = fRec790[1] + 2.0 * (fTemp1175 * fTemp1176 / fTemp1177);
			double fRec791 = fTemp1178;
			double fTemp1179 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1241.0 * fTemp1122 + 1762.0 * fTemp1123) + fTemp1124 * (1617.0 * fTemp1126 + 3078.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1241.0 * fTemp1133 + 1762.0 * fTemp1134) + fTemp1135 * (1617.0 * fTemp1137 + 3078.0 * fTemp1138)));
			double fTemp1180 = std::tan(fConst5 * fTemp1179);
			double fTemp1181 = fTemp1180 * (fTemp1145 - fRec793[1]) + fRec792[1];
			double fTemp1182 = fTemp1180 * (fTemp1180 + fTemp1151 / fTemp1179) + 1.0;
			double fTemp1183 = fTemp1181 / fTemp1182;
			fRec792[0] = 2.0 * fTemp1183 - fRec792[1];
			fRec793[0] = fRec793[1] + 2.0 * (fTemp1180 * fTemp1181 / fTemp1182);
			double fRec794 = fTemp1183;
			double fTemp1184 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1175.0 * fTemp1122 + 1664.0 * fTemp1123) + fTemp1124 * (1.47e+03 * fTemp1126 + 2858.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1175.0 * fTemp1133 + 1664.0 * fTemp1134) + fTemp1135 * (1.47e+03 * fTemp1137 + 2858.0 * fTemp1138)));
			double fTemp1185 = std::tan(fConst5 * fTemp1184);
			double fTemp1186 = fTemp1185 * (fTemp1145 - fRec796[1]) + fRec795[1];
			double fTemp1187 = fTemp1185 * (fTemp1185 + fTemp1151 / fTemp1184) + 1.0;
			double fTemp1188 = fTemp1186 / fTemp1187;
			fRec795[0] = 2.0 * fTemp1188 - fRec795[1];
			fRec796[0] = fRec796[1] + 2.0 * (fTemp1185 * fTemp1186 / fTemp1187);
			double fRec797 = fTemp1188;
			double fTemp1189 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1.11e+03 * fTemp1122 + 1566.0 * fTemp1123) + fTemp1124 * (1323.0 * fTemp1126 + 2638.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1.11e+03 * fTemp1133 + 1566.0 * fTemp1134) + fTemp1135 * (1323.0 * fTemp1137 + 2638.0 * fTemp1138)));
			double fTemp1190 = std::tan(fConst5 * fTemp1189);
			double fTemp1191 = fTemp1190 * (fTemp1145 - fRec799[1]) + fRec798[1];
			double fTemp1192 = fTemp1190 * (fTemp1190 + fTemp1151 / fTemp1189) + 1.0;
			double fTemp1193 = fTemp1191 / fTemp1192;
			fRec798[0] = 2.0 * fTemp1193 - fRec798[1];
			fRec799[0] = fRec799[1] + 2.0 * (fTemp1190 * fTemp1191 / fTemp1192);
			double fRec800 = fTemp1193;
			double fTemp1194 = fTemp1110 * (fTemp1118 * (fTemp1120 * (522.0 * fTemp1122 + 685.0 * fTemp1123) + fTemp1124 * (588.0 * fTemp1126 + 659.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (522.0 * fTemp1133 + 685.0 * fTemp1134) + fTemp1135 * (588.0 * fTemp1137 + 659.0 * fTemp1138)));
			double fTemp1195 = std::tan(fConst5 * fTemp1194);
			double fTemp1196 = fTemp1195 * (fTemp1145 - fRec802[1]) + fRec801[1];
			double fTemp1197 = fTemp1195 * (fTemp1195 + fTemp1151 / fTemp1194) + 1.0;
			double fTemp1198 = fTemp1196 / fTemp1197;
			fRec801[0] = 2.0 * fTemp1198 - fRec801[1];
			fRec802[0] = fRec802[1] + 2.0 * (fTemp1195 * fTemp1196 / fTemp1197);
			double fRec803 = fTemp1198;
			double fTemp1199 = fTemp1110 * (fTemp1118 * (fTemp1120 * (457.0 * fTemp1122 + 587.0 * fTemp1123) + fTemp1124 * (534.0 * fTemp1126 + 538.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (457.0 * fTemp1133 + 587.0 * fTemp1134) + fTemp1135 * (534.0 * fTemp1137 + 538.0 * fTemp1138)));
			double fTemp1200 = std::tan(fConst5 * fTemp1199);
			double fTemp1201 = fTemp1200 * (fTemp1145 - fRec805[1]) + fRec804[1];
			double fTemp1202 = fTemp1200 * (fTemp1200 + fTemp1151 / fTemp1199) + 1.0;
			double fTemp1203 = fTemp1201 / fTemp1202;
			fRec804[0] = 2.0 * fTemp1203 - fRec804[1];
			fRec805[0] = fRec805[1] + 2.0 * (fTemp1200 * fTemp1201 / fTemp1202);
			double fRec806 = fTemp1203;
			double fTemp1204 = fTemp1110 * (fTemp1118 * (fTemp1120 * (392.0 * fTemp1122 + 537.0 * fTemp1123) + fTemp1124 * (441.0 * fTemp1126 + 439.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (392.0 * fTemp1133 + 537.0 * fTemp1134) + fTemp1135 * (441.0 * fTemp1137 + 439.0 * fTemp1138)));
			double fTemp1205 = std::tan(fConst5 * fTemp1204);
			double fTemp1206 = fTemp1205 * (fTemp1145 - fRec808[1]) + fRec807[1];
			double fTemp1207 = fTemp1205 * (fTemp1205 + fTemp1151 / fTemp1204) + 1.0;
			double fTemp1208 = fTemp1206 / fTemp1207;
			fRec807[0] = 2.0 * fTemp1208 - fRec807[1];
			fRec808[0] = fRec808[1] + 2.0 * (fTemp1205 * fTemp1206 / fTemp1207);
			double fRec809 = fTemp1208;
			double fTemp1209 = fTemp1110 * (fTemp1118 * (fTemp1120 * (326.0 * fTemp1122 + 489.0 * fTemp1123) + fTemp1124 * (367.0 * fTemp1126 + 368.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (326.0 * fTemp1133 + 489.0 * fTemp1134) + fTemp1135 * (367.0 * fTemp1137 + 368.0 * fTemp1138)));
			double fTemp1210 = std::tan(fConst5 * fTemp1209);
			double fTemp1211 = fTemp1210 * (fTemp1145 - fRec811[1]) + fRec810[1];
			double fTemp1212 = fTemp1210 * (fTemp1210 + fTemp1151 / fTemp1209) + 1.0;
			double fTemp1213 = fTemp1211 / fTemp1212;
			fRec810[0] = 2.0 * fTemp1213 - fRec810[1];
			fRec811[0] = fRec811[1] + 2.0 * (fTemp1210 * fTemp1211 / fTemp1212);
			double fRec812 = fTemp1213;
			double fTemp1214 = fTemp1110 * (fTemp1118 * (fTemp1120 * (261.0 * fTemp1122 + 391.0 * fTemp1123) + fTemp1124 * (294.0 * fTemp1126 + 309.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (261.0 * fTemp1133 + 391.0 * fTemp1134) + fTemp1135 * (294.0 * fTemp1137 + 309.0 * fTemp1138)));
			double fTemp1215 = std::tan(fConst5 * fTemp1214);
			double fTemp1216 = fTemp1215 * (fTemp1145 - fRec814[1]) + fRec813[1];
			double fTemp1217 = fTemp1215 * (fTemp1215 + fTemp1151 / fTemp1214) + 1.0;
			double fTemp1218 = fTemp1216 / fTemp1217;
			fRec813[0] = 2.0 * fTemp1218 - fRec813[1];
			fRec814[0] = fRec814[1] + 2.0 * (fTemp1215 * fTemp1216 / fTemp1217);
			double fRec815 = fTemp1218;
			double fTemp1219 = fTemp1110 * (fTemp1118 * (fTemp1120 * (196.0 * fTemp1122 + 293.0 * fTemp1123) + fTemp1124 * (203.0 * fTemp1126 + 2.2e+02 * fTemp1127)) + fTemp1128 * (fTemp1131 * (196.0 * fTemp1133 + 293.0 * fTemp1134) + fTemp1135 * (203.0 * fTemp1137 + 2.2e+02 * fTemp1138)));
			double fTemp1220 = std::tan(fConst5 * fTemp1219);
			double fTemp1221 = fTemp1220 * (fTemp1145 - fRec817[1]) + fRec816[1];
			double fTemp1222 = fTemp1220 * (fTemp1220 + fTemp1151 / fTemp1219) + 1.0;
			double fTemp1223 = fTemp1221 / fTemp1222;
			fRec816[0] = 2.0 * fTemp1223 - fRec816[1];
			fRec817[0] = fRec817[1] + 2.0 * (fTemp1220 * fTemp1221 / fTemp1222);
			double fRec818 = fTemp1223;
			double fTemp1224 = fTemp1110 * (fTemp1118 * (fTemp1120 * (131.0 * fTemp1122 + 195.0 * fTemp1123) + fTemp1124 * (147.0 * fTemp1126 + 1.3e+02 * fTemp1127)) + fTemp1128 * (fTemp1131 * (131.0 * fTemp1133 + 195.0 * fTemp1134) + fTemp1135 * (147.0 * fTemp1137 + 1.3e+02 * fTemp1138)));
			double fTemp1225 = std::tan(fConst5 * fTemp1224);
			double fTemp1226 = fTemp1225 * (fTemp1145 - fRec820[1]) + fRec819[1];
			double fTemp1227 = fTemp1225 * (fTemp1225 + fTemp1151 / fTemp1224) + 1.0;
			double fTemp1228 = fTemp1226 / fTemp1227;
			fRec819[0] = 2.0 * fTemp1228 - fRec819[1];
			fRec820[0] = fRec820[1] + 2.0 * (fTemp1225 * fTemp1226 / fTemp1227);
			double fRec821 = fTemp1228;
			double fTemp1229 = (fTemp1118 * ((65.0 * fTemp1122 + 98.0 * fTemp1123) * fTemp1120 + (53.0 * fTemp1126 + 5e+01 * fTemp1127) * fTemp1124) + fTemp1128 * ((65.0 * fTemp1133 + 98.0 * fTemp1134) * fTemp1131 + (53.0 * fTemp1137 + 5e+01 * fTemp1138) * fTemp1135)) * fTemp1110;
			double fTemp1230 = std::tan(fConst5 * fTemp1229);
			double fTemp1231 = fTemp1230 * (fTemp1145 - fRec823[1]) + fRec822[1];
			double fTemp1232 = fTemp1230 * (fTemp1230 + fTemp1151 / fTemp1229) + 1.0;
			double fTemp1233 = fTemp1231 / fTemp1232;
			fRec822[0] = 2.0 * fTemp1233 - fRec822[1];
			fRec823[0] = fRec823[1] + 2.0 * (fTemp1230 * fTemp1231 / fTemp1232);
			double fRec824 = fTemp1233;
			double fTemp1234 = fTemp1110 * (fTemp1118 * (fTemp1120 * (588.0 * fTemp1122 + 783.0 * fTemp1123) + fTemp1124 * (735.0 * fTemp1126 + 879.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (588.0 * fTemp1133 + 783.0 * fTemp1134) + fTemp1135 * (735.0 * fTemp1137 + 879.0 * fTemp1138)));
			double fTemp1235 = std::tan(fConst5 * fTemp1234);
			double fTemp1236 = fTemp1235 * (fTemp1145 - fRec826[1]) + fRec825[1];
			double fTemp1237 = fTemp1235 * (fTemp1235 + fTemp1151 / fTemp1234) + 1.0;
			double fTemp1238 = fTemp1236 / fTemp1237;
			fRec825[0] = 2.0 * fTemp1238 - fRec825[1];
			fRec826[0] = fRec826[1] + 2.0 * (fTemp1235 * fTemp1236 / fTemp1237);
			double fRec827 = fTemp1238;
			double fTemp1239 = fTemp1110 * (fTemp1118 * (fTemp1120 * (653.0 * fTemp1122 + 8.8e+02 * fTemp1123) + fTemp1124 * (785.0 * fTemp1126 + 1099.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (653.0 * fTemp1133 + 8.8e+02 * fTemp1134) + fTemp1135 * (785.0 * fTemp1137 + 1099.0 * fTemp1138)));
			double fTemp1240 = std::tan(fConst5 * fTemp1239);
			double fTemp1241 = fTemp1240 * (fTemp1145 - fRec829[1]) + fRec828[1];
			double fTemp1242 = fTemp1240 * (fTemp1240 + fTemp1151 / fTemp1239) + 1.0;
			double fTemp1243 = fTemp1241 / fTemp1242;
			fRec828[0] = 2.0 * fTemp1243 - fRec828[1];
			fRec829[0] = fRec829[1] + 2.0 * (fTemp1240 * fTemp1241 / fTemp1242);
			double fRec830 = fTemp1243;
			double fTemp1244 = fTemp1110 * (fTemp1118 * (fTemp1120 * (718.0 * fTemp1122 + 979.0 * fTemp1123) + fTemp1124 * (882.0 * fTemp1126 + 1319.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (718.0 * fTemp1133 + 979.0 * fTemp1134) + fTemp1135 * (882.0 * fTemp1137 + 1319.0 * fTemp1138)));
			double fTemp1245 = std::tan(fConst5 * fTemp1244);
			double fTemp1246 = fTemp1245 * (fTemp1145 - fRec832[1]) + fRec831[1];
			double fTemp1247 = fTemp1245 * (fTemp1245 + fTemp1151 / fTemp1244) + 1.0;
			double fTemp1248 = fTemp1246 / fTemp1247;
			fRec831[0] = 2.0 * fTemp1248 - fRec831[1];
			fRec832[0] = fRec832[1] + 2.0 * (fTemp1245 * fTemp1246 / fTemp1247);
			double fRec833 = fTemp1248;
			double fTemp1249 = fTemp1110 * (fTemp1118 * (fTemp1120 * (784.0 * fTemp1122 + 1076.0 * fTemp1123) + fTemp1124 * (961.0 * fTemp1126 + 1539.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (784.0 * fTemp1133 + 1076.0 * fTemp1134) + fTemp1135 * (961.0 * fTemp1137 + 1539.0 * fTemp1138)));
			double fTemp1250 = std::tan(fConst5 * fTemp1249);
			double fTemp1251 = fTemp1250 * (fTemp1145 - fRec835[1]) + fRec834[1];
			double fTemp1252 = fTemp1250 * (fTemp1250 + fTemp1151 / fTemp1249) + 1.0;
			double fTemp1253 = fTemp1251 / fTemp1252;
			fRec834[0] = 2.0 * fTemp1253 - fRec834[1];
			fRec835[0] = fRec835[1] + 2.0 * (fTemp1250 * fTemp1251 / fTemp1252);
			double fRec836 = fTemp1253;
			double fTemp1254 = fTemp1110 * (fTemp1118 * (fTemp1120 * (849.0 * fTemp1122 + 1174.0 * fTemp1123) + fTemp1124 * (1028.0 * fTemp1126 + 1759.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (849.0 * fTemp1133 + 1174.0 * fTemp1134) + fTemp1135 * (1028.0 * fTemp1137 + 1759.0 * fTemp1138)));
			double fTemp1255 = std::tan(fConst5 * fTemp1254);
			double fTemp1256 = fTemp1255 * (fTemp1145 - fRec838[1]) + fRec837[1];
			double fTemp1257 = fTemp1255 * (fTemp1255 + fTemp1151 / fTemp1254) + 1.0;
			double fTemp1258 = fTemp1256 / fTemp1257;
			fRec837[0] = 2.0 * fTemp1258 - fRec837[1];
			fRec838[0] = fRec838[1] + 2.0 * (fTemp1255 * fTemp1256 / fTemp1257);
			double fRec839 = fTemp1258;
			double fTemp1259 = fTemp1110 * (fTemp1118 * (fTemp1120 * (914.0 * fTemp1122 + 1272.0 * fTemp1123) + fTemp1124 * (1078.0 * fTemp1126 + 1978.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (914.0 * fTemp1133 + 1272.0 * fTemp1134) + fTemp1135 * (1078.0 * fTemp1137 + 1978.0 * fTemp1138)));
			double fTemp1260 = std::tan(fConst5 * fTemp1259);
			double fTemp1261 = fTemp1260 * (fTemp1145 - fRec841[1]) + fRec840[1];
			double fTemp1262 = fTemp1260 * (fTemp1260 + fTemp1151 / fTemp1259) + 1.0;
			double fTemp1263 = fTemp1261 / fTemp1262;
			fRec840[0] = 2.0 * fTemp1263 - fRec840[1];
			fRec841[0] = fRec841[1] + 2.0 * (fTemp1260 * fTemp1261 / fTemp1262);
			double fRec842 = fTemp1263;
			double fTemp1264 = fTemp1110 * (fTemp1118 * (fTemp1120 * (979.0 * fTemp1122 + 1371.0 * fTemp1123) + fTemp1124 * (1175.0 * fTemp1126 + 2198.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (979.0 * fTemp1133 + 1371.0 * fTemp1134) + fTemp1135 * (1175.0 * fTemp1137 + 2198.0 * fTemp1138)));
			double fTemp1265 = std::tan(fConst5 * fTemp1264);
			double fTemp1266 = fTemp1265 * (fTemp1145 - fRec844[1]) + fRec843[1];
			double fTemp1267 = fTemp1265 * (fTemp1265 + fTemp1151 / fTemp1264) + 1.0;
			double fTemp1268 = fTemp1266 / fTemp1267;
			fRec843[0] = 2.0 * fTemp1268 - fRec843[1];
			fRec844[0] = fRec844[1] + 2.0 * (fTemp1265 * fTemp1266 / fTemp1267);
			double fRec845 = fTemp1268;
			double fTemp1269 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1045.0 * fTemp1122 + 1468.0 * fTemp1123) + fTemp1124 * (1269.0 * fTemp1126 + 2418.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1045.0 * fTemp1133 + 1468.0 * fTemp1134) + fTemp1135 * (1269.0 * fTemp1137 + 2418.0 * fTemp1138)));
			double fTemp1270 = std::tan(fConst5 * fTemp1269);
			double fTemp1271 = fTemp1270 * (fTemp1145 - fRec847[1]) + fRec846[1];
			double fTemp1272 = fTemp1270 * (fTemp1270 + fTemp1151 / fTemp1269) + 1.0;
			double fTemp1273 = fTemp1271 / fTemp1272;
			fRec846[0] = 2.0 * fTemp1273 - fRec846[1];
			fRec847[0] = fRec847[1] + 2.0 * (fTemp1270 * fTemp1271 / fTemp1272);
			double fRec848 = fTemp1273;
			double fTemp1274 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1763.0 * fTemp1122 + 2643.0 * fTemp1123) + fTemp1124 * (2351.0 * fTemp1126 + 5056.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1763.0 * fTemp1133 + 2643.0 * fTemp1134) + fTemp1135 * (2351.0 * fTemp1137 + 5056.0 * fTemp1138)));
			double fTemp1275 = std::tan(fConst5 * fTemp1274);
			double fTemp1276 = fTemp1275 * (fTemp1145 - fRec850[1]) + fRec849[1];
			double fTemp1277 = fTemp1275 * (fTemp1275 + fTemp1151 / fTemp1274) + 1.0;
			double fTemp1278 = fTemp1276 / fTemp1277;
			fRec849[0] = 2.0 * fTemp1278 - fRec849[1];
			fRec850[0] = fRec850[1] + 2.0 * (fTemp1275 * fTemp1276 / fTemp1277);
			double fRec851 = fTemp1278;
			double fTemp1279 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1828.0 * fTemp1122 + 2741.0 * fTemp1123) + fTemp1124 * (2498.0 * fTemp1126 + 5496.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1828.0 * fTemp1133 + 2741.0 * fTemp1134) + fTemp1135 * (2498.0 * fTemp1137 + 5496.0 * fTemp1138)));
			double fTemp1280 = std::tan(fConst5 * fTemp1279);
			double fTemp1281 = fTemp1280 * (fTemp1145 - fRec853[1]) + fRec852[1];
			double fTemp1282 = fTemp1280 * (fTemp1280 + fTemp1151 / fTemp1279) + 1.0;
			double fTemp1283 = fTemp1281 / fTemp1282;
			fRec852[0] = 2.0 * fTemp1283 - fRec852[1];
			fRec853[0] = fRec853[1] + 2.0 * (fTemp1280 * fTemp1281 / fTemp1282);
			double fRec854 = fTemp1283;
			double fTemp1284 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1894.0 * fTemp1122 + 2839.0 * fTemp1123) + fTemp1124 * (2645.0 * fTemp1126 + 5717.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1894.0 * fTemp1133 + 2839.0 * fTemp1134) + fTemp1135 * (2645.0 * fTemp1137 + 5717.0 * fTemp1138)));
			double fTemp1285 = std::tan(fConst5 * fTemp1284);
			double fTemp1286 = fTemp1285 * (fTemp1145 - fRec856[1]) + fRec855[1];
			double fTemp1287 = fTemp1285 * (fTemp1285 + fTemp1151 / fTemp1284) + 1.0;
			double fTemp1288 = fTemp1286 / fTemp1287;
			fRec855[0] = 2.0 * fTemp1288 - fRec855[1];
			fRec856[0] = fRec856[1] + 2.0 * (fTemp1285 * fTemp1286 / fTemp1287);
			double fRec857 = fTemp1288;
			double fTemp1289 = fTemp1110 * (fTemp1118 * (fTemp1120 * (1959.0 * fTemp1122 + 2937.0 * fTemp1123) + fTemp1124 * (2792.0 * fTemp1126 + 7035.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (1959.0 * fTemp1133 + 2937.0 * fTemp1134) + fTemp1135 * (2792.0 * fTemp1137 + 7035.0 * fTemp1138)));
			double fTemp1290 = std::tan(fConst5 * fTemp1289);
			double fTemp1291 = fTemp1290 * (fTemp1145 - fRec859[1]) + fRec858[1];
			double fTemp1292 = fTemp1290 * (fTemp1290 + fTemp1151 / fTemp1289) + 1.0;
			double fTemp1293 = fTemp1291 / fTemp1292;
			fRec858[0] = 2.0 * fTemp1293 - fRec858[1];
			fRec859[0] = fRec859[1] + 2.0 * (fTemp1290 * fTemp1291 / fTemp1292);
			double fRec860 = fTemp1293;
			double fTemp1294 = fTemp1110 * (fTemp1118 * (fTemp1120 * (2024.0 * fTemp1122 + 3.23e+03 * fTemp1123) + fTemp1124 * (3233.0 * fTemp1126 + 7255.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (2024.0 * fTemp1133 + 3.23e+03 * fTemp1134) + fTemp1135 * (3233.0 * fTemp1137 + 7255.0 * fTemp1138)));
			double fTemp1295 = std::tan(fConst5 * fTemp1294);
			double fTemp1296 = fTemp1295 * (fTemp1145 - fRec862[1]) + fRec861[1];
			double fTemp1297 = fTemp1295 * (fTemp1295 + fTemp1151 / fTemp1294) + 1.0;
			double fTemp1298 = fTemp1296 / fTemp1297;
			fRec861[0] = 2.0 * fTemp1298 - fRec861[1];
			fRec862[0] = fRec862[1] + 2.0 * (fTemp1295 * fTemp1296 / fTemp1297);
			double fRec863 = fTemp1298;
			double fTemp1299 = fTemp1110 * (fTemp1118 * (fTemp1120 * (2089.0 * fTemp1122 + 3328.0 * fTemp1123) + fTemp1124 * (3.38e+03 * fTemp1126 + 8574.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (2089.0 * fTemp1133 + 3328.0 * fTemp1134) + fTemp1135 * (3.38e+03 * fTemp1137 + 8574.0 * fTemp1138)));
			double fTemp1300 = std::tan(fConst5 * fTemp1299);
			double fTemp1301 = fTemp1300 * (fTemp1145 - fRec865[1]) + fRec864[1];
			double fTemp1302 = fTemp1300 * (fTemp1300 + fTemp1151 / fTemp1299) + 1.0;
			double fTemp1303 = fTemp1301 / fTemp1302;
			fRec864[0] = 2.0 * fTemp1303 - fRec864[1];
			fRec865[0] = fRec865[1] + 2.0 * (fTemp1300 * fTemp1301 / fTemp1302);
			double fRec866 = fTemp1303;
			double fTemp1304 = fTemp1110 * (fTemp1118 * (fTemp1120 * (2351.0 * fTemp1122 + 4013.0 * fTemp1123) + fTemp1124 * (3527.0 * fTemp1126 + 9672.0 * fTemp1127)) + fTemp1128 * (fTemp1131 * (2351.0 * fTemp1133 + 4013.0 * fTemp1134) + fTemp1135 * (3527.0 * fTemp1137 + 9672.0 * fTemp1138)));
			double fTemp1305 = std::tan(fConst5 * fTemp1304);
			double fTemp1306 = fTemp1305 * (fTemp1145 - fRec868[1]) + fRec867[1];
			double fTemp1307 = fTemp1305 * (fTemp1305 + fTemp1151 / fTemp1304) + 1.0;
			double fTemp1308 = fTemp1306 / fTemp1307;
			fRec867[0] = 2.0 * fTemp1308 - fRec867[1];
			fRec868[0] = fRec868[1] + 2.0 * (fTemp1305 * fTemp1306 / fTemp1307);
			double fRec869 = fTemp1308;
			fRec729[0] = 0.6366197723675814 * std::atan(0.03125 * (fRec751 * (fTemp1118 * (fTemp1120 * (0.00729633 * fTemp1122 + 0.00190274 * fTemp1123) + fTemp1124 * (0.00656447 * fTemp1126 + 0.00854136 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.00729633 * fTemp1133 + 0.00190274 * fTemp1134) + fTemp1135 * (0.00656447 * fTemp1137 + 0.00854136 * fTemp1138))) + fRec779 * (fTemp1118 * (fTemp1120 * (0.02313585 * fTemp1122 + 0.00348521 * fTemp1123) + fTemp1124 * (0.09585942 * fTemp1126 + 0.01776269 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.02313585 * fTemp1133 + 0.00348521 * fTemp1134) + fTemp1135 * (0.09585942 * fTemp1137 + 0.01776269 * fTemp1138))) + fRec782 * (fTemp1118 * (fTemp1120 * (0.04640077 * fTemp1122 + 0.01305707 * fTemp1123) + fTemp1124 * (0.06985491 * fTemp1126 + 0.01631748 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.04640077 * fTemp1133 + 0.01305707 * fTemp1134) + fTemp1135 * (0.06985491 * fTemp1137 + 0.01631748 * fTemp1138))) + fRec785 * (fTemp1118 * (fTemp1120 * (0.0121161 * fTemp1122 + 0.00709897 * fTemp1123) + fTemp1124 * (0.0343155 * fTemp1126 + 0.02601317 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.0121161 * fTemp1133 + 0.00709897 * fTemp1134) + fTemp1135 * (0.0343155 * fTemp1137 + 0.02601317 * fTemp1138))) + fRec788 * (fTemp1118 * (fTemp1120 * (0.01668042 * fTemp1122 + 0.01592137 * fTemp1123) + fTemp1124 * (0.01093969 * fTemp1126 + 0.02061391 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.01668042 * fTemp1133 + 0.01592137 * fTemp1134) + fTemp1135 * (0.01093969 * fTemp1137 + 0.02061391 * fTemp1138))) + fRec791 * (fTemp1118 * (fTemp1120 * (0.00848029 * fTemp1122 + 0.01670722 * fTemp1123) + fTemp1124 * (0.05126037 * fTemp1126 + 0.03283333 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.00848029 * fTemp1133 + 0.01670722 * fTemp1134) + fTemp1135 * (0.05126037 * fTemp1137 + 0.03283333 * fTemp1138))) + fRec794 * (fTemp1118 * (fTemp1120 * (0.00496045 * fTemp1122 + 0.02143791 * fTemp1123) + fTemp1124 * (0.07354127 * fTemp1126 + 0.01222045 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.00496045 * fTemp1133 + 0.02143791 * fTemp1134) + fTemp1135 * (0.07354127 * fTemp1137 + 0.01222045 * fTemp1138))) + fRec797 * (fTemp1118 * (fTemp1120 * (0.00482074 * fTemp1122 + 0.01863539 * fTemp1123) + fTemp1124 * (0.06191843 * fTemp1126 + 0.03888326 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.00482074 * fTemp1133 + 0.01863539 * fTemp1134) + fTemp1135 * (0.06191843 * fTemp1137 + 0.03888326 * fTemp1138))) + fRec800 * (fTemp1118 * (fTemp1120 * (0.02735344 * fTemp1122 + 0.02193515 * fTemp1123) + fTemp1124 * (0.07170723 * fTemp1126 + 0.04759307 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.02735344 * fTemp1133 + 0.02193515 * fTemp1134) + fTemp1135 * (0.07170723 * fTemp1137 + 0.04759307 * fTemp1138))) + fRec803 * (fTemp1118 * (fTemp1120 * (0.03067041 * fTemp1122 + 0.05785498 * fTemp1123) + fTemp1124 * (0.09954785 * fTemp1126 + 0.62411215 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.03067041 * fTemp1133 + 0.05785498 * fTemp1134) + fTemp1135 * (0.09954785 * fTemp1137 + 0.62411215 * fTemp1138))) + fRec806 * (fTemp1118 * (fTemp1120 * (0.03436227 * fTemp1122 + 0.04838698 * fTemp1123) + fTemp1124 * (0.0250452 * fTemp1126 + 0.00707754 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.03436227 * fTemp1133 + 0.04838698 * fTemp1134) + fTemp1135 * (0.0250452 * fTemp1137 + 0.00707754 * fTemp1138))) + fRec809 * (fTemp1118 * (fTemp1120 * (0.01922137 * fTemp1122 + 0.00787687 * fTemp1123) + fTemp1124 * (0.25042786 * fTemp1126 + 0.6674602 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.01922137 * fTemp1133 + 0.00787687 * fTemp1134) + fTemp1135 * (0.25042786 * fTemp1137 + 0.6674602 * fTemp1138))) + fRec812 * (fTemp1118 * (fTemp1120 * (0.05522969 * fTemp1122 + 0.06051622 * fTemp1123) + fTemp1124 * (0.02470587 * fTemp1126 + 0.01035828 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.05522969 * fTemp1133 + 0.06051622 * fTemp1134) + fTemp1135 * (0.02470587 * fTemp1137 + 0.01035828 * fTemp1138))) + fRec815 * (fTemp1118 * (fTemp1120 * (0.08153769 * fTemp1122 + 0.02426847 * fTemp1123) + fTemp1124 * (0.49828005 * fTemp1126 + 0.00749257 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.08153769 * fTemp1133 + 0.02426847 * fTemp1134) + fTemp1135 * (0.49828005 * fTemp1137 + 0.00749257 * fTemp1138))) + fRec818 * (fTemp1118 * (fTemp1120 * (fTemp1122 + 0.09843679 * fTemp1123) + fTemp1124 * (fTemp1127 + 0.0405712 * fTemp1126)) + fTemp1128 * (fTemp1131 * (fTemp1133 + 0.09843679 * fTemp1134) + fTemp1135 * (fTemp1138 + 0.0405712 * fTemp1137))) + fRec821 * (fTemp1118 * (fTemp1120 * (fTemp1123 + 0.27707616 * fTemp1122) + fTemp1124 * (fTemp1126 + 0.01216278 * fTemp1127)) + fTemp1128 * (fTemp1131 * (fTemp1134 + 0.27707616 * fTemp1133) + fTemp1135 * (fTemp1137 + 0.01216278 * fTemp1138))) + fRec824 * (fTemp1118 * (fTemp1120 * (0.04196492 * fTemp1122 + 0.75217775 * fTemp1123) + fTemp1124 * (0.07116083 * fTemp1126 + 0.01835863 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.04196492 * fTemp1133 + 0.75217775 * fTemp1134) + fTemp1135 * (0.07116083 * fTemp1137 + 0.01835863 * fTemp1138))) + fRec827 * (fTemp1118 * (fTemp1120 * (0.01797695 * fTemp1122 + 0.0640251 * fTemp1123) + fTemp1124 * (0.54357606 * fTemp1126 + 0.4053105 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.01797695 * fTemp1133 + 0.0640251 * fTemp1134) + fTemp1135 * (0.54357606 * fTemp1137 + 0.4053105 * fTemp1138))) + fRec830 * (fTemp1118 * (fTemp1120 * (0.03381146 * fTemp1122 + 0.05363475 * fTemp1123) + fTemp1124 * (0.01573797 * fTemp1126 + 0.64427134 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.03381146 * fTemp1133 + 0.05363475 * fTemp1134) + fTemp1135 * (0.01573797 * fTemp1137 + 0.64427134 * fTemp1138))) + fRec833 * (fTemp1118 * (fTemp1120 * (0.0550058 * fTemp1122 + 0.02121633 * fTemp1123) + fTemp1124 * (0.2722688 * fTemp1126 + 0.27821024 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.0550058 * fTemp1133 + 0.02121633 * fTemp1134) + fTemp1135 * (0.2722688 * fTemp1137 + 0.27821024 * fTemp1138))) + fRec836 * (fTemp1118 * (fTemp1120 * (0.02913938 * fTemp1122 + 0.03638926 * fTemp1123) + fTemp1124 * (0.01228042 * fTemp1126 + 0.08982961 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.02913938 * fTemp1133 + 0.03638926 * fTemp1134) + fTemp1135 * (0.01228042 * fTemp1137 + 0.08982961 * fTemp1138))) + fRec839 * (fTemp1118 * (fTemp1120 * (0.05834666 * fTemp1122 + 0.01772408 * fTemp1123) + fTemp1124 * (0.14442907 * fTemp1126 + 0.07338235 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.05834666 * fTemp1133 + 0.01772408 * fTemp1134) + fTemp1135 * (0.14442907 * fTemp1137 + 0.07338235 * fTemp1138))) + fRec842 * (fTemp1118 * (fTemp1120 * (0.03480883 * fTemp1122 + 0.02102163 * fTemp1123) + fTemp1124 * (0.01626654 * fTemp1126 + 0.03442368 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.03480883 * fTemp1133 + 0.02102163 * fTemp1134) + fTemp1135 * (0.01626654 * fTemp1137 + 0.03442368 * fTemp1138))) + fRec845 * (fTemp1118 * (fTemp1120 * (0.01985851 * fTemp1122 + 0.00274825 * fTemp1123) + fTemp1124 * (0.28175268 * fTemp1126 + 0.22375855 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.01985851 * fTemp1133 + 0.00274825 * fTemp1134) + fTemp1135 * (0.28175268 * fTemp1137 + 0.22375855 * fTemp1138))) + fRec848 * (fTemp1118 * (fTemp1120 * (0.02222397 * fTemp1122 + 0.00886369 * fTemp1123) + fTemp1124 * (0.02115358 * fTemp1126 + 0.02409027 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.02222397 * fTemp1133 + 0.00886369 * fTemp1134) + fTemp1135 * (0.02115358 * fTemp1137 + 0.02409027 * fTemp1138))) + fRec851 * (fTemp1118 * (fTemp1120 * (0.00722812 * fTemp1122 + 0.00161424 * fTemp1123) + fTemp1124 * (0.01233555 * fTemp1126 + 0.01528356 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.00722812 * fTemp1133 + 0.00161424 * fTemp1134) + fTemp1135 * (0.01233555 * fTemp1137 + 0.01528356 * fTemp1138))) + fRec854 * (fTemp1118 * (fTemp1120 * (0.01041008 * fTemp1122 + 0.00333966 * fTemp1123) + fTemp1124 * (0.01134687 * fTemp1126 + 0.01369543 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.01041008 * fTemp1133 + 0.00333966 * fTemp1134) + fTemp1135 * (0.01134687 * fTemp1137 + 0.01369543 * fTemp1138))) + fRec857 * (fTemp1118 * (fTemp1120 * (0.00722225 * fTemp1122 + 0.00320751 * fTemp1123) + fTemp1124 * (0.01055565 * fTemp1126 + 0.00841917 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.00722225 * fTemp1133 + 0.00320751 * fTemp1134) + fTemp1135 * (0.01055565 * fTemp1137 + 0.00841917 * fTemp1138))) + fRec860 * (fTemp1118 * (fTemp1120 * (0.00592071 * fTemp1122 + 0.00126865 * fTemp1123) + fTemp1124 * (0.03127152 * fTemp1126 + 0.02237106 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.00592071 * fTemp1133 + 0.00126865 * fTemp1134) + fTemp1135 * (0.03127152 * fTemp1137 + 0.02237106 * fTemp1138))) + fRec863 * (fTemp1118 * (fTemp1120 * (0.01158114 * fTemp1122 + 0.00132724 * fTemp1123) + fTemp1124 * (0.01587526 * fTemp1126 + 0.00969712 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.01158114 * fTemp1133 + 0.00132724 * fTemp1134) + fTemp1135 * (0.01587526 * fTemp1137 + 0.00969712 * fTemp1138))) + fRec866 * (fTemp1118 * (fTemp1120 * (0.00443968 * fTemp1122 + 0.00152525 * fTemp1123) + fTemp1124 * (0.00962998 * fTemp1126 + 0.00986048 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.00443968 * fTemp1133 + 0.00152525 * fTemp1134) + fTemp1135 * (0.00962998 * fTemp1137 + 0.00986048 * fTemp1138))) + fRec869 * (fTemp1118 * (fTemp1120 * (0.00282064 * fTemp1122 + 0.00097757 * fTemp1123) + fTemp1124 * (0.0068168 * fTemp1126 + 0.01255551 * fTemp1127)) + fTemp1128 * (fTemp1131 * (0.00282064 * fTemp1133 + 0.00097757 * fTemp1134) + fTemp1135 * (0.0068168 * fTemp1137 + 0.01255551 * fTemp1138)))));
			fRec8[0] = fRec729[0];
			double fTemp1309 = mydsp_faustpower3_f(fRec871[1]);
			fRec876[0] = std::fmod(fRec876[1], fConst0) + std::fabs(0.1 * fRec875[1]) + 0.1;
			int iTemp1310 = (fConst1 * fRec876[0]) < (fConst1 * fRec876[1]);
			iVec50[0] = 317;
			iRec877[0] = (317 - iVec50[1]) % -2147483648 + (12345 - 59 * iRec877[1]);
			fRec875[0] = fRec875[1] * double(iVec0[1] - iTemp1310) + (0.0 - 4.656612873077393e-10 * double(iRec877[0])) * double(iTemp1310 + iTemp1);
			int iTemp1311 = fRec875[0] == fRec875[1];
			fRec874[0] = fRec874[1] * double(iTemp1311) + 0.125 * fTemp3 * double(1 - iTemp1311);
			double fTemp1312 = ((fRec874[0] != fRec874[1]) ? fConst4 : fRec872[1] + -1.0);
			fRec872[0] = fTemp1312;
			fRec873[0] = ((fTemp1312 > 0.0) ? fRec873[1] + (fRec874[0] - fRec873[1]) / fTemp1312 : fRec874[0]);
			double fTemp1313 = tanh(fRec13[0] + fSlow4 * std::sin(6.283185307179586 * fRec873[0])) + 1.0;
			fVbargraph42 = FAUSTFLOAT(5e+02 * fTemp1313);
			double fTemp1314 = (fTemp6 * 0.5 * fTemp1313 + 1.0) * fRec870[1];
			fRec883[0] = std::fmod(fRec883[1], fConst0) + std::fabs(0.1 * fRec882[1]) + 0.1;
			int iTemp1315 = (fConst1 * fRec883[0]) < (fConst1 * fRec883[1]);
			iVec51[0] = 283;
			iRec884[0] = (283 - iVec51[1]) % -2147483648 + (12345 - 59 * iRec884[1]);
			fRec882[0] = fRec882[1] * double(iVec0[1] - iTemp1315) + (0.0 - 4.656612873077393e-10 * double(iRec884[0])) * double(iTemp1315 + iTemp1);
			int iTemp1316 = fRec882[0] == fRec882[1];
			fRec881[0] = fRec881[1] * double(iTemp1316) + 0.125 * fTemp3 * double(1 - iTemp1316);
			double fTemp1317 = ((fRec881[0] != fRec881[1]) ? fConst4 : fRec879[1] + -1.0);
			fRec879[0] = fTemp1317;
			fRec880[0] = ((fTemp1317 > 0.0) ? fRec880[1] + (fRec881[0] - fRec880[1]) / fTemp1317 : fRec881[0]);
			double fTemp1318 = std::pow(5e+02, tanh(fRec21[0] + fSlow4 * std::sin(6.283185307179586 * fRec880[0])));
			fVbargraph43 = FAUSTFLOAT(1e+03 * fTemp1318);
			fRec878[0] = fRec878[1] + fConst1 * fTemp1318;
			fRec889[0] = std::fmod(fRec889[1], fConst0) + std::fabs(0.1 * fRec888[1]) + 0.1;
			int iTemp1319 = (fConst1 * fRec889[0]) < (fConst1 * fRec889[1]);
			iVec52[0] = 313;
			iRec890[0] = (313 - iVec52[1]) % -2147483648 + (12345 - 59 * iRec890[1]);
			fRec888[0] = fRec888[1] * double(iVec0[1] - iTemp1319) + (0.0 - 4.656612873077393e-10 * double(iRec890[0])) * double(iTemp1319 + iTemp1);
			int iTemp1320 = fRec888[0] == fRec888[1];
			fRec887[0] = fRec887[1] * double(iTemp1320) + 0.125 * fTemp3 * double(1 - iTemp1320);
			double fTemp1321 = ((fRec887[0] != fRec887[1]) ? fConst4 : fRec885[1] + -1.0);
			fRec885[0] = fTemp1321;
			fRec886[0] = ((fTemp1321 > 0.0) ? fRec886[1] + (fRec887[0] - fRec886[1]) / fTemp1321 : fRec887[0]);
			double fTemp1322 = tanh(fRec28[0] + fSlow4 * std::sin(6.283185307179586 * fRec886[0])) + 1.0;
			fVbargraph44 = FAUSTFLOAT(5e+02 * fTemp1322);
			double fTemp1323 = std::cos(fRec878[0]) * 0.5 * fTemp1322;
			double fTemp1324 = 0.0 - (fTemp1309 + fTemp1314 + fTemp1323);
			fVec53[0] = fTemp1324;
			fRec870[0] = fTemp1324;
			fRec898[0] = std::fmod(fRec898[1], fConst0) + std::fabs(0.1 * fRec897[1]) + 0.1;
			int iTemp1325 = (fConst1 * fRec898[0]) < (fConst1 * fRec898[1]);
			iVec54[0] = 293;
			iRec899[0] = (293 - iVec54[1]) % -2147483648 + (12345 - 59 * iRec899[1]);
			fRec897[0] = fRec897[1] * double(iVec0[1] - iTemp1325) + (0.0 - 4.656612873077393e-10 * double(iRec899[0])) * double(iTemp1325 + iTemp1);
			int iTemp1326 = fRec897[0] == fRec897[1];
			fRec896[0] = fRec896[1] * double(iTemp1326) + 0.125 * fTemp3 * double(1 - iTemp1326);
			double fTemp1327 = ((fRec896[0] != fRec896[1]) ? fConst4 : fRec894[1] + -1.0);
			fRec894[0] = fTemp1327;
			fRec895[0] = ((fTemp1327 > 0.0) ? fRec895[1] + (fRec896[0] - fRec895[1]) / fTemp1327 : fRec896[0]);
			double fTemp1328 = 0.45 * (tanh(fRec38[0] + fSlow4 * std::sin(6.283185307179586 * fRec895[0])) + 1.0) + 0.1;
			fVbargraph45 = FAUSTFLOAT(1e+03 * fTemp1328);
			double fTemp1329 = fTemp1328;
			fRec904[0] = std::fmod(fRec904[1], fConst0) + std::fabs(0.1 * fRec903[1]) + 0.1;
			int iTemp1330 = (fConst1 * fRec904[0]) < (fConst1 * fRec904[1]);
			iVec55[0] = 307;
			iRec905[0] = (307 - iVec55[1]) % -2147483648 + (12345 - 59 * iRec905[1]);
			fRec903[0] = fRec903[1] * double(iVec0[1] - iTemp1330) + (0.0 - 4.656612873077393e-10 * double(iRec905[0])) * double(iTemp1330 + iTemp1);
			int iTemp1331 = fRec903[0] == fRec903[1];
			fRec902[0] = fRec902[1] * double(iTemp1331) + 0.125 * fTemp3 * double(1 - iTemp1331);
			double fTemp1332 = ((fRec902[0] != fRec902[1]) ? fConst4 : fRec900[1] + -1.0);
			fRec900[0] = fTemp1332;
			fRec901[0] = ((fTemp1332 > 0.0) ? fRec901[1] + (fRec902[0] - fRec901[1]) / fTemp1332 : fRec902[0]);
			double fTemp1333 = tanh(fRec45[0] + fSlow4 * std::sin(6.283185307179586 * fRec901[0])) + 1.0;
			fVbargraph46 = FAUSTFLOAT(5e+02 * fTemp1333);
			double fTemp1334 = 4.0 * 0.5 * fTemp1333;
			int iTemp1335 = int(fTemp1334);
			double fTemp1336 = double(iTemp1335);
			double fTemp1337 = fTemp1336 + (1.0 - fTemp1334);
			int iTemp1338 = iTemp1335 >= 2;
			double fTemp1339 = double(1 - iTemp1338);
			int iTemp1340 = iTemp1335 >= 1;
			double fTemp1341 = double(1 - iTemp1340);
			double fTemp1342 = double(iTemp1340);
			double fTemp1343 = double(iTemp1338);
			int iTemp1344 = iTemp1335 >= 3;
			double fTemp1345 = double(1 - iTemp1344);
			double fTemp1346 = double(iTemp1344);
			double fTemp1347 = fTemp1334 - fTemp1336;
			int iTemp1348 = iTemp1335 + 1;
			int iTemp1349 = iTemp1348 >= 2;
			double fTemp1350 = double(1 - iTemp1349);
			int iTemp1351 = iTemp1348 >= 1;
			double fTemp1352 = double(1 - iTemp1351);
			double fTemp1353 = double(iTemp1351);
			double fTemp1354 = double(iTemp1349);
			int iTemp1355 = iTemp1348 >= 3;
			double fTemp1356 = double(1 - iTemp1355);
			double fTemp1357 = double(iTemp1355);
			double fTemp1358 = fTemp1329 * (fTemp1337 * (fTemp1339 * (261.0 * fTemp1341 + 391.0 * fTemp1342) + fTemp1343 * (294.0 * fTemp1345 + 309.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (261.0 * fTemp1352 + 391.0 * fTemp1353) + fTemp1354 * (294.0 * fTemp1356 + 309.0 * fTemp1357)));
			double fTemp1359 = std::tan(fConst5 * fTemp1358);
			fRec906[0] = 0.995 * fRec906[1] - (fTemp1309 + fTemp1314 + fTemp1323 + fVec53[1]);
			fRec911[0] = std::fmod(fRec911[1], fConst0) + std::fabs(0.1 * fRec910[1]) + 0.1;
			int iTemp1360 = (fConst1 * fRec911[0]) < (fConst1 * fRec911[1]);
			iVec56[0] = 331;
			iRec912[0] = (331 - iVec56[1]) % -2147483648 + (12345 - 59 * iRec912[1]);
			fRec910[0] = fRec910[1] * double(iVec0[1] - iTemp1360) + (0.0 - 4.656612873077393e-10 * double(iRec912[0])) * double(iTemp1360 + iTemp1);
			int iTemp1361 = fRec910[0] == fRec910[1];
			fRec909[0] = fRec909[1] * double(iTemp1361) + 0.125 * fTemp3 * double(1 - iTemp1361);
			double fTemp1362 = ((fRec909[0] != fRec909[1]) ? fConst4 : fRec907[1] + -1.0);
			fRec907[0] = fTemp1362;
			fRec908[0] = ((fTemp1362 > 0.0) ? fRec908[1] + (fRec909[0] - fRec908[1]) / fTemp1362 : fRec909[0]);
			double fTemp1363 = std::pow(1e+03, tanh(fRec53[0] + fSlow4 * std::sin(6.283185307179586 * fRec908[0])));
			fVbargraph47 = FAUSTFLOAT(fTemp1363);
			double fTemp1364 = fRec906[0] * fTemp1363;
			double fTemp1365 = fTemp1359 * (fTemp1364 - fRec892[1]) + fRec891[1];
			fRec917[0] = std::fmod(fRec917[1], fConst0) + std::fabs(0.1 * fRec916[1]) + 0.1;
			int iTemp1366 = (fConst1 * fRec917[0]) < (fConst1 * fRec917[1]);
			iVec57[0] = 311;
			iRec918[0] = (311 - iVec57[1]) % -2147483648 + (12345 - 59 * iRec918[1]);
			fRec916[0] = fRec916[1] * double(iVec0[1] - iTemp1366) + (0.0 - 4.656612873077393e-10 * double(iRec918[0])) * double(iTemp1366 + iTemp1);
			int iTemp1367 = fRec916[0] == fRec916[1];
			fRec915[0] = fRec915[1] * double(iTemp1367) + 0.125 * fTemp3 * double(1 - iTemp1367);
			double fTemp1368 = ((fRec915[0] != fRec915[1]) ? fConst4 : fRec913[1] + -1.0);
			fRec913[0] = fTemp1368;
			fRec914[0] = ((fTemp1368 > 0.0) ? fRec914[1] + (fRec915[0] - fRec914[1]) / fTemp1368 : fRec915[0]);
			double fTemp1369 = std::pow(1e+02, tanh(fRec60[0] + fSlow4 * std::sin(6.283185307179586 * fRec914[0])));
			fVbargraph48 = FAUSTFLOAT(fTemp1369);
			double fTemp1370 = std::max<double>(2.220446049250313e-16, fTemp1369);
			double fTemp1371 = fTemp1359 * (fTemp1359 + fTemp1370 / fTemp1358) + 1.0;
			double fTemp1372 = fTemp1365 / fTemp1371;
			fRec891[0] = 2.0 * fTemp1372 - fRec891[1];
			fRec892[0] = fRec892[1] + 2.0 * (fTemp1359 * fTemp1365 / fTemp1371);
			double fRec893 = fTemp1372;
			double fTemp1373 = fTemp1329 * (fTemp1337 * (fTemp1339 * (196.0 * fTemp1341 + 293.0 * fTemp1342) + fTemp1343 * (203.0 * fTemp1345 + 2.2e+02 * fTemp1346)) + fTemp1347 * (fTemp1350 * (196.0 * fTemp1352 + 293.0 * fTemp1353) + fTemp1354 * (203.0 * fTemp1356 + 2.2e+02 * fTemp1357)));
			double fTemp1374 = std::tan(fConst5 * fTemp1373);
			double fTemp1375 = fTemp1374 * (fTemp1364 - fRec920[1]) + fRec919[1];
			double fTemp1376 = fTemp1374 * (fTemp1374 + fTemp1370 / fTemp1373) + 1.0;
			double fTemp1377 = fTemp1375 / fTemp1376;
			fRec919[0] = 2.0 * fTemp1377 - fRec919[1];
			fRec920[0] = fRec920[1] + 2.0 * (fTemp1374 * fTemp1375 / fTemp1376);
			double fRec921 = fTemp1377;
			double fTemp1378 = fTemp1329 * (fTemp1337 * (fTemp1339 * (131.0 * fTemp1341 + 195.0 * fTemp1342) + fTemp1343 * (147.0 * fTemp1345 + 1.3e+02 * fTemp1346)) + fTemp1347 * (fTemp1350 * (131.0 * fTemp1352 + 195.0 * fTemp1353) + fTemp1354 * (147.0 * fTemp1356 + 1.3e+02 * fTemp1357)));
			double fTemp1379 = std::tan(fConst5 * fTemp1378);
			double fTemp1380 = fTemp1379 * (fTemp1364 - fRec923[1]) + fRec922[1];
			double fTemp1381 = fTemp1379 * (fTemp1379 + fTemp1370 / fTemp1378) + 1.0;
			double fTemp1382 = fTemp1380 / fTemp1381;
			fRec922[0] = 2.0 * fTemp1382 - fRec922[1];
			fRec923[0] = fRec923[1] + 2.0 * (fTemp1379 * fTemp1380 / fTemp1381);
			double fRec924 = fTemp1382;
			double fTemp1383 = (fTemp1337 * ((65.0 * fTemp1341 + 98.0 * fTemp1342) * fTemp1339 + (53.0 * fTemp1345 + 5e+01 * fTemp1346) * fTemp1343) + fTemp1347 * ((65.0 * fTemp1352 + 98.0 * fTemp1353) * fTemp1350 + (53.0 * fTemp1356 + 5e+01 * fTemp1357) * fTemp1354)) * fTemp1329;
			double fTemp1384 = std::tan(fConst5 * fTemp1383);
			double fTemp1385 = fTemp1384 * (fTemp1364 - fRec926[1]) + fRec925[1];
			double fTemp1386 = fTemp1384 * (fTemp1384 + fTemp1370 / fTemp1383) + 1.0;
			double fTemp1387 = fTemp1385 / fTemp1386;
			fRec925[0] = 2.0 * fTemp1387 - fRec925[1];
			fRec926[0] = fRec926[1] + 2.0 * (fTemp1384 * fTemp1385 / fTemp1386);
			double fRec927 = fTemp1387;
			double fTemp1388 = fTemp1329 * (fTemp1337 * (fTemp1339 * (849.0 * fTemp1341 + 1174.0 * fTemp1342) + fTemp1343 * (1028.0 * fTemp1345 + 1759.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (849.0 * fTemp1352 + 1174.0 * fTemp1353) + fTemp1354 * (1028.0 * fTemp1356 + 1759.0 * fTemp1357)));
			double fTemp1389 = std::tan(fConst5 * fTemp1388);
			double fTemp1390 = fTemp1389 * (fTemp1364 - fRec929[1]) + fRec928[1];
			double fTemp1391 = fTemp1389 * (fTemp1389 + fTemp1370 / fTemp1388) + 1.0;
			double fTemp1392 = fTemp1390 / fTemp1391;
			fRec928[0] = 2.0 * fTemp1392 - fRec928[1];
			fRec929[0] = fRec929[1] + 2.0 * (fTemp1389 * fTemp1390 / fTemp1391);
			double fRec930 = fTemp1392;
			double fTemp1393 = fTemp1329 * (fTemp1337 * (fTemp1339 * (784.0 * fTemp1341 + 1076.0 * fTemp1342) + fTemp1343 * (961.0 * fTemp1345 + 1539.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (784.0 * fTemp1352 + 1076.0 * fTemp1353) + fTemp1354 * (961.0 * fTemp1356 + 1539.0 * fTemp1357)));
			double fTemp1394 = std::tan(fConst5 * fTemp1393);
			double fTemp1395 = fTemp1394 * (fTemp1364 - fRec932[1]) + fRec931[1];
			double fTemp1396 = fTemp1394 * (fTemp1394 + fTemp1370 / fTemp1393) + 1.0;
			double fTemp1397 = fTemp1395 / fTemp1396;
			fRec931[0] = 2.0 * fTemp1397 - fRec931[1];
			fRec932[0] = fRec932[1] + 2.0 * (fTemp1394 * fTemp1395 / fTemp1396);
			double fRec933 = fTemp1397;
			double fTemp1398 = fTemp1329 * (fTemp1337 * (fTemp1339 * (718.0 * fTemp1341 + 979.0 * fTemp1342) + fTemp1343 * (882.0 * fTemp1345 + 1319.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (718.0 * fTemp1352 + 979.0 * fTemp1353) + fTemp1354 * (882.0 * fTemp1356 + 1319.0 * fTemp1357)));
			double fTemp1399 = std::tan(fConst5 * fTemp1398);
			double fTemp1400 = fTemp1399 * (fTemp1364 - fRec935[1]) + fRec934[1];
			double fTemp1401 = fTemp1399 * (fTemp1399 + fTemp1370 / fTemp1398) + 1.0;
			double fTemp1402 = fTemp1400 / fTemp1401;
			fRec934[0] = 2.0 * fTemp1402 - fRec934[1];
			fRec935[0] = fRec935[1] + 2.0 * (fTemp1399 * fTemp1400 / fTemp1401);
			double fRec936 = fTemp1402;
			double fTemp1403 = fTemp1329 * (fTemp1337 * (fTemp1339 * (653.0 * fTemp1341 + 8.8e+02 * fTemp1342) + fTemp1343 * (785.0 * fTemp1345 + 1099.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (653.0 * fTemp1352 + 8.8e+02 * fTemp1353) + fTemp1354 * (785.0 * fTemp1356 + 1099.0 * fTemp1357)));
			double fTemp1404 = std::tan(fConst5 * fTemp1403);
			double fTemp1405 = fTemp1404 * (fTemp1364 - fRec938[1]) + fRec937[1];
			double fTemp1406 = fTemp1404 * (fTemp1404 + fTemp1370 / fTemp1403) + 1.0;
			double fTemp1407 = fTemp1405 / fTemp1406;
			fRec937[0] = 2.0 * fTemp1407 - fRec937[1];
			fRec938[0] = fRec938[1] + 2.0 * (fTemp1404 * fTemp1405 / fTemp1406);
			double fRec939 = fTemp1407;
			double fTemp1408 = fTemp1329 * (fTemp1337 * (fTemp1339 * (588.0 * fTemp1341 + 783.0 * fTemp1342) + fTemp1343 * (735.0 * fTemp1345 + 879.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (588.0 * fTemp1352 + 783.0 * fTemp1353) + fTemp1354 * (735.0 * fTemp1356 + 879.0 * fTemp1357)));
			double fTemp1409 = std::tan(fConst5 * fTemp1408);
			double fTemp1410 = fTemp1409 * (fTemp1364 - fRec941[1]) + fRec940[1];
			double fTemp1411 = fTemp1409 * (fTemp1409 + fTemp1370 / fTemp1408) + 1.0;
			double fTemp1412 = fTemp1410 / fTemp1411;
			fRec940[0] = 2.0 * fTemp1412 - fRec940[1];
			fRec941[0] = fRec941[1] + 2.0 * (fTemp1409 * fTemp1410 / fTemp1411);
			double fRec942 = fTemp1412;
			double fTemp1413 = fTemp1329 * (fTemp1337 * (fTemp1339 * (522.0 * fTemp1341 + 685.0 * fTemp1342) + fTemp1343 * (588.0 * fTemp1345 + 659.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (522.0 * fTemp1352 + 685.0 * fTemp1353) + fTemp1354 * (588.0 * fTemp1356 + 659.0 * fTemp1357)));
			double fTemp1414 = std::tan(fConst5 * fTemp1413);
			double fTemp1415 = fTemp1414 * (fTemp1364 - fRec944[1]) + fRec943[1];
			double fTemp1416 = fTemp1414 * (fTemp1414 + fTemp1370 / fTemp1413) + 1.0;
			double fTemp1417 = fTemp1415 / fTemp1416;
			fRec943[0] = 2.0 * fTemp1417 - fRec943[1];
			fRec944[0] = fRec944[1] + 2.0 * (fTemp1414 * fTemp1415 / fTemp1416);
			double fRec945 = fTemp1417;
			double fTemp1418 = fTemp1329 * (fTemp1337 * (fTemp1339 * (457.0 * fTemp1341 + 587.0 * fTemp1342) + fTemp1343 * (534.0 * fTemp1345 + 538.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (457.0 * fTemp1352 + 587.0 * fTemp1353) + fTemp1354 * (534.0 * fTemp1356 + 538.0 * fTemp1357)));
			double fTemp1419 = std::tan(fConst5 * fTemp1418);
			double fTemp1420 = fTemp1419 * (fTemp1364 - fRec947[1]) + fRec946[1];
			double fTemp1421 = fTemp1419 * (fTemp1419 + fTemp1370 / fTemp1418) + 1.0;
			double fTemp1422 = fTemp1420 / fTemp1421;
			fRec946[0] = 2.0 * fTemp1422 - fRec946[1];
			fRec947[0] = fRec947[1] + 2.0 * (fTemp1419 * fTemp1420 / fTemp1421);
			double fRec948 = fTemp1422;
			double fTemp1423 = fTemp1329 * (fTemp1337 * (fTemp1339 * (392.0 * fTemp1341 + 537.0 * fTemp1342) + fTemp1343 * (441.0 * fTemp1345 + 439.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (392.0 * fTemp1352 + 537.0 * fTemp1353) + fTemp1354 * (441.0 * fTemp1356 + 439.0 * fTemp1357)));
			double fTemp1424 = std::tan(fConst5 * fTemp1423);
			double fTemp1425 = fTemp1424 * (fTemp1364 - fRec950[1]) + fRec949[1];
			double fTemp1426 = fTemp1424 * (fTemp1424 + fTemp1370 / fTemp1423) + 1.0;
			double fTemp1427 = fTemp1425 / fTemp1426;
			fRec949[0] = 2.0 * fTemp1427 - fRec949[1];
			fRec950[0] = fRec950[1] + 2.0 * (fTemp1424 * fTemp1425 / fTemp1426);
			double fRec951 = fTemp1427;
			double fTemp1428 = fTemp1329 * (fTemp1337 * (fTemp1339 * (326.0 * fTemp1341 + 489.0 * fTemp1342) + fTemp1343 * (367.0 * fTemp1345 + 368.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (326.0 * fTemp1352 + 489.0 * fTemp1353) + fTemp1354 * (367.0 * fTemp1356 + 368.0 * fTemp1357)));
			double fTemp1429 = std::tan(fConst5 * fTemp1428);
			double fTemp1430 = fTemp1429 * (fTemp1364 - fRec953[1]) + fRec952[1];
			double fTemp1431 = fTemp1429 * (fTemp1429 + fTemp1370 / fTemp1428) + 1.0;
			double fTemp1432 = fTemp1430 / fTemp1431;
			fRec952[0] = 2.0 * fTemp1432 - fRec952[1];
			fRec953[0] = fRec953[1] + 2.0 * (fTemp1429 * fTemp1430 / fTemp1431);
			double fRec954 = fTemp1432;
			double fTemp1433 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1371.0 * fTemp1341 + 1958.0 * fTemp1342) + fTemp1343 * (1855.0 * fTemp1345 + 3517.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1371.0 * fTemp1352 + 1958.0 * fTemp1353) + fTemp1354 * (1855.0 * fTemp1356 + 3517.0 * fTemp1357)));
			double fTemp1434 = std::tan(fConst5 * fTemp1433);
			double fTemp1435 = fTemp1434 * (fTemp1364 - fRec956[1]) + fRec955[1];
			double fTemp1436 = fTemp1434 * (fTemp1434 + fTemp1370 / fTemp1433) + 1.0;
			double fTemp1437 = fTemp1435 / fTemp1436;
			fRec955[0] = 2.0 * fTemp1437 - fRec955[1];
			fRec956[0] = fRec956[1] + 2.0 * (fTemp1434 * fTemp1435 / fTemp1436);
			double fRec957 = fTemp1437;
			double fTemp1438 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1306.0 * fTemp1341 + 1.86e+03 * fTemp1342) + fTemp1343 * (1764.0 * fTemp1345 + 3298.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1306.0 * fTemp1352 + 1.86e+03 * fTemp1353) + fTemp1354 * (1764.0 * fTemp1356 + 3298.0 * fTemp1357)));
			double fTemp1439 = std::tan(fConst5 * fTemp1438);
			double fTemp1440 = fTemp1439 * (fTemp1364 - fRec959[1]) + fRec958[1];
			double fTemp1441 = fTemp1439 * (fTemp1439 + fTemp1370 / fTemp1438) + 1.0;
			double fTemp1442 = fTemp1440 / fTemp1441;
			fRec958[0] = 2.0 * fTemp1442 - fRec958[1];
			fRec959[0] = fRec959[1] + 2.0 * (fTemp1439 * fTemp1440 / fTemp1441);
			double fRec960 = fTemp1442;
			double fTemp1443 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1241.0 * fTemp1341 + 1762.0 * fTemp1342) + fTemp1343 * (1617.0 * fTemp1345 + 3078.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1241.0 * fTemp1352 + 1762.0 * fTemp1353) + fTemp1354 * (1617.0 * fTemp1356 + 3078.0 * fTemp1357)));
			double fTemp1444 = std::tan(fConst5 * fTemp1443);
			double fTemp1445 = fTemp1444 * (fTemp1364 - fRec962[1]) + fRec961[1];
			double fTemp1446 = fTemp1444 * (fTemp1444 + fTemp1370 / fTemp1443) + 1.0;
			double fTemp1447 = fTemp1445 / fTemp1446;
			fRec961[0] = 2.0 * fTemp1447 - fRec961[1];
			fRec962[0] = fRec962[1] + 2.0 * (fTemp1444 * fTemp1445 / fTemp1446);
			double fRec963 = fTemp1447;
			double fTemp1448 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1175.0 * fTemp1341 + 1664.0 * fTemp1342) + fTemp1343 * (1.47e+03 * fTemp1345 + 2858.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1175.0 * fTemp1352 + 1664.0 * fTemp1353) + fTemp1354 * (1.47e+03 * fTemp1356 + 2858.0 * fTemp1357)));
			double fTemp1449 = std::tan(fConst5 * fTemp1448);
			double fTemp1450 = fTemp1449 * (fTemp1364 - fRec965[1]) + fRec964[1];
			double fTemp1451 = fTemp1449 * (fTemp1449 + fTemp1370 / fTemp1448) + 1.0;
			double fTemp1452 = fTemp1450 / fTemp1451;
			fRec964[0] = 2.0 * fTemp1452 - fRec964[1];
			fRec965[0] = fRec965[1] + 2.0 * (fTemp1449 * fTemp1450 / fTemp1451);
			double fRec966 = fTemp1452;
			double fTemp1453 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1.11e+03 * fTemp1341 + 1566.0 * fTemp1342) + fTemp1343 * (1323.0 * fTemp1345 + 2638.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1.11e+03 * fTemp1352 + 1566.0 * fTemp1353) + fTemp1354 * (1323.0 * fTemp1356 + 2638.0 * fTemp1357)));
			double fTemp1454 = std::tan(fConst5 * fTemp1453);
			double fTemp1455 = fTemp1454 * (fTemp1364 - fRec968[1]) + fRec967[1];
			double fTemp1456 = fTemp1454 * (fTemp1454 + fTemp1370 / fTemp1453) + 1.0;
			double fTemp1457 = fTemp1455 / fTemp1456;
			fRec967[0] = 2.0 * fTemp1457 - fRec967[1];
			fRec968[0] = fRec968[1] + 2.0 * (fTemp1454 * fTemp1455 / fTemp1456);
			double fRec969 = fTemp1457;
			double fTemp1458 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1045.0 * fTemp1341 + 1468.0 * fTemp1342) + fTemp1343 * (1269.0 * fTemp1345 + 2418.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1045.0 * fTemp1352 + 1468.0 * fTemp1353) + fTemp1354 * (1269.0 * fTemp1356 + 2418.0 * fTemp1357)));
			double fTemp1459 = std::tan(fConst5 * fTemp1458);
			double fTemp1460 = fTemp1459 * (fTemp1364 - fRec971[1]) + fRec970[1];
			double fTemp1461 = fTemp1459 * (fTemp1459 + fTemp1370 / fTemp1458) + 1.0;
			double fTemp1462 = fTemp1460 / fTemp1461;
			fRec970[0] = 2.0 * fTemp1462 - fRec970[1];
			fRec971[0] = fRec971[1] + 2.0 * (fTemp1459 * fTemp1460 / fTemp1461);
			double fRec972 = fTemp1462;
			double fTemp1463 = fTemp1329 * (fTemp1337 * (fTemp1339 * (979.0 * fTemp1341 + 1371.0 * fTemp1342) + fTemp1343 * (1175.0 * fTemp1345 + 2198.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (979.0 * fTemp1352 + 1371.0 * fTemp1353) + fTemp1354 * (1175.0 * fTemp1356 + 2198.0 * fTemp1357)));
			double fTemp1464 = std::tan(fConst5 * fTemp1463);
			double fTemp1465 = fTemp1464 * (fTemp1364 - fRec974[1]) + fRec973[1];
			double fTemp1466 = fTemp1464 * (fTemp1464 + fTemp1370 / fTemp1463) + 1.0;
			double fTemp1467 = fTemp1465 / fTemp1466;
			fRec973[0] = 2.0 * fTemp1467 - fRec973[1];
			fRec974[0] = fRec974[1] + 2.0 * (fTemp1464 * fTemp1465 / fTemp1466);
			double fRec975 = fTemp1467;
			double fTemp1468 = fTemp1329 * (fTemp1337 * (fTemp1339 * (914.0 * fTemp1341 + 1272.0 * fTemp1342) + fTemp1343 * (1078.0 * fTemp1345 + 1978.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (914.0 * fTemp1352 + 1272.0 * fTemp1353) + fTemp1354 * (1078.0 * fTemp1356 + 1978.0 * fTemp1357)));
			double fTemp1469 = std::tan(fConst5 * fTemp1468);
			double fTemp1470 = fTemp1469 * (fTemp1364 - fRec977[1]) + fRec976[1];
			double fTemp1471 = fTemp1469 * (fTemp1469 + fTemp1370 / fTemp1468) + 1.0;
			double fTemp1472 = fTemp1470 / fTemp1471;
			fRec976[0] = 2.0 * fTemp1472 - fRec976[1];
			fRec977[0] = fRec977[1] + 2.0 * (fTemp1469 * fTemp1470 / fTemp1471);
			double fRec978 = fTemp1472;
			double fTemp1473 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1894.0 * fTemp1341 + 2839.0 * fTemp1342) + fTemp1343 * (2645.0 * fTemp1345 + 5717.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1894.0 * fTemp1352 + 2839.0 * fTemp1353) + fTemp1354 * (2645.0 * fTemp1356 + 5717.0 * fTemp1357)));
			double fTemp1474 = std::tan(fConst5 * fTemp1473);
			double fTemp1475 = fTemp1474 * (fTemp1364 - fRec980[1]) + fRec979[1];
			double fTemp1476 = fTemp1474 * (fTemp1474 + fTemp1370 / fTemp1473) + 1.0;
			double fTemp1477 = fTemp1475 / fTemp1476;
			fRec979[0] = 2.0 * fTemp1477 - fRec979[1];
			fRec980[0] = fRec980[1] + 2.0 * (fTemp1474 * fTemp1475 / fTemp1476);
			double fRec981 = fTemp1477;
			double fTemp1478 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1828.0 * fTemp1341 + 2741.0 * fTemp1342) + fTemp1343 * (2498.0 * fTemp1345 + 5496.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1828.0 * fTemp1352 + 2741.0 * fTemp1353) + fTemp1354 * (2498.0 * fTemp1356 + 5496.0 * fTemp1357)));
			double fTemp1479 = std::tan(fConst5 * fTemp1478);
			double fTemp1480 = fTemp1479 * (fTemp1364 - fRec983[1]) + fRec982[1];
			double fTemp1481 = fTemp1479 * (fTemp1479 + fTemp1370 / fTemp1478) + 1.0;
			double fTemp1482 = fTemp1480 / fTemp1481;
			fRec982[0] = 2.0 * fTemp1482 - fRec982[1];
			fRec983[0] = fRec983[1] + 2.0 * (fTemp1479 * fTemp1480 / fTemp1481);
			double fRec984 = fTemp1482;
			double fTemp1483 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1763.0 * fTemp1341 + 2643.0 * fTemp1342) + fTemp1343 * (2351.0 * fTemp1345 + 5056.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1763.0 * fTemp1352 + 2643.0 * fTemp1353) + fTemp1354 * (2351.0 * fTemp1356 + 5056.0 * fTemp1357)));
			double fTemp1484 = std::tan(fConst5 * fTemp1483);
			double fTemp1485 = fTemp1484 * (fTemp1364 - fRec986[1]) + fRec985[1];
			double fTemp1486 = fTemp1484 * (fTemp1484 + fTemp1370 / fTemp1483) + 1.0;
			double fTemp1487 = fTemp1485 / fTemp1486;
			fRec985[0] = 2.0 * fTemp1487 - fRec985[1];
			fRec986[0] = fRec986[1] + 2.0 * (fTemp1484 * fTemp1485 / fTemp1486);
			double fRec987 = fTemp1487;
			double fTemp1488 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1698.0 * fTemp1341 + 2349.0 * fTemp1342) + fTemp1343 * (2273.0 * fTemp1345 + 4617.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1698.0 * fTemp1352 + 2349.0 * fTemp1353) + fTemp1354 * (2273.0 * fTemp1356 + 4617.0 * fTemp1357)));
			double fTemp1489 = std::tan(fConst5 * fTemp1488);
			double fTemp1490 = fTemp1489 * (fTemp1364 - fRec989[1]) + fRec988[1];
			double fTemp1491 = fTemp1489 * (fTemp1489 + fTemp1370 / fTemp1488) + 1.0;
			double fTemp1492 = fTemp1490 / fTemp1491;
			fRec988[0] = 2.0 * fTemp1492 - fRec988[1];
			fRec989[0] = fRec989[1] + 2.0 * (fTemp1489 * fTemp1490 / fTemp1491);
			double fRec990 = fTemp1492;
			double fTemp1493 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1632.0 * fTemp1341 + 2252.0 * fTemp1342) + fTemp1343 * (2204.0 * fTemp1345 + 4177.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1632.0 * fTemp1352 + 2252.0 * fTemp1353) + fTemp1354 * (2204.0 * fTemp1356 + 4177.0 * fTemp1357)));
			double fTemp1494 = std::tan(fConst5 * fTemp1493);
			double fTemp1495 = fTemp1494 * (fTemp1364 - fRec992[1]) + fRec991[1];
			double fTemp1496 = fTemp1494 * (fTemp1494 + fTemp1370 / fTemp1493) + 1.0;
			double fTemp1497 = fTemp1495 / fTemp1496;
			fRec991[0] = 2.0 * fTemp1497 - fRec991[1];
			fRec992[0] = fRec992[1] + 2.0 * (fTemp1494 * fTemp1495 / fTemp1496);
			double fRec993 = fTemp1497;
			double fTemp1498 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1567.0 * fTemp1341 + 2153.0 * fTemp1342) + fTemp1343 * (2054.0 * fTemp1345 + 3957.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1567.0 * fTemp1352 + 2153.0 * fTemp1353) + fTemp1354 * (2054.0 * fTemp1356 + 3957.0 * fTemp1357)));
			double fTemp1499 = std::tan(fConst5 * fTemp1498);
			double fTemp1500 = fTemp1499 * (fTemp1364 - fRec995[1]) + fRec994[1];
			double fTemp1501 = fTemp1499 * (fTemp1499 + fTemp1370 / fTemp1498) + 1.0;
			double fTemp1502 = fTemp1500 / fTemp1501;
			fRec994[0] = 2.0 * fTemp1502 - fRec994[1];
			fRec995[0] = fRec995[1] + 2.0 * (fTemp1499 * fTemp1500 / fTemp1501);
			double fRec996 = fTemp1502;
			double fTemp1503 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1502.0 * fTemp1341 + 2056.0 * fTemp1342) + fTemp1343 * (1.91e+03 * fTemp1345 + 3737.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1502.0 * fTemp1352 + 2056.0 * fTemp1353) + fTemp1354 * (1.91e+03 * fTemp1356 + 3737.0 * fTemp1357)));
			double fTemp1504 = std::tan(fConst5 * fTemp1503);
			double fTemp1505 = fTemp1504 * (fTemp1364 - fRec998[1]) + fRec997[1];
			double fTemp1506 = fTemp1504 * (fTemp1504 + fTemp1370 / fTemp1503) + 1.0;
			double fTemp1507 = fTemp1505 / fTemp1506;
			fRec997[0] = 2.0 * fTemp1507 - fRec997[1];
			fRec998[0] = fRec998[1] + 2.0 * (fTemp1504 * fTemp1505 / fTemp1506);
			double fRec999 = fTemp1507;
			double fTemp1508 = fTemp1329 * (fTemp1337 * (fTemp1339 * (1959.0 * fTemp1341 + 2937.0 * fTemp1342) + fTemp1343 * (2792.0 * fTemp1345 + 7035.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (1959.0 * fTemp1352 + 2937.0 * fTemp1353) + fTemp1354 * (2792.0 * fTemp1356 + 7035.0 * fTemp1357)));
			double fTemp1509 = std::tan(fConst5 * fTemp1508);
			double fTemp1510 = fTemp1509 * (fTemp1364 - fRec1001[1]) + fRec1000[1];
			double fTemp1511 = fTemp1509 * (fTemp1509 + fTemp1370 / fTemp1508) + 1.0;
			double fTemp1512 = fTemp1510 / fTemp1511;
			fRec1000[0] = 2.0 * fTemp1512 - fRec1000[1];
			fRec1001[0] = fRec1001[1] + 2.0 * (fTemp1509 * fTemp1510 / fTemp1511);
			double fRec1002 = fTemp1512;
			double fTemp1513 = fTemp1329 * (fTemp1337 * (fTemp1339 * (2024.0 * fTemp1341 + 3.23e+03 * fTemp1342) + fTemp1343 * (3233.0 * fTemp1345 + 7255.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (2024.0 * fTemp1352 + 3.23e+03 * fTemp1353) + fTemp1354 * (3233.0 * fTemp1356 + 7255.0 * fTemp1357)));
			double fTemp1514 = std::tan(fConst5 * fTemp1513);
			double fTemp1515 = fTemp1514 * (fTemp1364 - fRec1004[1]) + fRec1003[1];
			double fTemp1516 = fTemp1514 * (fTemp1514 + fTemp1370 / fTemp1513) + 1.0;
			double fTemp1517 = fTemp1515 / fTemp1516;
			fRec1003[0] = 2.0 * fTemp1517 - fRec1003[1];
			fRec1004[0] = fRec1004[1] + 2.0 * (fTemp1514 * fTemp1515 / fTemp1516);
			double fRec1005 = fTemp1517;
			double fTemp1518 = fTemp1329 * (fTemp1337 * (fTemp1339 * (2089.0 * fTemp1341 + 3328.0 * fTemp1342) + fTemp1343 * (3.38e+03 * fTemp1345 + 8574.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (2089.0 * fTemp1352 + 3328.0 * fTemp1353) + fTemp1354 * (3.38e+03 * fTemp1356 + 8574.0 * fTemp1357)));
			double fTemp1519 = std::tan(fConst5 * fTemp1518);
			double fTemp1520 = fTemp1519 * (fTemp1364 - fRec1007[1]) + fRec1006[1];
			double fTemp1521 = fTemp1519 * (fTemp1519 + fTemp1370 / fTemp1518) + 1.0;
			double fTemp1522 = fTemp1520 / fTemp1521;
			fRec1006[0] = 2.0 * fTemp1522 - fRec1006[1];
			fRec1007[0] = fRec1007[1] + 2.0 * (fTemp1519 * fTemp1520 / fTemp1521);
			double fRec1008 = fTemp1522;
			double fTemp1523 = fTemp1329 * (fTemp1337 * (fTemp1339 * (2351.0 * fTemp1341 + 4013.0 * fTemp1342) + fTemp1343 * (3527.0 * fTemp1345 + 9672.0 * fTemp1346)) + fTemp1347 * (fTemp1350 * (2351.0 * fTemp1352 + 4013.0 * fTemp1353) + fTemp1354 * (3527.0 * fTemp1356 + 9672.0 * fTemp1357)));
			double fTemp1524 = std::tan(fConst5 * fTemp1523);
			double fTemp1525 = fTemp1524 * (fTemp1364 - fRec1010[1]) + fRec1009[1];
			double fTemp1526 = fTemp1524 * (fTemp1524 + fTemp1370 / fTemp1523) + 1.0;
			double fTemp1527 = fTemp1525 / fTemp1526;
			fRec1009[0] = 2.0 * fTemp1527 - fRec1009[1];
			fRec1010[0] = fRec1010[1] + 2.0 * (fTemp1524 * fTemp1525 / fTemp1526);
			double fRec1011 = fTemp1527;
			fRec871[0] = 0.6366197723675814 * std::atan(0.03125 * (fRec893 * (fTemp1337 * (fTemp1339 * (0.08153769 * fTemp1341 + 0.02426847 * fTemp1342) + fTemp1343 * (0.49828005 * fTemp1345 + 0.00749257 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.08153769 * fTemp1352 + 0.02426847 * fTemp1353) + fTemp1354 * (0.49828005 * fTemp1356 + 0.00749257 * fTemp1357))) + fRec921 * (fTemp1337 * (fTemp1339 * (fTemp1341 + 0.09843679 * fTemp1342) + fTemp1343 * (fTemp1346 + 0.0405712 * fTemp1345)) + fTemp1347 * (fTemp1350 * (fTemp1352 + 0.09843679 * fTemp1353) + fTemp1354 * (fTemp1357 + 0.0405712 * fTemp1356))) + fRec924 * (fTemp1337 * (fTemp1339 * (fTemp1342 + 0.27707616 * fTemp1341) + fTemp1343 * (fTemp1345 + 0.01216278 * fTemp1346)) + fTemp1347 * (fTemp1350 * (fTemp1353 + 0.27707616 * fTemp1352) + fTemp1354 * (fTemp1356 + 0.01216278 * fTemp1357))) + fRec927 * (fTemp1337 * (fTemp1339 * (0.04196492 * fTemp1341 + 0.75217775 * fTemp1342) + fTemp1343 * (0.07116083 * fTemp1345 + 0.01835863 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.04196492 * fTemp1352 + 0.75217775 * fTemp1353) + fTemp1354 * (0.07116083 * fTemp1356 + 0.01835863 * fTemp1357))) + fRec930 * (fTemp1337 * (fTemp1339 * (0.05834666 * fTemp1341 + 0.01772408 * fTemp1342) + fTemp1343 * (0.14442907 * fTemp1345 + 0.07338235 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.05834666 * fTemp1352 + 0.01772408 * fTemp1353) + fTemp1354 * (0.14442907 * fTemp1356 + 0.07338235 * fTemp1357))) + fRec933 * (fTemp1337 * (fTemp1339 * (0.02913938 * fTemp1341 + 0.03638926 * fTemp1342) + fTemp1343 * (0.01228042 * fTemp1345 + 0.08982961 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.02913938 * fTemp1352 + 0.03638926 * fTemp1353) + fTemp1354 * (0.01228042 * fTemp1356 + 0.08982961 * fTemp1357))) + fRec936 * (fTemp1337 * (fTemp1339 * (0.0550058 * fTemp1341 + 0.02121633 * fTemp1342) + fTemp1343 * (0.2722688 * fTemp1345 + 0.27821024 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.0550058 * fTemp1352 + 0.02121633 * fTemp1353) + fTemp1354 * (0.2722688 * fTemp1356 + 0.27821024 * fTemp1357))) + fRec939 * (fTemp1337 * (fTemp1339 * (0.03381146 * fTemp1341 + 0.05363475 * fTemp1342) + fTemp1343 * (0.01573797 * fTemp1345 + 0.64427134 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.03381146 * fTemp1352 + 0.05363475 * fTemp1353) + fTemp1354 * (0.01573797 * fTemp1356 + 0.64427134 * fTemp1357))) + fRec942 * (fTemp1337 * (fTemp1339 * (0.01797695 * fTemp1341 + 0.0640251 * fTemp1342) + fTemp1343 * (0.54357606 * fTemp1345 + 0.4053105 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.01797695 * fTemp1352 + 0.0640251 * fTemp1353) + fTemp1354 * (0.54357606 * fTemp1356 + 0.4053105 * fTemp1357))) + fRec945 * (fTemp1337 * (fTemp1339 * (0.03067041 * fTemp1341 + 0.05785498 * fTemp1342) + fTemp1343 * (0.09954785 * fTemp1345 + 0.62411215 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.03067041 * fTemp1352 + 0.05785498 * fTemp1353) + fTemp1354 * (0.09954785 * fTemp1356 + 0.62411215 * fTemp1357))) + fRec948 * (fTemp1337 * (fTemp1339 * (0.03436227 * fTemp1341 + 0.04838698 * fTemp1342) + fTemp1343 * (0.0250452 * fTemp1345 + 0.00707754 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.03436227 * fTemp1352 + 0.04838698 * fTemp1353) + fTemp1354 * (0.0250452 * fTemp1356 + 0.00707754 * fTemp1357))) + fRec951 * (fTemp1337 * (fTemp1339 * (0.01922137 * fTemp1341 + 0.00787687 * fTemp1342) + fTemp1343 * (0.25042786 * fTemp1345 + 0.6674602 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.01922137 * fTemp1352 + 0.00787687 * fTemp1353) + fTemp1354 * (0.25042786 * fTemp1356 + 0.6674602 * fTemp1357))) + fRec954 * (fTemp1337 * (fTemp1339 * (0.05522969 * fTemp1341 + 0.06051622 * fTemp1342) + fTemp1343 * (0.02470587 * fTemp1345 + 0.01035828 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.05522969 * fTemp1352 + 0.06051622 * fTemp1353) + fTemp1354 * (0.02470587 * fTemp1356 + 0.01035828 * fTemp1357))) + fRec957 * (fTemp1337 * (fTemp1339 * (0.01668042 * fTemp1341 + 0.01592137 * fTemp1342) + fTemp1343 * (0.01093969 * fTemp1345 + 0.02061391 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.01668042 * fTemp1352 + 0.01592137 * fTemp1353) + fTemp1354 * (0.01093969 * fTemp1356 + 0.02061391 * fTemp1357))) + fRec960 * (fTemp1337 * (fTemp1339 * (0.00848029 * fTemp1341 + 0.01670722 * fTemp1342) + fTemp1343 * (0.05126037 * fTemp1345 + 0.03283333 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.00848029 * fTemp1352 + 0.01670722 * fTemp1353) + fTemp1354 * (0.05126037 * fTemp1356 + 0.03283333 * fTemp1357))) + fRec963 * (fTemp1337 * (fTemp1339 * (0.00496045 * fTemp1341 + 0.02143791 * fTemp1342) + fTemp1343 * (0.07354127 * fTemp1345 + 0.01222045 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.00496045 * fTemp1352 + 0.02143791 * fTemp1353) + fTemp1354 * (0.07354127 * fTemp1356 + 0.01222045 * fTemp1357))) + fRec966 * (fTemp1337 * (fTemp1339 * (0.00482074 * fTemp1341 + 0.01863539 * fTemp1342) + fTemp1343 * (0.06191843 * fTemp1345 + 0.03888326 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.00482074 * fTemp1352 + 0.01863539 * fTemp1353) + fTemp1354 * (0.06191843 * fTemp1356 + 0.03888326 * fTemp1357))) + fRec969 * (fTemp1337 * (fTemp1339 * (0.02735344 * fTemp1341 + 0.02193515 * fTemp1342) + fTemp1343 * (0.07170723 * fTemp1345 + 0.04759307 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.02735344 * fTemp1352 + 0.02193515 * fTemp1353) + fTemp1354 * (0.07170723 * fTemp1356 + 0.04759307 * fTemp1357))) + fRec972 * (fTemp1337 * (fTemp1339 * (0.02222397 * fTemp1341 + 0.00886369 * fTemp1342) + fTemp1343 * (0.02115358 * fTemp1345 + 0.02409027 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.02222397 * fTemp1352 + 0.00886369 * fTemp1353) + fTemp1354 * (0.02115358 * fTemp1356 + 0.02409027 * fTemp1357))) + fRec975 * (fTemp1337 * (fTemp1339 * (0.01985851 * fTemp1341 + 0.00274825 * fTemp1342) + fTemp1343 * (0.28175268 * fTemp1345 + 0.22375855 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.01985851 * fTemp1352 + 0.00274825 * fTemp1353) + fTemp1354 * (0.28175268 * fTemp1356 + 0.22375855 * fTemp1357))) + fRec978 * (fTemp1337 * (fTemp1339 * (0.03480883 * fTemp1341 + 0.02102163 * fTemp1342) + fTemp1343 * (0.01626654 * fTemp1345 + 0.03442368 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.03480883 * fTemp1352 + 0.02102163 * fTemp1353) + fTemp1354 * (0.01626654 * fTemp1356 + 0.03442368 * fTemp1357))) + fRec981 * (fTemp1337 * (fTemp1339 * (0.00722225 * fTemp1341 + 0.00320751 * fTemp1342) + fTemp1343 * (0.01055565 * fTemp1345 + 0.00841917 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.00722225 * fTemp1352 + 0.00320751 * fTemp1353) + fTemp1354 * (0.01055565 * fTemp1356 + 0.00841917 * fTemp1357))) + fRec984 * (fTemp1337 * (fTemp1339 * (0.01041008 * fTemp1341 + 0.00333966 * fTemp1342) + fTemp1343 * (0.01134687 * fTemp1345 + 0.01369543 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.01041008 * fTemp1352 + 0.00333966 * fTemp1353) + fTemp1354 * (0.01134687 * fTemp1356 + 0.01369543 * fTemp1357))) + fRec987 * (fTemp1337 * (fTemp1339 * (0.00722812 * fTemp1341 + 0.00161424 * fTemp1342) + fTemp1343 * (0.01233555 * fTemp1345 + 0.01528356 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.00722812 * fTemp1352 + 0.00161424 * fTemp1353) + fTemp1354 * (0.01233555 * fTemp1356 + 0.01528356 * fTemp1357))) + fRec990 * (fTemp1337 * (fTemp1339 * (0.00729633 * fTemp1341 + 0.00190274 * fTemp1342) + fTemp1343 * (0.00656447 * fTemp1345 + 0.00854136 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.00729633 * fTemp1352 + 0.00190274 * fTemp1353) + fTemp1354 * (0.00656447 * fTemp1356 + 0.00854136 * fTemp1357))) + fRec993 * (fTemp1337 * (fTemp1339 * (0.02313585 * fTemp1341 + 0.00348521 * fTemp1342) + fTemp1343 * (0.09585942 * fTemp1345 + 0.01776269 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.02313585 * fTemp1352 + 0.00348521 * fTemp1353) + fTemp1354 * (0.09585942 * fTemp1356 + 0.01776269 * fTemp1357))) + fRec996 * (fTemp1337 * (fTemp1339 * (0.04640077 * fTemp1341 + 0.01305707 * fTemp1342) + fTemp1343 * (0.06985491 * fTemp1345 + 0.01631748 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.04640077 * fTemp1352 + 0.01305707 * fTemp1353) + fTemp1354 * (0.06985491 * fTemp1356 + 0.01631748 * fTemp1357))) + fRec999 * (fTemp1337 * (fTemp1339 * (0.0121161 * fTemp1341 + 0.00709897 * fTemp1342) + fTemp1343 * (0.0343155 * fTemp1345 + 0.02601317 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.0121161 * fTemp1352 + 0.00709897 * fTemp1353) + fTemp1354 * (0.0343155 * fTemp1356 + 0.02601317 * fTemp1357))) + fRec1002 * (fTemp1337 * (fTemp1339 * (0.00592071 * fTemp1341 + 0.00126865 * fTemp1342) + fTemp1343 * (0.03127152 * fTemp1345 + 0.02237106 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.00592071 * fTemp1352 + 0.00126865 * fTemp1353) + fTemp1354 * (0.03127152 * fTemp1356 + 0.02237106 * fTemp1357))) + fRec1005 * (fTemp1337 * (fTemp1339 * (0.01158114 * fTemp1341 + 0.00132724 * fTemp1342) + fTemp1343 * (0.01587526 * fTemp1345 + 0.00969712 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.01158114 * fTemp1352 + 0.00132724 * fTemp1353) + fTemp1354 * (0.01587526 * fTemp1356 + 0.00969712 * fTemp1357))) + fRec1008 * (fTemp1337 * (fTemp1339 * (0.00443968 * fTemp1341 + 0.00152525 * fTemp1342) + fTemp1343 * (0.00962998 * fTemp1345 + 0.00986048 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.00443968 * fTemp1352 + 0.00152525 * fTemp1353) + fTemp1354 * (0.00962998 * fTemp1356 + 0.00986048 * fTemp1357))) + fRec1011 * (fTemp1337 * (fTemp1339 * (0.00282064 * fTemp1341 + 0.00097757 * fTemp1342) + fTemp1343 * (0.0068168 * fTemp1345 + 0.01255551 * fTemp1346)) + fTemp1347 * (fTemp1350 * (0.00282064 * fTemp1352 + 0.00097757 * fTemp1353) + fTemp1354 * (0.0068168 * fTemp1356 + 0.01255551 * fTemp1357)))));
			fRec9[0] = fRec871[0];
			fRec1018[0] = std::fmod(fRec1018[1], fConst0) + std::fabs(0.1 * fRec1017[1]) + 0.1;
			int iTemp1528 = (fConst1 * fRec1018[0]) < (fConst1 * fRec1018[1]);
			iVec58[0] = 383;
			iRec1019[0] = (383 - iVec58[1]) % -2147483648 + (12345 - 59 * iRec1019[1]);
			fRec1017[0] = fRec1017[1] * double(iVec0[1] - iTemp1528) + (0.0 - 4.656612873077393e-10 * double(iRec1019[0])) * double(iTemp1528 + iTemp1);
			int iTemp1529 = fRec1017[0] == fRec1017[1];
			fRec1016[0] = fRec1016[1] * double(iTemp1529) + 0.125 * fTemp3 * double(1 - iTemp1529);
			double fTemp1530 = ((fRec1016[0] != fRec1016[1]) ? fConst4 : fRec1014[1] + -1.0);
			fRec1014[0] = fTemp1530;
			fRec1015[0] = ((fTemp1530 > 0.0) ? fRec1015[1] + (fRec1016[0] - fRec1015[1]) / fTemp1530 : fRec1016[0]);
			double fTemp1531 = tanh(fRec13[0] + fSlow4 * std::sin(6.283185307179586 * fRec1015[0])) + 1.0;
			fVbargraph49 = FAUSTFLOAT(5e+02 * fTemp1531);
			double fTemp1532 = (fTemp6 * 0.5 * fTemp1531 + 1.0) * fRec1012[1];
			double fTemp1533 = mydsp_faustpower3_f(fRec1013[1]);
			fRec1025[0] = std::fmod(fRec1025[1], fConst0) + std::fabs(0.1 * fRec1024[1]) + 0.1;
			int iTemp1534 = (fConst1 * fRec1025[0]) < (fConst1 * fRec1025[1]);
			iVec59[0] = 353;
			iRec1026[0] = (353 - iVec59[1]) % -2147483648 + (12345 - 59 * iRec1026[1]);
			fRec1024[0] = fRec1024[1] * double(iVec0[1] - iTemp1534) + (0.0 - 4.656612873077393e-10 * double(iRec1026[0])) * double(iTemp1534 + iTemp1);
			int iTemp1535 = fRec1024[0] == fRec1024[1];
			fRec1023[0] = fRec1023[1] * double(iTemp1535) + 0.125 * fTemp3 * double(1 - iTemp1535);
			double fTemp1536 = ((fRec1023[0] != fRec1023[1]) ? fConst4 : fRec1021[1] + -1.0);
			fRec1021[0] = fTemp1536;
			fRec1022[0] = ((fTemp1536 > 0.0) ? fRec1022[1] + (fRec1023[0] - fRec1022[1]) / fTemp1536 : fRec1023[0]);
			double fTemp1537 = std::pow(5e+02, tanh(fRec21[0] + fSlow4 * std::sin(6.283185307179586 * fRec1022[0])));
			fVbargraph50 = FAUSTFLOAT(1e+03 * fTemp1537);
			fRec1020[0] = fRec1020[1] + fConst1 * fTemp1537;
			fRec1031[0] = std::fmod(fRec1031[1], fConst0) + std::fabs(0.1 * fRec1030[1]) + 0.1;
			int iTemp1538 = (fConst1 * fRec1031[0]) < (fConst1 * fRec1031[1]);
			iVec60[0] = 379;
			iRec1032[0] = (379 - iVec60[1]) % -2147483648 + (12345 - 59 * iRec1032[1]);
			fRec1030[0] = fRec1030[1] * double(iVec0[1] - iTemp1538) + (0.0 - 4.656612873077393e-10 * double(iRec1032[0])) * double(iTemp1538 + iTemp1);
			int iTemp1539 = fRec1030[0] == fRec1030[1];
			fRec1029[0] = fRec1029[1] * double(iTemp1539) + 0.125 * fTemp3 * double(1 - iTemp1539);
			double fTemp1540 = ((fRec1029[0] != fRec1029[1]) ? fConst4 : fRec1027[1] + -1.0);
			fRec1027[0] = fTemp1540;
			fRec1028[0] = ((fTemp1540 > 0.0) ? fRec1028[1] + (fRec1029[0] - fRec1028[1]) / fTemp1540 : fRec1029[0]);
			double fTemp1541 = tanh(fRec28[0] + fSlow4 * std::sin(6.283185307179586 * fRec1028[0])) + 1.0;
			fVbargraph51 = FAUSTFLOAT(5e+02 * fTemp1541);
			double fTemp1542 = std::cos(fRec1020[0]) * 0.5 * fTemp1541;
			double fTemp1543 = 0.0 - (fTemp1532 + fTemp1533 + fTemp1542);
			fVec61[0] = fTemp1543;
			fRec1012[0] = fTemp1543;
			fRec1040[0] = std::fmod(fRec1040[1], fConst0) + std::fabs(0.1 * fRec1039[1]) + 0.1;
			int iTemp1544 = (fConst1 * fRec1040[0]) < (fConst1 * fRec1040[1]);
			iVec62[0] = 359;
			iRec1041[0] = (359 - iVec62[1]) % -2147483648 + (12345 - 59 * iRec1041[1]);
			fRec1039[0] = fRec1039[1] * double(iVec0[1] - iTemp1544) + (0.0 - 4.656612873077393e-10 * double(iRec1041[0])) * double(iTemp1544 + iTemp1);
			int iTemp1545 = fRec1039[0] == fRec1039[1];
			fRec1038[0] = fRec1038[1] * double(iTemp1545) + 0.125 * fTemp3 * double(1 - iTemp1545);
			double fTemp1546 = ((fRec1038[0] != fRec1038[1]) ? fConst4 : fRec1036[1] + -1.0);
			fRec1036[0] = fTemp1546;
			fRec1037[0] = ((fTemp1546 > 0.0) ? fRec1037[1] + (fRec1038[0] - fRec1037[1]) / fTemp1546 : fRec1038[0]);
			double fTemp1547 = 0.45 * (tanh(fRec38[0] + fSlow4 * std::sin(6.283185307179586 * fRec1037[0])) + 1.0) + 0.1;
			fVbargraph52 = FAUSTFLOAT(1e+03 * fTemp1547);
			double fTemp1548 = fTemp1547;
			fRec1046[0] = std::fmod(fRec1046[1], fConst0) + std::fabs(0.1 * fRec1045[1]) + 0.1;
			int iTemp1549 = (fConst1 * fRec1046[0]) < (fConst1 * fRec1046[1]);
			iVec63[0] = 367;
			iRec1047[0] = (367 - iVec63[1]) % -2147483648 + (12345 - 59 * iRec1047[1]);
			fRec1045[0] = fRec1045[1] * double(iVec0[1] - iTemp1549) + (0.0 - 4.656612873077393e-10 * double(iRec1047[0])) * double(iTemp1549 + iTemp1);
			int iTemp1550 = fRec1045[0] == fRec1045[1];
			fRec1044[0] = fRec1044[1] * double(iTemp1550) + 0.125 * fTemp3 * double(1 - iTemp1550);
			double fTemp1551 = ((fRec1044[0] != fRec1044[1]) ? fConst4 : fRec1042[1] + -1.0);
			fRec1042[0] = fTemp1551;
			fRec1043[0] = ((fTemp1551 > 0.0) ? fRec1043[1] + (fRec1044[0] - fRec1043[1]) / fTemp1551 : fRec1044[0]);
			double fTemp1552 = tanh(fRec45[0] + fSlow4 * std::sin(6.283185307179586 * fRec1043[0])) + 1.0;
			fVbargraph53 = FAUSTFLOAT(5e+02 * fTemp1552);
			double fTemp1553 = 4.0 * 0.5 * fTemp1552;
			int iTemp1554 = int(fTemp1553);
			double fTemp1555 = double(iTemp1554);
			double fTemp1556 = fTemp1555 + (1.0 - fTemp1553);
			int iTemp1557 = iTemp1554 >= 2;
			double fTemp1558 = double(1 - iTemp1557);
			int iTemp1559 = iTemp1554 >= 1;
			double fTemp1560 = double(1 - iTemp1559);
			double fTemp1561 = double(iTemp1559);
			double fTemp1562 = double(iTemp1557);
			int iTemp1563 = iTemp1554 >= 3;
			double fTemp1564 = double(1 - iTemp1563);
			double fTemp1565 = double(iTemp1563);
			double fTemp1566 = fTemp1553 - fTemp1555;
			int iTemp1567 = iTemp1554 + 1;
			int iTemp1568 = iTemp1567 >= 2;
			double fTemp1569 = double(1 - iTemp1568);
			int iTemp1570 = iTemp1567 >= 1;
			double fTemp1571 = double(1 - iTemp1570);
			double fTemp1572 = double(iTemp1570);
			double fTemp1573 = double(iTemp1568);
			int iTemp1574 = iTemp1567 >= 3;
			double fTemp1575 = double(1 - iTemp1574);
			double fTemp1576 = double(iTemp1574);
			double fTemp1577 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1045.0 * fTemp1560 + 1468.0 * fTemp1561) + fTemp1562 * (1269.0 * fTemp1564 + 2418.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1045.0 * fTemp1571 + 1468.0 * fTemp1572) + fTemp1573 * (1269.0 * fTemp1575 + 2418.0 * fTemp1576)));
			double fTemp1578 = std::tan(fConst5 * fTemp1577);
			fRec1048[0] = 0.995 * fRec1048[1] - (fTemp1542 + fTemp1533 + fTemp1532 + fVec61[1]);
			fRec1053[0] = std::fmod(fRec1053[1], fConst0) + std::fabs(0.1 * fRec1052[1]) + 0.1;
			int iTemp1579 = (fConst1 * fRec1053[0]) < (fConst1 * fRec1053[1]);
			iVec64[0] = 389;
			iRec1054[0] = (389 - iVec64[1]) % -2147483648 + (12345 - 59 * iRec1054[1]);
			fRec1052[0] = fRec1052[1] * double(iVec0[1] - iTemp1579) + (0.0 - 4.656612873077393e-10 * double(iRec1054[0])) * double(iTemp1579 + iTemp1);
			int iTemp1580 = fRec1052[0] == fRec1052[1];
			fRec1051[0] = fRec1051[1] * double(iTemp1580) + 0.125 * fTemp3 * double(1 - iTemp1580);
			double fTemp1581 = ((fRec1051[0] != fRec1051[1]) ? fConst4 : fRec1049[1] + -1.0);
			fRec1049[0] = fTemp1581;
			fRec1050[0] = ((fTemp1581 > 0.0) ? fRec1050[1] + (fRec1051[0] - fRec1050[1]) / fTemp1581 : fRec1051[0]);
			double fTemp1582 = std::pow(1e+03, tanh(fRec53[0] + fSlow4 * std::sin(6.283185307179586 * fRec1050[0])));
			fVbargraph54 = FAUSTFLOAT(fTemp1582);
			double fTemp1583 = fRec1048[0] * fTemp1582;
			double fTemp1584 = fTemp1578 * (fTemp1583 - fRec1034[1]) + fRec1033[1];
			fRec1059[0] = std::fmod(fRec1059[1], fConst0) + std::fabs(0.1 * fRec1058[1]) + 0.1;
			int iTemp1585 = (fConst1 * fRec1059[0]) < (fConst1 * fRec1059[1]);
			iVec65[0] = 373;
			iRec1060[0] = (373 - iVec65[1]) % -2147483648 + (12345 - 59 * iRec1060[1]);
			fRec1058[0] = fRec1058[1] * double(iVec0[1] - iTemp1585) + (0.0 - 4.656612873077393e-10 * double(iRec1060[0])) * double(iTemp1585 + iTemp1);
			int iTemp1586 = fRec1058[0] == fRec1058[1];
			fRec1057[0] = fRec1057[1] * double(iTemp1586) + 0.125 * fTemp3 * double(1 - iTemp1586);
			double fTemp1587 = ((fRec1057[0] != fRec1057[1]) ? fConst4 : fRec1055[1] + -1.0);
			fRec1055[0] = fTemp1587;
			fRec1056[0] = ((fTemp1587 > 0.0) ? fRec1056[1] + (fRec1057[0] - fRec1056[1]) / fTemp1587 : fRec1057[0]);
			double fTemp1588 = std::pow(1e+02, tanh(fRec60[0] + fSlow4 * std::sin(6.283185307179586 * fRec1056[0])));
			fVbargraph55 = FAUSTFLOAT(fTemp1588);
			double fTemp1589 = std::max<double>(2.220446049250313e-16, fTemp1588);
			double fTemp1590 = fTemp1578 * (fTemp1578 + fTemp1589 / fTemp1577) + 1.0;
			double fTemp1591 = fTemp1584 / fTemp1590;
			fRec1033[0] = 2.0 * fTemp1591 - fRec1033[1];
			fRec1034[0] = fRec1034[1] + 2.0 * (fTemp1578 * fTemp1584 / fTemp1590);
			double fRec1035 = fTemp1591;
			double fTemp1592 = fTemp1548 * (fTemp1556 * (fTemp1558 * (979.0 * fTemp1560 + 1371.0 * fTemp1561) + fTemp1562 * (1175.0 * fTemp1564 + 2198.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (979.0 * fTemp1571 + 1371.0 * fTemp1572) + fTemp1573 * (1175.0 * fTemp1575 + 2198.0 * fTemp1576)));
			double fTemp1593 = std::tan(fConst5 * fTemp1592);
			double fTemp1594 = fTemp1593 * (fTemp1583 - fRec1062[1]) + fRec1061[1];
			double fTemp1595 = fTemp1593 * (fTemp1593 + fTemp1589 / fTemp1592) + 1.0;
			double fTemp1596 = fTemp1594 / fTemp1595;
			fRec1061[0] = 2.0 * fTemp1596 - fRec1061[1];
			fRec1062[0] = fRec1062[1] + 2.0 * (fTemp1593 * fTemp1594 / fTemp1595);
			double fRec1063 = fTemp1596;
			double fTemp1597 = fTemp1548 * (fTemp1556 * (fTemp1558 * (914.0 * fTemp1560 + 1272.0 * fTemp1561) + fTemp1562 * (1078.0 * fTemp1564 + 1978.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (914.0 * fTemp1571 + 1272.0 * fTemp1572) + fTemp1573 * (1078.0 * fTemp1575 + 1978.0 * fTemp1576)));
			double fTemp1598 = std::tan(fConst5 * fTemp1597);
			double fTemp1599 = fTemp1598 * (fTemp1583 - fRec1065[1]) + fRec1064[1];
			double fTemp1600 = fTemp1598 * (fTemp1598 + fTemp1589 / fTemp1597) + 1.0;
			double fTemp1601 = fTemp1599 / fTemp1600;
			fRec1064[0] = 2.0 * fTemp1601 - fRec1064[1];
			fRec1065[0] = fRec1065[1] + 2.0 * (fTemp1598 * fTemp1599 / fTemp1600);
			double fRec1066 = fTemp1601;
			double fTemp1602 = fTemp1548 * (fTemp1556 * (fTemp1558 * (849.0 * fTemp1560 + 1174.0 * fTemp1561) + fTemp1562 * (1028.0 * fTemp1564 + 1759.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (849.0 * fTemp1571 + 1174.0 * fTemp1572) + fTemp1573 * (1028.0 * fTemp1575 + 1759.0 * fTemp1576)));
			double fTemp1603 = std::tan(fConst5 * fTemp1602);
			double fTemp1604 = fTemp1603 * (fTemp1583 - fRec1068[1]) + fRec1067[1];
			double fTemp1605 = fTemp1603 * (fTemp1603 + fTemp1589 / fTemp1602) + 1.0;
			double fTemp1606 = fTemp1604 / fTemp1605;
			fRec1067[0] = 2.0 * fTemp1606 - fRec1067[1];
			fRec1068[0] = fRec1068[1] + 2.0 * (fTemp1603 * fTemp1604 / fTemp1605);
			double fRec1069 = fTemp1606;
			double fTemp1607 = fTemp1548 * (fTemp1556 * (fTemp1558 * (784.0 * fTemp1560 + 1076.0 * fTemp1561) + fTemp1562 * (961.0 * fTemp1564 + 1539.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (784.0 * fTemp1571 + 1076.0 * fTemp1572) + fTemp1573 * (961.0 * fTemp1575 + 1539.0 * fTemp1576)));
			double fTemp1608 = std::tan(fConst5 * fTemp1607);
			double fTemp1609 = fTemp1608 * (fTemp1583 - fRec1071[1]) + fRec1070[1];
			double fTemp1610 = fTemp1608 * (fTemp1608 + fTemp1589 / fTemp1607) + 1.0;
			double fTemp1611 = fTemp1609 / fTemp1610;
			fRec1070[0] = 2.0 * fTemp1611 - fRec1070[1];
			fRec1071[0] = fRec1071[1] + 2.0 * (fTemp1608 * fTemp1609 / fTemp1610);
			double fRec1072 = fTemp1611;
			double fTemp1612 = fTemp1548 * (fTemp1556 * (fTemp1558 * (718.0 * fTemp1560 + 979.0 * fTemp1561) + fTemp1562 * (882.0 * fTemp1564 + 1319.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (718.0 * fTemp1571 + 979.0 * fTemp1572) + fTemp1573 * (882.0 * fTemp1575 + 1319.0 * fTemp1576)));
			double fTemp1613 = std::tan(fConst5 * fTemp1612);
			double fTemp1614 = fTemp1613 * (fTemp1583 - fRec1074[1]) + fRec1073[1];
			double fTemp1615 = fTemp1613 * (fTemp1613 + fTemp1589 / fTemp1612) + 1.0;
			double fTemp1616 = fTemp1614 / fTemp1615;
			fRec1073[0] = 2.0 * fTemp1616 - fRec1073[1];
			fRec1074[0] = fRec1074[1] + 2.0 * (fTemp1613 * fTemp1614 / fTemp1615);
			double fRec1075 = fTemp1616;
			double fTemp1617 = fTemp1548 * (fTemp1556 * (fTemp1558 * (653.0 * fTemp1560 + 8.8e+02 * fTemp1561) + fTemp1562 * (785.0 * fTemp1564 + 1099.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (653.0 * fTemp1571 + 8.8e+02 * fTemp1572) + fTemp1573 * (785.0 * fTemp1575 + 1099.0 * fTemp1576)));
			double fTemp1618 = std::tan(fConst5 * fTemp1617);
			double fTemp1619 = fTemp1618 * (fTemp1583 - fRec1077[1]) + fRec1076[1];
			double fTemp1620 = fTemp1618 * (fTemp1618 + fTemp1589 / fTemp1617) + 1.0;
			double fTemp1621 = fTemp1619 / fTemp1620;
			fRec1076[0] = 2.0 * fTemp1621 - fRec1076[1];
			fRec1077[0] = fRec1077[1] + 2.0 * (fTemp1618 * fTemp1619 / fTemp1620);
			double fRec1078 = fTemp1621;
			double fTemp1622 = fTemp1548 * (fTemp1556 * (fTemp1558 * (588.0 * fTemp1560 + 783.0 * fTemp1561) + fTemp1562 * (735.0 * fTemp1564 + 879.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (588.0 * fTemp1571 + 783.0 * fTemp1572) + fTemp1573 * (735.0 * fTemp1575 + 879.0 * fTemp1576)));
			double fTemp1623 = std::tan(fConst5 * fTemp1622);
			double fTemp1624 = fTemp1623 * (fTemp1583 - fRec1080[1]) + fRec1079[1];
			double fTemp1625 = fTemp1623 * (fTemp1623 + fTemp1589 / fTemp1622) + 1.0;
			double fTemp1626 = fTemp1624 / fTemp1625;
			fRec1079[0] = 2.0 * fTemp1626 - fRec1079[1];
			fRec1080[0] = fRec1080[1] + 2.0 * (fTemp1623 * fTemp1624 / fTemp1625);
			double fRec1081 = fTemp1626;
			double fTemp1627 = fTemp1548 * (fTemp1556 * (fTemp1558 * (522.0 * fTemp1560 + 685.0 * fTemp1561) + fTemp1562 * (588.0 * fTemp1564 + 659.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (522.0 * fTemp1571 + 685.0 * fTemp1572) + fTemp1573 * (588.0 * fTemp1575 + 659.0 * fTemp1576)));
			double fTemp1628 = std::tan(fConst5 * fTemp1627);
			double fTemp1629 = fTemp1628 * (fTemp1583 - fRec1083[1]) + fRec1082[1];
			double fTemp1630 = fTemp1628 * (fTemp1628 + fTemp1589 / fTemp1627) + 1.0;
			double fTemp1631 = fTemp1629 / fTemp1630;
			fRec1082[0] = 2.0 * fTemp1631 - fRec1082[1];
			fRec1083[0] = fRec1083[1] + 2.0 * (fTemp1628 * fTemp1629 / fTemp1630);
			double fRec1084 = fTemp1631;
			double fTemp1632 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1632.0 * fTemp1560 + 2252.0 * fTemp1561) + fTemp1562 * (2204.0 * fTemp1564 + 4177.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1632.0 * fTemp1571 + 2252.0 * fTemp1572) + fTemp1573 * (2204.0 * fTemp1575 + 4177.0 * fTemp1576)));
			double fTemp1633 = std::tan(fConst5 * fTemp1632);
			double fTemp1634 = fTemp1633 * (fTemp1583 - fRec1086[1]) + fRec1085[1];
			double fTemp1635 = fTemp1633 * (fTemp1633 + fTemp1589 / fTemp1632) + 1.0;
			double fTemp1636 = fTemp1634 / fTemp1635;
			fRec1085[0] = 2.0 * fTemp1636 - fRec1085[1];
			fRec1086[0] = fRec1086[1] + 2.0 * (fTemp1633 * fTemp1634 / fTemp1635);
			double fRec1087 = fTemp1636;
			double fTemp1637 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1567.0 * fTemp1560 + 2153.0 * fTemp1561) + fTemp1562 * (2054.0 * fTemp1564 + 3957.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1567.0 * fTemp1571 + 2153.0 * fTemp1572) + fTemp1573 * (2054.0 * fTemp1575 + 3957.0 * fTemp1576)));
			double fTemp1638 = std::tan(fConst5 * fTemp1637);
			double fTemp1639 = fTemp1638 * (fTemp1583 - fRec1089[1]) + fRec1088[1];
			double fTemp1640 = fTemp1638 * (fTemp1638 + fTemp1589 / fTemp1637) + 1.0;
			double fTemp1641 = fTemp1639 / fTemp1640;
			fRec1088[0] = 2.0 * fTemp1641 - fRec1088[1];
			fRec1089[0] = fRec1089[1] + 2.0 * (fTemp1638 * fTemp1639 / fTemp1640);
			double fRec1090 = fTemp1641;
			double fTemp1642 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1502.0 * fTemp1560 + 2056.0 * fTemp1561) + fTemp1562 * (1.91e+03 * fTemp1564 + 3737.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1502.0 * fTemp1571 + 2056.0 * fTemp1572) + fTemp1573 * (1.91e+03 * fTemp1575 + 3737.0 * fTemp1576)));
			double fTemp1643 = std::tan(fConst5 * fTemp1642);
			double fTemp1644 = fTemp1643 * (fTemp1583 - fRec1092[1]) + fRec1091[1];
			double fTemp1645 = fTemp1643 * (fTemp1643 + fTemp1589 / fTemp1642) + 1.0;
			double fTemp1646 = fTemp1644 / fTemp1645;
			fRec1091[0] = 2.0 * fTemp1646 - fRec1091[1];
			fRec1092[0] = fRec1092[1] + 2.0 * (fTemp1643 * fTemp1644 / fTemp1645);
			double fRec1093 = fTemp1646;
			double fTemp1647 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1371.0 * fTemp1560 + 1958.0 * fTemp1561) + fTemp1562 * (1855.0 * fTemp1564 + 3517.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1371.0 * fTemp1571 + 1958.0 * fTemp1572) + fTemp1573 * (1855.0 * fTemp1575 + 3517.0 * fTemp1576)));
			double fTemp1648 = std::tan(fConst5 * fTemp1647);
			double fTemp1649 = fTemp1648 * (fTemp1583 - fRec1095[1]) + fRec1094[1];
			double fTemp1650 = fTemp1648 * (fTemp1648 + fTemp1589 / fTemp1647) + 1.0;
			double fTemp1651 = fTemp1649 / fTemp1650;
			fRec1094[0] = 2.0 * fTemp1651 - fRec1094[1];
			fRec1095[0] = fRec1095[1] + 2.0 * (fTemp1648 * fTemp1649 / fTemp1650);
			double fRec1096 = fTemp1651;
			double fTemp1652 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1306.0 * fTemp1560 + 1.86e+03 * fTemp1561) + fTemp1562 * (1764.0 * fTemp1564 + 3298.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1306.0 * fTemp1571 + 1.86e+03 * fTemp1572) + fTemp1573 * (1764.0 * fTemp1575 + 3298.0 * fTemp1576)));
			double fTemp1653 = std::tan(fConst5 * fTemp1652);
			double fTemp1654 = fTemp1653 * (fTemp1583 - fRec1098[1]) + fRec1097[1];
			double fTemp1655 = fTemp1653 * (fTemp1653 + fTemp1589 / fTemp1652) + 1.0;
			double fTemp1656 = fTemp1654 / fTemp1655;
			fRec1097[0] = 2.0 * fTemp1656 - fRec1097[1];
			fRec1098[0] = fRec1098[1] + 2.0 * (fTemp1653 * fTemp1654 / fTemp1655);
			double fRec1099 = fTemp1656;
			double fTemp1657 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1241.0 * fTemp1560 + 1762.0 * fTemp1561) + fTemp1562 * (1617.0 * fTemp1564 + 3078.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1241.0 * fTemp1571 + 1762.0 * fTemp1572) + fTemp1573 * (1617.0 * fTemp1575 + 3078.0 * fTemp1576)));
			double fTemp1658 = std::tan(fConst5 * fTemp1657);
			double fTemp1659 = fTemp1658 * (fTemp1583 - fRec1101[1]) + fRec1100[1];
			double fTemp1660 = fTemp1658 * (fTemp1658 + fTemp1589 / fTemp1657) + 1.0;
			double fTemp1661 = fTemp1659 / fTemp1660;
			fRec1100[0] = 2.0 * fTemp1661 - fRec1100[1];
			fRec1101[0] = fRec1101[1] + 2.0 * (fTemp1658 * fTemp1659 / fTemp1660);
			double fRec1102 = fTemp1661;
			double fTemp1662 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1175.0 * fTemp1560 + 1664.0 * fTemp1561) + fTemp1562 * (1.47e+03 * fTemp1564 + 2858.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1175.0 * fTemp1571 + 1664.0 * fTemp1572) + fTemp1573 * (1.47e+03 * fTemp1575 + 2858.0 * fTemp1576)));
			double fTemp1663 = std::tan(fConst5 * fTemp1662);
			double fTemp1664 = fTemp1663 * (fTemp1583 - fRec1104[1]) + fRec1103[1];
			double fTemp1665 = fTemp1663 * (fTemp1663 + fTemp1589 / fTemp1662) + 1.0;
			double fTemp1666 = fTemp1664 / fTemp1665;
			fRec1103[0] = 2.0 * fTemp1666 - fRec1103[1];
			fRec1104[0] = fRec1104[1] + 2.0 * (fTemp1663 * fTemp1664 / fTemp1665);
			double fRec1105 = fTemp1666;
			double fTemp1667 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1.11e+03 * fTemp1560 + 1566.0 * fTemp1561) + fTemp1562 * (1323.0 * fTemp1564 + 2638.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1.11e+03 * fTemp1571 + 1566.0 * fTemp1572) + fTemp1573 * (1323.0 * fTemp1575 + 2638.0 * fTemp1576)));
			double fTemp1668 = std::tan(fConst5 * fTemp1667);
			double fTemp1669 = fTemp1668 * (fTemp1583 - fRec1107[1]) + fRec1106[1];
			double fTemp1670 = fTemp1668 * (fTemp1668 + fTemp1589 / fTemp1667) + 1.0;
			double fTemp1671 = fTemp1669 / fTemp1670;
			fRec1106[0] = 2.0 * fTemp1671 - fRec1106[1];
			fRec1107[0] = fRec1107[1] + 2.0 * (fTemp1668 * fTemp1669 / fTemp1670);
			double fRec1108 = fTemp1671;
			double fTemp1672 = (fTemp1556 * ((65.0 * fTemp1560 + 98.0 * fTemp1561) * fTemp1558 + (53.0 * fTemp1564 + 5e+01 * fTemp1565) * fTemp1562) + fTemp1566 * ((65.0 * fTemp1571 + 98.0 * fTemp1572) * fTemp1569 + (53.0 * fTemp1575 + 5e+01 * fTemp1576) * fTemp1573)) * fTemp1548;
			double fTemp1673 = std::tan(fConst5 * fTemp1672);
			double fTemp1674 = fTemp1673 * (fTemp1583 - fRec1110[1]) + fRec1109[1];
			double fTemp1675 = fTemp1673 * (fTemp1673 + fTemp1589 / fTemp1672) + 1.0;
			double fTemp1676 = fTemp1674 / fTemp1675;
			fRec1109[0] = 2.0 * fTemp1676 - fRec1109[1];
			fRec1110[0] = fRec1110[1] + 2.0 * (fTemp1673 * fTemp1674 / fTemp1675);
			double fRec1111 = fTemp1676;
			double fTemp1677 = fTemp1548 * (fTemp1556 * (fTemp1558 * (131.0 * fTemp1560 + 195.0 * fTemp1561) + fTemp1562 * (147.0 * fTemp1564 + 1.3e+02 * fTemp1565)) + fTemp1566 * (fTemp1569 * (131.0 * fTemp1571 + 195.0 * fTemp1572) + fTemp1573 * (147.0 * fTemp1575 + 1.3e+02 * fTemp1576)));
			double fTemp1678 = std::tan(fConst5 * fTemp1677);
			double fTemp1679 = fTemp1678 * (fTemp1583 - fRec1113[1]) + fRec1112[1];
			double fTemp1680 = fTemp1678 * (fTemp1678 + fTemp1589 / fTemp1677) + 1.0;
			double fTemp1681 = fTemp1679 / fTemp1680;
			fRec1112[0] = 2.0 * fTemp1681 - fRec1112[1];
			fRec1113[0] = fRec1113[1] + 2.0 * (fTemp1678 * fTemp1679 / fTemp1680);
			double fRec1114 = fTemp1681;
			double fTemp1682 = fTemp1548 * (fTemp1556 * (fTemp1558 * (196.0 * fTemp1560 + 293.0 * fTemp1561) + fTemp1562 * (203.0 * fTemp1564 + 2.2e+02 * fTemp1565)) + fTemp1566 * (fTemp1569 * (196.0 * fTemp1571 + 293.0 * fTemp1572) + fTemp1573 * (203.0 * fTemp1575 + 2.2e+02 * fTemp1576)));
			double fTemp1683 = std::tan(fConst5 * fTemp1682);
			double fTemp1684 = fTemp1683 * (fTemp1583 - fRec1116[1]) + fRec1115[1];
			double fTemp1685 = fTemp1683 * (fTemp1683 + fTemp1589 / fTemp1682) + 1.0;
			double fTemp1686 = fTemp1684 / fTemp1685;
			fRec1115[0] = 2.0 * fTemp1686 - fRec1115[1];
			fRec1116[0] = fRec1116[1] + 2.0 * (fTemp1683 * fTemp1684 / fTemp1685);
			double fRec1117 = fTemp1686;
			double fTemp1687 = fTemp1548 * (fTemp1556 * (fTemp1558 * (261.0 * fTemp1560 + 391.0 * fTemp1561) + fTemp1562 * (294.0 * fTemp1564 + 309.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (261.0 * fTemp1571 + 391.0 * fTemp1572) + fTemp1573 * (294.0 * fTemp1575 + 309.0 * fTemp1576)));
			double fTemp1688 = std::tan(fConst5 * fTemp1687);
			double fTemp1689 = fTemp1688 * (fTemp1583 - fRec1119[1]) + fRec1118[1];
			double fTemp1690 = fTemp1688 * (fTemp1688 + fTemp1589 / fTemp1687) + 1.0;
			double fTemp1691 = fTemp1689 / fTemp1690;
			fRec1118[0] = 2.0 * fTemp1691 - fRec1118[1];
			fRec1119[0] = fRec1119[1] + 2.0 * (fTemp1688 * fTemp1689 / fTemp1690);
			double fRec1120 = fTemp1691;
			double fTemp1692 = fTemp1548 * (fTemp1556 * (fTemp1558 * (326.0 * fTemp1560 + 489.0 * fTemp1561) + fTemp1562 * (367.0 * fTemp1564 + 368.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (326.0 * fTemp1571 + 489.0 * fTemp1572) + fTemp1573 * (367.0 * fTemp1575 + 368.0 * fTemp1576)));
			double fTemp1693 = std::tan(fConst5 * fTemp1692);
			double fTemp1694 = fTemp1693 * (fTemp1583 - fRec1122[1]) + fRec1121[1];
			double fTemp1695 = fTemp1693 * (fTemp1693 + fTemp1589 / fTemp1692) + 1.0;
			double fTemp1696 = fTemp1694 / fTemp1695;
			fRec1121[0] = 2.0 * fTemp1696 - fRec1121[1];
			fRec1122[0] = fRec1122[1] + 2.0 * (fTemp1693 * fTemp1694 / fTemp1695);
			double fRec1123 = fTemp1696;
			double fTemp1697 = fTemp1548 * (fTemp1556 * (fTemp1558 * (392.0 * fTemp1560 + 537.0 * fTemp1561) + fTemp1562 * (441.0 * fTemp1564 + 439.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (392.0 * fTemp1571 + 537.0 * fTemp1572) + fTemp1573 * (441.0 * fTemp1575 + 439.0 * fTemp1576)));
			double fTemp1698 = std::tan(fConst5 * fTemp1697);
			double fTemp1699 = fTemp1698 * (fTemp1583 - fRec1125[1]) + fRec1124[1];
			double fTemp1700 = fTemp1698 * (fTemp1698 + fTemp1589 / fTemp1697) + 1.0;
			double fTemp1701 = fTemp1699 / fTemp1700;
			fRec1124[0] = 2.0 * fTemp1701 - fRec1124[1];
			fRec1125[0] = fRec1125[1] + 2.0 * (fTemp1698 * fTemp1699 / fTemp1700);
			double fRec1126 = fTemp1701;
			double fTemp1702 = fTemp1548 * (fTemp1556 * (fTemp1558 * (457.0 * fTemp1560 + 587.0 * fTemp1561) + fTemp1562 * (534.0 * fTemp1564 + 538.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (457.0 * fTemp1571 + 587.0 * fTemp1572) + fTemp1573 * (534.0 * fTemp1575 + 538.0 * fTemp1576)));
			double fTemp1703 = std::tan(fConst5 * fTemp1702);
			double fTemp1704 = fTemp1703 * (fTemp1583 - fRec1128[1]) + fRec1127[1];
			double fTemp1705 = fTemp1703 * (fTemp1703 + fTemp1589 / fTemp1702) + 1.0;
			double fTemp1706 = fTemp1704 / fTemp1705;
			fRec1127[0] = 2.0 * fTemp1706 - fRec1127[1];
			fRec1128[0] = fRec1128[1] + 2.0 * (fTemp1703 * fTemp1704 / fTemp1705);
			double fRec1129 = fTemp1706;
			double fTemp1707 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1698.0 * fTemp1560 + 2349.0 * fTemp1561) + fTemp1562 * (2273.0 * fTemp1564 + 4617.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1698.0 * fTemp1571 + 2349.0 * fTemp1572) + fTemp1573 * (2273.0 * fTemp1575 + 4617.0 * fTemp1576)));
			double fTemp1708 = std::tan(fConst5 * fTemp1707);
			double fTemp1709 = fTemp1708 * (fTemp1583 - fRec1131[1]) + fRec1130[1];
			double fTemp1710 = fTemp1708 * (fTemp1708 + fTemp1589 / fTemp1707) + 1.0;
			double fTemp1711 = fTemp1709 / fTemp1710;
			fRec1130[0] = 2.0 * fTemp1711 - fRec1130[1];
			fRec1131[0] = fRec1131[1] + 2.0 * (fTemp1708 * fTemp1709 / fTemp1710);
			double fRec1132 = fTemp1711;
			double fTemp1712 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1763.0 * fTemp1560 + 2643.0 * fTemp1561) + fTemp1562 * (2351.0 * fTemp1564 + 5056.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1763.0 * fTemp1571 + 2643.0 * fTemp1572) + fTemp1573 * (2351.0 * fTemp1575 + 5056.0 * fTemp1576)));
			double fTemp1713 = std::tan(fConst5 * fTemp1712);
			double fTemp1714 = fTemp1713 * (fTemp1583 - fRec1134[1]) + fRec1133[1];
			double fTemp1715 = fTemp1713 * (fTemp1713 + fTemp1589 / fTemp1712) + 1.0;
			double fTemp1716 = fTemp1714 / fTemp1715;
			fRec1133[0] = 2.0 * fTemp1716 - fRec1133[1];
			fRec1134[0] = fRec1134[1] + 2.0 * (fTemp1713 * fTemp1714 / fTemp1715);
			double fRec1135 = fTemp1716;
			double fTemp1717 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1828.0 * fTemp1560 + 2741.0 * fTemp1561) + fTemp1562 * (2498.0 * fTemp1564 + 5496.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1828.0 * fTemp1571 + 2741.0 * fTemp1572) + fTemp1573 * (2498.0 * fTemp1575 + 5496.0 * fTemp1576)));
			double fTemp1718 = std::tan(fConst5 * fTemp1717);
			double fTemp1719 = fTemp1718 * (fTemp1583 - fRec1137[1]) + fRec1136[1];
			double fTemp1720 = fTemp1718 * (fTemp1718 + fTemp1589 / fTemp1717) + 1.0;
			double fTemp1721 = fTemp1719 / fTemp1720;
			fRec1136[0] = 2.0 * fTemp1721 - fRec1136[1];
			fRec1137[0] = fRec1137[1] + 2.0 * (fTemp1718 * fTemp1719 / fTemp1720);
			double fRec1138 = fTemp1721;
			double fTemp1722 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1894.0 * fTemp1560 + 2839.0 * fTemp1561) + fTemp1562 * (2645.0 * fTemp1564 + 5717.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1894.0 * fTemp1571 + 2839.0 * fTemp1572) + fTemp1573 * (2645.0 * fTemp1575 + 5717.0 * fTemp1576)));
			double fTemp1723 = std::tan(fConst5 * fTemp1722);
			double fTemp1724 = fTemp1723 * (fTemp1583 - fRec1140[1]) + fRec1139[1];
			double fTemp1725 = fTemp1723 * (fTemp1723 + fTemp1589 / fTemp1722) + 1.0;
			double fTemp1726 = fTemp1724 / fTemp1725;
			fRec1139[0] = 2.0 * fTemp1726 - fRec1139[1];
			fRec1140[0] = fRec1140[1] + 2.0 * (fTemp1723 * fTemp1724 / fTemp1725);
			double fRec1141 = fTemp1726;
			double fTemp1727 = fTemp1548 * (fTemp1556 * (fTemp1558 * (1959.0 * fTemp1560 + 2937.0 * fTemp1561) + fTemp1562 * (2792.0 * fTemp1564 + 7035.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (1959.0 * fTemp1571 + 2937.0 * fTemp1572) + fTemp1573 * (2792.0 * fTemp1575 + 7035.0 * fTemp1576)));
			double fTemp1728 = std::tan(fConst5 * fTemp1727);
			double fTemp1729 = fTemp1728 * (fTemp1583 - fRec1143[1]) + fRec1142[1];
			double fTemp1730 = fTemp1728 * (fTemp1728 + fTemp1589 / fTemp1727) + 1.0;
			double fTemp1731 = fTemp1729 / fTemp1730;
			fRec1142[0] = 2.0 * fTemp1731 - fRec1142[1];
			fRec1143[0] = fRec1143[1] + 2.0 * (fTemp1728 * fTemp1729 / fTemp1730);
			double fRec1144 = fTemp1731;
			double fTemp1732 = fTemp1548 * (fTemp1556 * (fTemp1558 * (2024.0 * fTemp1560 + 3.23e+03 * fTemp1561) + fTemp1562 * (3233.0 * fTemp1564 + 7255.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (2024.0 * fTemp1571 + 3.23e+03 * fTemp1572) + fTemp1573 * (3233.0 * fTemp1575 + 7255.0 * fTemp1576)));
			double fTemp1733 = std::tan(fConst5 * fTemp1732);
			double fTemp1734 = fTemp1733 * (fTemp1583 - fRec1146[1]) + fRec1145[1];
			double fTemp1735 = fTemp1733 * (fTemp1733 + fTemp1589 / fTemp1732) + 1.0;
			double fTemp1736 = fTemp1734 / fTemp1735;
			fRec1145[0] = 2.0 * fTemp1736 - fRec1145[1];
			fRec1146[0] = fRec1146[1] + 2.0 * (fTemp1733 * fTemp1734 / fTemp1735);
			double fRec1147 = fTemp1736;
			double fTemp1737 = fTemp1548 * (fTemp1556 * (fTemp1558 * (2089.0 * fTemp1560 + 3328.0 * fTemp1561) + fTemp1562 * (3.38e+03 * fTemp1564 + 8574.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (2089.0 * fTemp1571 + 3328.0 * fTemp1572) + fTemp1573 * (3.38e+03 * fTemp1575 + 8574.0 * fTemp1576)));
			double fTemp1738 = std::tan(fConst5 * fTemp1737);
			double fTemp1739 = fTemp1738 * (fTemp1583 - fRec1149[1]) + fRec1148[1];
			double fTemp1740 = fTemp1738 * (fTemp1738 + fTemp1589 / fTemp1737) + 1.0;
			double fTemp1741 = fTemp1739 / fTemp1740;
			fRec1148[0] = 2.0 * fTemp1741 - fRec1148[1];
			fRec1149[0] = fRec1149[1] + 2.0 * (fTemp1738 * fTemp1739 / fTemp1740);
			double fRec1150 = fTemp1741;
			double fTemp1742 = fTemp1548 * (fTemp1556 * (fTemp1558 * (2351.0 * fTemp1560 + 4013.0 * fTemp1561) + fTemp1562 * (3527.0 * fTemp1564 + 9672.0 * fTemp1565)) + fTemp1566 * (fTemp1569 * (2351.0 * fTemp1571 + 4013.0 * fTemp1572) + fTemp1573 * (3527.0 * fTemp1575 + 9672.0 * fTemp1576)));
			double fTemp1743 = std::tan(fConst5 * fTemp1742);
			double fTemp1744 = fTemp1743 * (fTemp1583 - fRec1152[1]) + fRec1151[1];
			double fTemp1745 = fTemp1743 * (fTemp1743 + fTemp1589 / fTemp1742) + 1.0;
			double fTemp1746 = fTemp1744 / fTemp1745;
			fRec1151[0] = 2.0 * fTemp1746 - fRec1151[1];
			fRec1152[0] = fRec1152[1] + 2.0 * (fTemp1743 * fTemp1744 / fTemp1745);
			double fRec1153 = fTemp1746;
			fRec1013[0] = 0.6366197723675814 * std::atan(0.03125 * (fRec1035 * (fTemp1556 * (fTemp1558 * (0.02222397 * fTemp1560 + 0.00886369 * fTemp1561) + fTemp1562 * (0.02115358 * fTemp1564 + 0.02409027 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.02222397 * fTemp1571 + 0.00886369 * fTemp1572) + fTemp1573 * (0.02115358 * fTemp1575 + 0.02409027 * fTemp1576))) + fRec1063 * (fTemp1556 * (fTemp1558 * (0.01985851 * fTemp1560 + 0.00274825 * fTemp1561) + fTemp1562 * (0.28175268 * fTemp1564 + 0.22375855 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.01985851 * fTemp1571 + 0.00274825 * fTemp1572) + fTemp1573 * (0.28175268 * fTemp1575 + 0.22375855 * fTemp1576))) + fRec1066 * (fTemp1556 * (fTemp1558 * (0.03480883 * fTemp1560 + 0.02102163 * fTemp1561) + fTemp1562 * (0.01626654 * fTemp1564 + 0.03442368 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.03480883 * fTemp1571 + 0.02102163 * fTemp1572) + fTemp1573 * (0.01626654 * fTemp1575 + 0.03442368 * fTemp1576))) + fRec1069 * (fTemp1556 * (fTemp1558 * (0.05834666 * fTemp1560 + 0.01772408 * fTemp1561) + fTemp1562 * (0.14442907 * fTemp1564 + 0.07338235 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.05834666 * fTemp1571 + 0.01772408 * fTemp1572) + fTemp1573 * (0.14442907 * fTemp1575 + 0.07338235 * fTemp1576))) + fRec1072 * (fTemp1556 * (fTemp1558 * (0.02913938 * fTemp1560 + 0.03638926 * fTemp1561) + fTemp1562 * (0.01228042 * fTemp1564 + 0.08982961 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.02913938 * fTemp1571 + 0.03638926 * fTemp1572) + fTemp1573 * (0.01228042 * fTemp1575 + 0.08982961 * fTemp1576))) + fRec1075 * (fTemp1556 * (fTemp1558 * (0.0550058 * fTemp1560 + 0.02121633 * fTemp1561) + fTemp1562 * (0.2722688 * fTemp1564 + 0.27821024 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.0550058 * fTemp1571 + 0.02121633 * fTemp1572) + fTemp1573 * (0.2722688 * fTemp1575 + 0.27821024 * fTemp1576))) + fRec1078 * (fTemp1556 * (fTemp1558 * (0.03381146 * fTemp1560 + 0.05363475 * fTemp1561) + fTemp1562 * (0.01573797 * fTemp1564 + 0.64427134 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.03381146 * fTemp1571 + 0.05363475 * fTemp1572) + fTemp1573 * (0.01573797 * fTemp1575 + 0.64427134 * fTemp1576))) + fRec1081 * (fTemp1556 * (fTemp1558 * (0.01797695 * fTemp1560 + 0.0640251 * fTemp1561) + fTemp1562 * (0.54357606 * fTemp1564 + 0.4053105 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.01797695 * fTemp1571 + 0.0640251 * fTemp1572) + fTemp1573 * (0.54357606 * fTemp1575 + 0.4053105 * fTemp1576))) + fRec1084 * (fTemp1556 * (fTemp1558 * (0.03067041 * fTemp1560 + 0.05785498 * fTemp1561) + fTemp1562 * (0.09954785 * fTemp1564 + 0.62411215 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.03067041 * fTemp1571 + 0.05785498 * fTemp1572) + fTemp1573 * (0.09954785 * fTemp1575 + 0.62411215 * fTemp1576))) + fRec1087 * (fTemp1556 * (fTemp1558 * (0.02313585 * fTemp1560 + 0.00348521 * fTemp1561) + fTemp1562 * (0.09585942 * fTemp1564 + 0.01776269 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.02313585 * fTemp1571 + 0.00348521 * fTemp1572) + fTemp1573 * (0.09585942 * fTemp1575 + 0.01776269 * fTemp1576))) + fRec1090 * (fTemp1556 * (fTemp1558 * (0.04640077 * fTemp1560 + 0.01305707 * fTemp1561) + fTemp1562 * (0.06985491 * fTemp1564 + 0.01631748 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.04640077 * fTemp1571 + 0.01305707 * fTemp1572) + fTemp1573 * (0.06985491 * fTemp1575 + 0.01631748 * fTemp1576))) + fRec1093 * (fTemp1556 * (fTemp1558 * (0.0121161 * fTemp1560 + 0.00709897 * fTemp1561) + fTemp1562 * (0.0343155 * fTemp1564 + 0.02601317 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.0121161 * fTemp1571 + 0.00709897 * fTemp1572) + fTemp1573 * (0.0343155 * fTemp1575 + 0.02601317 * fTemp1576))) + fRec1096 * (fTemp1556 * (fTemp1558 * (0.01668042 * fTemp1560 + 0.01592137 * fTemp1561) + fTemp1562 * (0.01093969 * fTemp1564 + 0.02061391 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.01668042 * fTemp1571 + 0.01592137 * fTemp1572) + fTemp1573 * (0.01093969 * fTemp1575 + 0.02061391 * fTemp1576))) + fRec1099 * (fTemp1556 * (fTemp1558 * (0.00848029 * fTemp1560 + 0.01670722 * fTemp1561) + fTemp1562 * (0.05126037 * fTemp1564 + 0.03283333 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.00848029 * fTemp1571 + 0.01670722 * fTemp1572) + fTemp1573 * (0.05126037 * fTemp1575 + 0.03283333 * fTemp1576))) + fRec1102 * (fTemp1556 * (fTemp1558 * (0.00496045 * fTemp1560 + 0.02143791 * fTemp1561) + fTemp1562 * (0.07354127 * fTemp1564 + 0.01222045 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.00496045 * fTemp1571 + 0.02143791 * fTemp1572) + fTemp1573 * (0.07354127 * fTemp1575 + 0.01222045 * fTemp1576))) + fRec1105 * (fTemp1556 * (fTemp1558 * (0.00482074 * fTemp1560 + 0.01863539 * fTemp1561) + fTemp1562 * (0.06191843 * fTemp1564 + 0.03888326 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.00482074 * fTemp1571 + 0.01863539 * fTemp1572) + fTemp1573 * (0.06191843 * fTemp1575 + 0.03888326 * fTemp1576))) + fRec1108 * (fTemp1556 * (fTemp1558 * (0.02735344 * fTemp1560 + 0.02193515 * fTemp1561) + fTemp1562 * (0.07170723 * fTemp1564 + 0.04759307 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.02735344 * fTemp1571 + 0.02193515 * fTemp1572) + fTemp1573 * (0.07170723 * fTemp1575 + 0.04759307 * fTemp1576))) + fRec1111 * (fTemp1556 * (fTemp1558 * (0.04196492 * fTemp1560 + 0.75217775 * fTemp1561) + fTemp1562 * (0.07116083 * fTemp1564 + 0.01835863 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.04196492 * fTemp1571 + 0.75217775 * fTemp1572) + fTemp1573 * (0.07116083 * fTemp1575 + 0.01835863 * fTemp1576))) + fRec1114 * (fTemp1556 * (fTemp1558 * (fTemp1561 + 0.27707616 * fTemp1560) + fTemp1562 * (fTemp1564 + 0.01216278 * fTemp1565)) + fTemp1566 * (fTemp1569 * (fTemp1572 + 0.27707616 * fTemp1571) + fTemp1573 * (fTemp1575 + 0.01216278 * fTemp1576))) + fRec1117 * (fTemp1556 * (fTemp1558 * (fTemp1560 + 0.09843679 * fTemp1561) + fTemp1562 * (fTemp1565 + 0.0405712 * fTemp1564)) + fTemp1566 * (fTemp1569 * (fTemp1571 + 0.09843679 * fTemp1572) + fTemp1573 * (fTemp1576 + 0.0405712 * fTemp1575))) + fRec1120 * (fTemp1556 * (fTemp1558 * (0.08153769 * fTemp1560 + 0.02426847 * fTemp1561) + fTemp1562 * (0.49828005 * fTemp1564 + 0.00749257 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.08153769 * fTemp1571 + 0.02426847 * fTemp1572) + fTemp1573 * (0.49828005 * fTemp1575 + 0.00749257 * fTemp1576))) + fRec1123 * (fTemp1556 * (fTemp1558 * (0.05522969 * fTemp1560 + 0.06051622 * fTemp1561) + fTemp1562 * (0.02470587 * fTemp1564 + 0.01035828 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.05522969 * fTemp1571 + 0.06051622 * fTemp1572) + fTemp1573 * (0.02470587 * fTemp1575 + 0.01035828 * fTemp1576))) + fRec1126 * (fTemp1556 * (fTemp1558 * (0.01922137 * fTemp1560 + 0.00787687 * fTemp1561) + fTemp1562 * (0.25042786 * fTemp1564 + 0.6674602 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.01922137 * fTemp1571 + 0.00787687 * fTemp1572) + fTemp1573 * (0.25042786 * fTemp1575 + 0.6674602 * fTemp1576))) + fRec1129 * (fTemp1556 * (fTemp1558 * (0.03436227 * fTemp1560 + 0.04838698 * fTemp1561) + fTemp1562 * (0.0250452 * fTemp1564 + 0.00707754 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.03436227 * fTemp1571 + 0.04838698 * fTemp1572) + fTemp1573 * (0.0250452 * fTemp1575 + 0.00707754 * fTemp1576))) + fRec1132 * (fTemp1556 * (fTemp1558 * (0.00729633 * fTemp1560 + 0.00190274 * fTemp1561) + fTemp1562 * (0.00656447 * fTemp1564 + 0.00854136 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.00729633 * fTemp1571 + 0.00190274 * fTemp1572) + fTemp1573 * (0.00656447 * fTemp1575 + 0.00854136 * fTemp1576))) + fRec1135 * (fTemp1556 * (fTemp1558 * (0.00722812 * fTemp1560 + 0.00161424 * fTemp1561) + fTemp1562 * (0.01233555 * fTemp1564 + 0.01528356 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.00722812 * fTemp1571 + 0.00161424 * fTemp1572) + fTemp1573 * (0.01233555 * fTemp1575 + 0.01528356 * fTemp1576))) + fRec1138 * (fTemp1556 * (fTemp1558 * (0.01041008 * fTemp1560 + 0.00333966 * fTemp1561) + fTemp1562 * (0.01134687 * fTemp1564 + 0.01369543 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.01041008 * fTemp1571 + 0.00333966 * fTemp1572) + fTemp1573 * (0.01134687 * fTemp1575 + 0.01369543 * fTemp1576))) + fRec1141 * (fTemp1556 * (fTemp1558 * (0.00722225 * fTemp1560 + 0.00320751 * fTemp1561) + fTemp1562 * (0.01055565 * fTemp1564 + 0.00841917 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.00722225 * fTemp1571 + 0.00320751 * fTemp1572) + fTemp1573 * (0.01055565 * fTemp1575 + 0.00841917 * fTemp1576))) + fRec1144 * (fTemp1556 * (fTemp1558 * (0.00592071 * fTemp1560 + 0.00126865 * fTemp1561) + fTemp1562 * (0.03127152 * fTemp1564 + 0.02237106 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.00592071 * fTemp1571 + 0.00126865 * fTemp1572) + fTemp1573 * (0.03127152 * fTemp1575 + 0.02237106 * fTemp1576))) + fRec1147 * (fTemp1556 * (fTemp1558 * (0.01158114 * fTemp1560 + 0.00132724 * fTemp1561) + fTemp1562 * (0.01587526 * fTemp1564 + 0.00969712 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.01158114 * fTemp1571 + 0.00132724 * fTemp1572) + fTemp1573 * (0.01587526 * fTemp1575 + 0.00969712 * fTemp1576))) + fRec1150 * (fTemp1556 * (fTemp1558 * (0.00443968 * fTemp1560 + 0.00152525 * fTemp1561) + fTemp1562 * (0.00962998 * fTemp1564 + 0.00986048 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.00443968 * fTemp1571 + 0.00152525 * fTemp1572) + fTemp1573 * (0.00962998 * fTemp1575 + 0.00986048 * fTemp1576))) + fRec1153 * (fTemp1556 * (fTemp1558 * (0.00282064 * fTemp1560 + 0.00097757 * fTemp1561) + fTemp1562 * (0.0068168 * fTemp1564 + 0.01255551 * fTemp1565)) + fTemp1566 * (fTemp1569 * (0.00282064 * fTemp1571 + 0.00097757 * fTemp1572) + fTemp1573 * (0.0068168 * fTemp1575 + 0.01255551 * fTemp1576)))));
			fRec10[0] = fRec1013[0];
			fRec2[IOTA0 & 32767] = fRec3[0] + 0.995 * fRec2[(IOTA0 - 1) & 32767] - fRec3[1];
			double fTemp1747 = std::fabs(fRec2[IOTA0 & 32767]);
			int iTemp1748 = (fTemp1747 >= fRec1158[1]) | (double(iRec1157[1]) >= fConst11);
			iRec1157[0] = ((iTemp1748) ? 0 : iRec1157[1] + 1);
			fRec1158[0] = ((iTemp1748) ? fTemp1747 : fRec1158[1]);
			double fTemp1749 = fRec1158[0] - fRec1155[1];
			fRec1155[0] = fRec1155[1] + fConst10 * fTemp1749;
			double fTemp1750 = fRec1155[1] + fConst9 * fTemp1749;
			double fRec1156 = fTemp1750;
			fRec1154[0] = std::max<double>(std::fabs(fRec1156), fConst12 * fRec1154[1]);
			double fTemp1751 = fRec2[(IOTA0 - iConst7) & 32767] / std::max<double>(1.0, fRec1154[0]);
			fRec1159[IOTA0 & 32767] = fRec5[0] + 0.995 * fRec1159[(IOTA0 - 1) & 32767] - fRec5[1];
			double fTemp1752 = std::fabs(fRec1159[IOTA0 & 32767]);
			int iTemp1753 = (fTemp1752 >= fRec1164[1]) | (double(iRec1163[1]) >= fConst11);
			iRec1163[0] = ((iTemp1753) ? 0 : iRec1163[1] + 1);
			fRec1164[0] = ((iTemp1753) ? fTemp1752 : fRec1164[1]);
			double fTemp1754 = fRec1164[0] - fRec1161[1];
			fRec1161[0] = fRec1161[1] + fConst10 * fTemp1754;
			double fTemp1755 = fRec1161[1] + fConst9 * fTemp1754;
			double fRec1162 = fTemp1755;
			fRec1160[0] = std::max<double>(std::fabs(fRec1162), fConst12 * fRec1160[1]);
			double fTemp1756 = fRec1159[(IOTA0 - iConst7) & 32767] / std::max<double>(1.0, fRec1160[0]);
			fRec1165[IOTA0 & 32767] = fRec7[0] + 0.995 * fRec1165[(IOTA0 - 1) & 32767] - fRec7[1];
			double fTemp1757 = std::fabs(fRec1165[IOTA0 & 32767]);
			int iTemp1758 = (fTemp1757 >= fRec1170[1]) | (double(iRec1169[1]) >= fConst11);
			iRec1169[0] = ((iTemp1758) ? 0 : iRec1169[1] + 1);
			fRec1170[0] = ((iTemp1758) ? fTemp1757 : fRec1170[1]);
			double fTemp1759 = fRec1170[0] - fRec1167[1];
			fRec1167[0] = fRec1167[1] + fConst10 * fTemp1759;
			double fTemp1760 = fRec1167[1] + fConst9 * fTemp1759;
			double fRec1168 = fTemp1760;
			fRec1166[0] = std::max<double>(std::fabs(fRec1168), fConst12 * fRec1166[1]);
			double fTemp1761 = fRec1165[(IOTA0 - iConst7) & 32767] / std::max<double>(1.0, fRec1166[0]);
			fRec1171[IOTA0 & 32767] = fRec9[0] + 0.995 * fRec1171[(IOTA0 - 1) & 32767] - fRec9[1];
			double fTemp1762 = std::fabs(fRec1171[IOTA0 & 32767]);
			int iTemp1763 = (fTemp1762 >= fRec1176[1]) | (double(iRec1175[1]) >= fConst11);
			iRec1175[0] = ((iTemp1763) ? 0 : iRec1175[1] + 1);
			fRec1176[0] = ((iTemp1763) ? fTemp1762 : fRec1176[1]);
			double fTemp1764 = fRec1176[0] - fRec1173[1];
			fRec1173[0] = fRec1173[1] + fConst10 * fTemp1764;
			double fTemp1765 = fRec1173[1] + fConst9 * fTemp1764;
			double fRec1174 = fTemp1765;
			fRec1172[0] = std::max<double>(std::fabs(fRec1174), fConst12 * fRec1172[1]);
			double fTemp1766 = fRec1171[(IOTA0 - iConst7) & 32767] / std::max<double>(1.0, fRec1172[0]);
			double fTemp1767 = fSlow2 * (fTemp1751 + fTemp1756 + fTemp1761 + fTemp1766);
			double fTemp1768 = fTemp1767 + fSlow11 * (fTemp1751 + fTemp1761);
			double fTemp1769 = fRec1[0] * (fTemp1768 + fSlow12 * fTemp1751);
			fRec0[0] = std::max<double>(fRec0[1] - fConst1, std::fabs(fTemp1769));
			fVbargraph56 = FAUSTFLOAT(2e+01 * std::log10(std::max<double>(2.2250738585072014e-308, std::max<double>(0.00031622776601683794, fRec0[0]))));
			output0[i0] = FAUSTFLOAT(fTemp1769);
			fRec1178[IOTA0 & 32767] = fRec4[0] + 0.995 * fRec1178[(IOTA0 - 1) & 32767] - fRec4[1];
			double fTemp1770 = std::fabs(fRec1178[IOTA0 & 32767]);
			int iTemp1771 = (fTemp1770 >= fRec1183[1]) | (double(iRec1182[1]) >= fConst11);
			iRec1182[0] = ((iTemp1771) ? 0 : iRec1182[1] + 1);
			fRec1183[0] = ((iTemp1771) ? fTemp1770 : fRec1183[1]);
			double fTemp1772 = fRec1183[0] - fRec1180[1];
			fRec1180[0] = fRec1180[1] + fConst10 * fTemp1772;
			double fTemp1773 = fRec1180[1] + fConst9 * fTemp1772;
			double fRec1181 = fTemp1773;
			fRec1179[0] = std::max<double>(std::fabs(fRec1181), fConst12 * fRec1179[1]);
			double fTemp1774 = fRec1178[(IOTA0 - iConst7) & 32767] / std::max<double>(1.0, fRec1179[0]);
			fRec1184[IOTA0 & 32767] = fRec6[0] + 0.995 * fRec1184[(IOTA0 - 1) & 32767] - fRec6[1];
			double fTemp1775 = std::fabs(fRec1184[IOTA0 & 32767]);
			int iTemp1776 = (fTemp1775 >= fRec1189[1]) | (double(iRec1188[1]) >= fConst11);
			iRec1188[0] = ((iTemp1776) ? 0 : iRec1188[1] + 1);
			fRec1189[0] = ((iTemp1776) ? fTemp1775 : fRec1189[1]);
			double fTemp1777 = fRec1189[0] - fRec1186[1];
			fRec1186[0] = fRec1186[1] + fConst10 * fTemp1777;
			double fTemp1778 = fRec1186[1] + fConst9 * fTemp1777;
			double fRec1187 = fTemp1778;
			fRec1185[0] = std::max<double>(std::fabs(fRec1187), fConst12 * fRec1185[1]);
			double fTemp1779 = fRec1184[(IOTA0 - iConst7) & 32767] / std::max<double>(1.0, fRec1185[0]);
			fRec1190[IOTA0 & 32767] = fRec8[0] + 0.995 * fRec1190[(IOTA0 - 1) & 32767] - fRec8[1];
			double fTemp1780 = std::fabs(fRec1190[IOTA0 & 32767]);
			int iTemp1781 = (fTemp1780 >= fRec1195[1]) | (double(iRec1194[1]) >= fConst11);
			iRec1194[0] = ((iTemp1781) ? 0 : iRec1194[1] + 1);
			fRec1195[0] = ((iTemp1781) ? fTemp1780 : fRec1195[1]);
			double fTemp1782 = fRec1195[0] - fRec1192[1];
			fRec1192[0] = fRec1192[1] + fConst10 * fTemp1782;
			double fTemp1783 = fRec1192[1] + fConst9 * fTemp1782;
			double fRec1193 = fTemp1783;
			fRec1191[0] = std::max<double>(std::fabs(fRec1193), fConst12 * fRec1191[1]);
			double fTemp1784 = fRec1190[(IOTA0 - iConst7) & 32767] / std::max<double>(1.0, fRec1191[0]);
			fRec1196[IOTA0 & 32767] = fRec10[0] + 0.995 * fRec1196[(IOTA0 - 1) & 32767] - fRec10[1];
			double fTemp1785 = std::fabs(fRec1196[IOTA0 & 32767]);
			int iTemp1786 = (fTemp1785 >= fRec1201[1]) | (double(iRec1200[1]) >= fConst11);
			iRec1200[0] = ((iTemp1786) ? 0 : iRec1200[1] + 1);
			fRec1201[0] = ((iTemp1786) ? fTemp1785 : fRec1201[1]);
			double fTemp1787 = fRec1201[0] - fRec1198[1];
			fRec1198[0] = fRec1198[1] + fConst10 * fTemp1787;
			double fTemp1788 = fRec1198[1] + fConst9 * fTemp1787;
			double fRec1199 = fTemp1788;
			fRec1197[0] = std::max<double>(std::fabs(fRec1199), fConst12 * fRec1197[1]);
			double fTemp1789 = fRec1196[(IOTA0 - iConst7) & 32767] / std::max<double>(1.0, fRec1197[0]);
			double fTemp1790 = fSlow2 * (fTemp1774 + fTemp1779 + fTemp1784 + fTemp1789);
			double fTemp1791 = fTemp1790 + fSlow11 * (fTemp1774 + fTemp1784);
			double fTemp1792 = fRec1[0] * (fTemp1791 + fSlow12 * fTemp1774);
			fRec1177[0] = std::max<double>(fRec1177[1] - fConst1, std::fabs(fTemp1792));
			fVbargraph57 = FAUSTFLOAT(2e+01 * std::log10(std::max<double>(2.2250738585072014e-308, std::max<double>(0.00031622776601683794, fRec1177[0]))));
			output1[i0] = FAUSTFLOAT(fTemp1792);
			double fTemp1793 = fTemp1767 + fSlow11 * (fTemp1756 + fTemp1766);
			double fTemp1794 = fRec1[0] * (fTemp1793 + fSlow12 * fTemp1756);
			fRec1202[0] = std::max<double>(fRec1202[1] - fConst1, std::fabs(fTemp1794));
			fVbargraph58 = FAUSTFLOAT(2e+01 * std::log10(std::max<double>(2.2250738585072014e-308, std::max<double>(0.00031622776601683794, fRec1202[0]))));
			output2[i0] = FAUSTFLOAT(fTemp1794);
			double fTemp1795 = fTemp1790 + fSlow11 * (fTemp1779 + fTemp1789);
			double fTemp1796 = fRec1[0] * (fTemp1795 + fSlow12 * fTemp1779);
			fRec1203[0] = std::max<double>(fRec1203[1] - fConst1, std::fabs(fTemp1796));
			fVbargraph59 = FAUSTFLOAT(2e+01 * std::log10(std::max<double>(2.2250738585072014e-308, std::max<double>(0.00031622776601683794, fRec1203[0]))));
			output3[i0] = FAUSTFLOAT(fTemp1796);
			double fTemp1797 = fRec1[0] * (fTemp1768 + fSlow12 * fTemp1761);
			fRec1204[0] = std::max<double>(fRec1204[1] - fConst1, std::fabs(fTemp1797));
			fVbargraph60 = FAUSTFLOAT(2e+01 * std::log10(std::max<double>(2.2250738585072014e-308, std::max<double>(0.00031622776601683794, fRec1204[0]))));
			output4[i0] = FAUSTFLOAT(fTemp1797);
			double fTemp1798 = fRec1[0] * (fTemp1791 + fSlow12 * fTemp1784);
			fRec1205[0] = std::max<double>(fRec1205[1] - fConst1, std::fabs(fTemp1798));
			fVbargraph61 = FAUSTFLOAT(2e+01 * std::log10(std::max<double>(2.2250738585072014e-308, std::max<double>(0.00031622776601683794, fRec1205[0]))));
			output5[i0] = FAUSTFLOAT(fTemp1798);
			double fTemp1799 = fRec1[0] * (fTemp1793 + fSlow12 * fTemp1766);
			fRec1206[0] = std::max<double>(fRec1206[1] - fConst1, std::fabs(fTemp1799));
			fVbargraph62 = FAUSTFLOAT(2e+01 * std::log10(std::max<double>(2.2250738585072014e-308, std::max<double>(0.00031622776601683794, fRec1206[0]))));
			output6[i0] = FAUSTFLOAT(fTemp1799);
			double fTemp1800 = fRec1[0] * (fTemp1795 + fSlow12 * fTemp1789);
			fRec1207[0] = std::max<double>(fRec1207[1] - fConst1, std::fabs(fTemp1800));
			fVbargraph63 = FAUSTFLOAT(2e+01 * std::log10(std::max<double>(2.2250738585072014e-308, std::max<double>(0.00031622776601683794, fRec1207[0]))));
			output7[i0] = FAUSTFLOAT(fTemp1800);
			iVec0[1] = iVec0[0];
			fRec1[1] = fRec1[0];
			fRec13[1] = fRec13[0];
			fRec18[1] = fRec18[0];
			iVec1[1] = iVec1[0];
			iVec2[1] = iVec2[0];
			iRec19[1] = iRec19[0];
			fRec17[1] = fRec17[0];
			IOTA0 = IOTA0 + 1;
			fRec16[1] = fRec16[0];
			fRec14[1] = fRec14[0];
			fRec15[1] = fRec15[0];
			fRec21[1] = fRec21[0];
			fRec26[1] = fRec26[0];
			iVec4[1] = iVec4[0];
			iRec27[1] = iRec27[0];
			fRec25[1] = fRec25[0];
			fRec24[1] = fRec24[0];
			fRec22[1] = fRec22[0];
			fRec23[1] = fRec23[0];
			fRec20[1] = fRec20[0];
			fRec28[1] = fRec28[0];
			fRec33[1] = fRec33[0];
			iVec5[1] = iVec5[0];
			iRec34[1] = iRec34[0];
			fRec32[1] = fRec32[0];
			fRec31[1] = fRec31[0];
			fRec29[1] = fRec29[0];
			fRec30[1] = fRec30[0];
			fVec6[1] = fVec6[0];
			fRec11[1] = fRec11[0];
			fRec38[1] = fRec38[0];
			fRec43[1] = fRec43[0];
			iVec7[1] = iVec7[0];
			iRec44[1] = iRec44[0];
			fRec42[1] = fRec42[0];
			fRec41[1] = fRec41[0];
			fRec39[1] = fRec39[0];
			fRec40[1] = fRec40[0];
			fRec45[1] = fRec45[0];
			fRec50[1] = fRec50[0];
			iVec8[1] = iVec8[0];
			iRec51[1] = iRec51[0];
			fRec49[1] = fRec49[0];
			fRec48[1] = fRec48[0];
			fRec46[1] = fRec46[0];
			fRec47[1] = fRec47[0];
			fRec52[1] = fRec52[0];
			fRec53[1] = fRec53[0];
			fRec58[1] = fRec58[0];
			iVec9[1] = iVec9[0];
			iRec59[1] = iRec59[0];
			fRec57[1] = fRec57[0];
			fRec56[1] = fRec56[0];
			fRec54[1] = fRec54[0];
			fRec55[1] = fRec55[0];
			fRec60[1] = fRec60[0];
			fRec65[1] = fRec65[0];
			iVec10[1] = iVec10[0];
			iRec66[1] = iRec66[0];
			fRec64[1] = fRec64[0];
			fRec63[1] = fRec63[0];
			fRec61[1] = fRec61[0];
			fRec62[1] = fRec62[0];
			fRec35[1] = fRec35[0];
			fRec36[1] = fRec36[0];
			fRec67[1] = fRec67[0];
			fRec68[1] = fRec68[0];
			fRec70[1] = fRec70[0];
			fRec71[1] = fRec71[0];
			fRec73[1] = fRec73[0];
			fRec74[1] = fRec74[0];
			fRec76[1] = fRec76[0];
			fRec77[1] = fRec77[0];
			fRec79[1] = fRec79[0];
			fRec80[1] = fRec80[0];
			fRec82[1] = fRec82[0];
			fRec83[1] = fRec83[0];
			fRec85[1] = fRec85[0];
			fRec86[1] = fRec86[0];
			fRec88[1] = fRec88[0];
			fRec89[1] = fRec89[0];
			fRec91[1] = fRec91[0];
			fRec92[1] = fRec92[0];
			fRec94[1] = fRec94[0];
			fRec95[1] = fRec95[0];
			fRec97[1] = fRec97[0];
			fRec98[1] = fRec98[0];
			fRec100[1] = fRec100[0];
			fRec101[1] = fRec101[0];
			fRec103[1] = fRec103[0];
			fRec104[1] = fRec104[0];
			fRec106[1] = fRec106[0];
			fRec107[1] = fRec107[0];
			fRec109[1] = fRec109[0];
			fRec110[1] = fRec110[0];
			fRec112[1] = fRec112[0];
			fRec113[1] = fRec113[0];
			fRec115[1] = fRec115[0];
			fRec116[1] = fRec116[0];
			fRec118[1] = fRec118[0];
			fRec119[1] = fRec119[0];
			fRec121[1] = fRec121[0];
			fRec122[1] = fRec122[0];
			fRec124[1] = fRec124[0];
			fRec125[1] = fRec125[0];
			fRec127[1] = fRec127[0];
			fRec128[1] = fRec128[0];
			fRec130[1] = fRec130[0];
			fRec131[1] = fRec131[0];
			fRec133[1] = fRec133[0];
			fRec134[1] = fRec134[0];
			fRec136[1] = fRec136[0];
			fRec137[1] = fRec137[0];
			fRec139[1] = fRec139[0];
			fRec140[1] = fRec140[0];
			fRec142[1] = fRec142[0];
			fRec143[1] = fRec143[0];
			fRec145[1] = fRec145[0];
			fRec146[1] = fRec146[0];
			fRec148[1] = fRec148[0];
			fRec149[1] = fRec149[0];
			fRec151[1] = fRec151[0];
			fRec152[1] = fRec152[0];
			fRec154[1] = fRec154[0];
			fRec155[1] = fRec155[0];
			fRec157[1] = fRec157[0];
			fRec158[1] = fRec158[0];
			fRec12[1] = fRec12[0];
			fRec3[1] = fRec3[0];
			fRec166[1] = fRec166[0];
			iVec11[1] = iVec11[0];
			iRec167[1] = iRec167[0];
			fRec165[1] = fRec165[0];
			fRec164[1] = fRec164[0];
			fRec162[1] = fRec162[0];
			fRec163[1] = fRec163[0];
			fRec173[1] = fRec173[0];
			iVec12[1] = iVec12[0];
			iRec174[1] = iRec174[0];
			fRec172[1] = fRec172[0];
			fRec171[1] = fRec171[0];
			fRec169[1] = fRec169[0];
			fRec170[1] = fRec170[0];
			fRec168[1] = fRec168[0];
			fRec179[1] = fRec179[0];
			iVec13[1] = iVec13[0];
			iRec180[1] = iRec180[0];
			fRec178[1] = fRec178[0];
			fRec177[1] = fRec177[0];
			fRec175[1] = fRec175[0];
			fRec176[1] = fRec176[0];
			fVec14[1] = fVec14[0];
			fRec160[1] = fRec160[0];
			fRec188[1] = fRec188[0];
			iVec15[1] = iVec15[0];
			iRec189[1] = iRec189[0];
			fRec187[1] = fRec187[0];
			fRec186[1] = fRec186[0];
			fRec184[1] = fRec184[0];
			fRec185[1] = fRec185[0];
			fRec194[1] = fRec194[0];
			iVec16[1] = iVec16[0];
			iRec195[1] = iRec195[0];
			fRec193[1] = fRec193[0];
			fRec192[1] = fRec192[0];
			fRec190[1] = fRec190[0];
			fRec191[1] = fRec191[0];
			fRec196[1] = fRec196[0];
			fRec201[1] = fRec201[0];
			iRec202[1] = iRec202[0];
			fRec200[1] = fRec200[0];
			fRec199[1] = fRec199[0];
			fRec197[1] = fRec197[0];
			fRec198[1] = fRec198[0];
			fRec207[1] = fRec207[0];
			iVec17[1] = iVec17[0];
			iRec208[1] = iRec208[0];
			fRec206[1] = fRec206[0];
			fRec205[1] = fRec205[0];
			fRec203[1] = fRec203[0];
			fRec204[1] = fRec204[0];
			fRec181[1] = fRec181[0];
			fRec182[1] = fRec182[0];
			fRec209[1] = fRec209[0];
			fRec210[1] = fRec210[0];
			fRec212[1] = fRec212[0];
			fRec213[1] = fRec213[0];
			fRec215[1] = fRec215[0];
			fRec216[1] = fRec216[0];
			fRec218[1] = fRec218[0];
			fRec219[1] = fRec219[0];
			fRec221[1] = fRec221[0];
			fRec222[1] = fRec222[0];
			fRec224[1] = fRec224[0];
			fRec225[1] = fRec225[0];
			fRec227[1] = fRec227[0];
			fRec228[1] = fRec228[0];
			fRec230[1] = fRec230[0];
			fRec231[1] = fRec231[0];
			fRec233[1] = fRec233[0];
			fRec234[1] = fRec234[0];
			fRec236[1] = fRec236[0];
			fRec237[1] = fRec237[0];
			fRec239[1] = fRec239[0];
			fRec240[1] = fRec240[0];
			fRec242[1] = fRec242[0];
			fRec243[1] = fRec243[0];
			fRec245[1] = fRec245[0];
			fRec246[1] = fRec246[0];
			fRec248[1] = fRec248[0];
			fRec249[1] = fRec249[0];
			fRec251[1] = fRec251[0];
			fRec252[1] = fRec252[0];
			fRec254[1] = fRec254[0];
			fRec255[1] = fRec255[0];
			fRec257[1] = fRec257[0];
			fRec258[1] = fRec258[0];
			fRec260[1] = fRec260[0];
			fRec261[1] = fRec261[0];
			fRec263[1] = fRec263[0];
			fRec264[1] = fRec264[0];
			fRec266[1] = fRec266[0];
			fRec267[1] = fRec267[0];
			fRec269[1] = fRec269[0];
			fRec270[1] = fRec270[0];
			fRec272[1] = fRec272[0];
			fRec273[1] = fRec273[0];
			fRec275[1] = fRec275[0];
			fRec276[1] = fRec276[0];
			fRec278[1] = fRec278[0];
			fRec279[1] = fRec279[0];
			fRec281[1] = fRec281[0];
			fRec282[1] = fRec282[0];
			fRec284[1] = fRec284[0];
			fRec285[1] = fRec285[0];
			fRec287[1] = fRec287[0];
			fRec288[1] = fRec288[0];
			fRec290[1] = fRec290[0];
			fRec291[1] = fRec291[0];
			fRec293[1] = fRec293[0];
			fRec294[1] = fRec294[0];
			fRec296[1] = fRec296[0];
			fRec297[1] = fRec297[0];
			fRec299[1] = fRec299[0];
			fRec300[1] = fRec300[0];
			fRec161[1] = fRec161[0];
			fRec4[1] = fRec4[0];
			fRec308[1] = fRec308[0];
			iVec18[1] = iVec18[0];
			iRec309[1] = iRec309[0];
			fRec307[1] = fRec307[0];
			fRec306[1] = fRec306[0];
			fRec304[1] = fRec304[0];
			fRec305[1] = fRec305[0];
			fRec315[1] = fRec315[0];
			iVec19[1] = iVec19[0];
			iRec316[1] = iRec316[0];
			fRec314[1] = fRec314[0];
			fRec313[1] = fRec313[0];
			fRec311[1] = fRec311[0];
			fRec312[1] = fRec312[0];
			fRec310[1] = fRec310[0];
			fRec321[1] = fRec321[0];
			iVec20[1] = iVec20[0];
			iRec322[1] = iRec322[0];
			fRec320[1] = fRec320[0];
			fRec319[1] = fRec319[0];
			fRec317[1] = fRec317[0];
			fRec318[1] = fRec318[0];
			fVec21[1] = fVec21[0];
			fRec302[1] = fRec302[0];
			fRec330[1] = fRec330[0];
			iVec22[1] = iVec22[0];
			iRec331[1] = iRec331[0];
			fRec329[1] = fRec329[0];
			fRec328[1] = fRec328[0];
			fRec326[1] = fRec326[0];
			fRec327[1] = fRec327[0];
			fRec336[1] = fRec336[0];
			iVec23[1] = iVec23[0];
			iRec337[1] = iRec337[0];
			fRec335[1] = fRec335[0];
			fRec334[1] = fRec334[0];
			fRec332[1] = fRec332[0];
			fRec333[1] = fRec333[0];
			fRec338[1] = fRec338[0];
			fRec343[1] = fRec343[0];
			iVec24[1] = iVec24[0];
			iRec344[1] = iRec344[0];
			fRec342[1] = fRec342[0];
			fRec341[1] = fRec341[0];
			fRec339[1] = fRec339[0];
			fRec340[1] = fRec340[0];
			fRec349[1] = fRec349[0];
			iVec25[1] = iVec25[0];
			iRec350[1] = iRec350[0];
			fRec348[1] = fRec348[0];
			fRec347[1] = fRec347[0];
			fRec345[1] = fRec345[0];
			fRec346[1] = fRec346[0];
			fRec323[1] = fRec323[0];
			fRec324[1] = fRec324[0];
			fRec351[1] = fRec351[0];
			fRec352[1] = fRec352[0];
			fRec354[1] = fRec354[0];
			fRec355[1] = fRec355[0];
			fRec357[1] = fRec357[0];
			fRec358[1] = fRec358[0];
			fRec360[1] = fRec360[0];
			fRec361[1] = fRec361[0];
			fRec363[1] = fRec363[0];
			fRec364[1] = fRec364[0];
			fRec366[1] = fRec366[0];
			fRec367[1] = fRec367[0];
			fRec369[1] = fRec369[0];
			fRec370[1] = fRec370[0];
			fRec372[1] = fRec372[0];
			fRec373[1] = fRec373[0];
			fRec375[1] = fRec375[0];
			fRec376[1] = fRec376[0];
			fRec378[1] = fRec378[0];
			fRec379[1] = fRec379[0];
			fRec381[1] = fRec381[0];
			fRec382[1] = fRec382[0];
			fRec384[1] = fRec384[0];
			fRec385[1] = fRec385[0];
			fRec387[1] = fRec387[0];
			fRec388[1] = fRec388[0];
			fRec390[1] = fRec390[0];
			fRec391[1] = fRec391[0];
			fRec393[1] = fRec393[0];
			fRec394[1] = fRec394[0];
			fRec396[1] = fRec396[0];
			fRec397[1] = fRec397[0];
			fRec399[1] = fRec399[0];
			fRec400[1] = fRec400[0];
			fRec402[1] = fRec402[0];
			fRec403[1] = fRec403[0];
			fRec405[1] = fRec405[0];
			fRec406[1] = fRec406[0];
			fRec408[1] = fRec408[0];
			fRec409[1] = fRec409[0];
			fRec411[1] = fRec411[0];
			fRec412[1] = fRec412[0];
			fRec414[1] = fRec414[0];
			fRec415[1] = fRec415[0];
			fRec417[1] = fRec417[0];
			fRec418[1] = fRec418[0];
			fRec420[1] = fRec420[0];
			fRec421[1] = fRec421[0];
			fRec423[1] = fRec423[0];
			fRec424[1] = fRec424[0];
			fRec426[1] = fRec426[0];
			fRec427[1] = fRec427[0];
			fRec429[1] = fRec429[0];
			fRec430[1] = fRec430[0];
			fRec432[1] = fRec432[0];
			fRec433[1] = fRec433[0];
			fRec435[1] = fRec435[0];
			fRec436[1] = fRec436[0];
			fRec438[1] = fRec438[0];
			fRec439[1] = fRec439[0];
			fRec441[1] = fRec441[0];
			fRec442[1] = fRec442[0];
			fRec303[1] = fRec303[0];
			fRec5[1] = fRec5[0];
			fRec450[1] = fRec450[0];
			iVec26[1] = iVec26[0];
			iRec451[1] = iRec451[0];
			fRec449[1] = fRec449[0];
			fRec448[1] = fRec448[0];
			fRec446[1] = fRec446[0];
			fRec447[1] = fRec447[0];
			fRec457[1] = fRec457[0];
			iVec27[1] = iVec27[0];
			iRec458[1] = iRec458[0];
			fRec456[1] = fRec456[0];
			fRec455[1] = fRec455[0];
			fRec453[1] = fRec453[0];
			fRec454[1] = fRec454[0];
			fRec452[1] = fRec452[0];
			fRec463[1] = fRec463[0];
			iVec28[1] = iVec28[0];
			iRec464[1] = iRec464[0];
			fRec462[1] = fRec462[0];
			fRec461[1] = fRec461[0];
			fRec459[1] = fRec459[0];
			fRec460[1] = fRec460[0];
			fVec29[1] = fVec29[0];
			fRec444[1] = fRec444[0];
			fRec472[1] = fRec472[0];
			iVec30[1] = iVec30[0];
			iRec473[1] = iRec473[0];
			fRec471[1] = fRec471[0];
			fRec470[1] = fRec470[0];
			fRec468[1] = fRec468[0];
			fRec469[1] = fRec469[0];
			fRec478[1] = fRec478[0];
			iVec31[1] = iVec31[0];
			iRec479[1] = iRec479[0];
			fRec477[1] = fRec477[0];
			fRec476[1] = fRec476[0];
			fRec474[1] = fRec474[0];
			fRec475[1] = fRec475[0];
			fRec480[1] = fRec480[0];
			fRec485[1] = fRec485[0];
			iVec32[1] = iVec32[0];
			iRec486[1] = iRec486[0];
			fRec484[1] = fRec484[0];
			fRec483[1] = fRec483[0];
			fRec481[1] = fRec481[0];
			fRec482[1] = fRec482[0];
			fRec491[1] = fRec491[0];
			iVec33[1] = iVec33[0];
			iRec492[1] = iRec492[0];
			fRec490[1] = fRec490[0];
			fRec489[1] = fRec489[0];
			fRec487[1] = fRec487[0];
			fRec488[1] = fRec488[0];
			fRec465[1] = fRec465[0];
			fRec466[1] = fRec466[0];
			fRec493[1] = fRec493[0];
			fRec494[1] = fRec494[0];
			fRec496[1] = fRec496[0];
			fRec497[1] = fRec497[0];
			fRec499[1] = fRec499[0];
			fRec500[1] = fRec500[0];
			fRec502[1] = fRec502[0];
			fRec503[1] = fRec503[0];
			fRec505[1] = fRec505[0];
			fRec506[1] = fRec506[0];
			fRec508[1] = fRec508[0];
			fRec509[1] = fRec509[0];
			fRec511[1] = fRec511[0];
			fRec512[1] = fRec512[0];
			fRec514[1] = fRec514[0];
			fRec515[1] = fRec515[0];
			fRec517[1] = fRec517[0];
			fRec518[1] = fRec518[0];
			fRec520[1] = fRec520[0];
			fRec521[1] = fRec521[0];
			fRec523[1] = fRec523[0];
			fRec524[1] = fRec524[0];
			fRec526[1] = fRec526[0];
			fRec527[1] = fRec527[0];
			fRec529[1] = fRec529[0];
			fRec530[1] = fRec530[0];
			fRec532[1] = fRec532[0];
			fRec533[1] = fRec533[0];
			fRec535[1] = fRec535[0];
			fRec536[1] = fRec536[0];
			fRec538[1] = fRec538[0];
			fRec539[1] = fRec539[0];
			fRec541[1] = fRec541[0];
			fRec542[1] = fRec542[0];
			fRec544[1] = fRec544[0];
			fRec545[1] = fRec545[0];
			fRec547[1] = fRec547[0];
			fRec548[1] = fRec548[0];
			fRec550[1] = fRec550[0];
			fRec551[1] = fRec551[0];
			fRec553[1] = fRec553[0];
			fRec554[1] = fRec554[0];
			fRec556[1] = fRec556[0];
			fRec557[1] = fRec557[0];
			fRec559[1] = fRec559[0];
			fRec560[1] = fRec560[0];
			fRec562[1] = fRec562[0];
			fRec563[1] = fRec563[0];
			fRec565[1] = fRec565[0];
			fRec566[1] = fRec566[0];
			fRec568[1] = fRec568[0];
			fRec569[1] = fRec569[0];
			fRec571[1] = fRec571[0];
			fRec572[1] = fRec572[0];
			fRec574[1] = fRec574[0];
			fRec575[1] = fRec575[0];
			fRec577[1] = fRec577[0];
			fRec578[1] = fRec578[0];
			fRec580[1] = fRec580[0];
			fRec581[1] = fRec581[0];
			fRec583[1] = fRec583[0];
			fRec584[1] = fRec584[0];
			fRec445[1] = fRec445[0];
			fRec6[1] = fRec6[0];
			fRec592[1] = fRec592[0];
			iVec34[1] = iVec34[0];
			iRec593[1] = iRec593[0];
			fRec591[1] = fRec591[0];
			fRec590[1] = fRec590[0];
			fRec588[1] = fRec588[0];
			fRec589[1] = fRec589[0];
			fRec599[1] = fRec599[0];
			iVec35[1] = iVec35[0];
			iRec600[1] = iRec600[0];
			fRec598[1] = fRec598[0];
			fRec597[1] = fRec597[0];
			fRec595[1] = fRec595[0];
			fRec596[1] = fRec596[0];
			fRec594[1] = fRec594[0];
			fRec605[1] = fRec605[0];
			iVec36[1] = iVec36[0];
			iRec606[1] = iRec606[0];
			fRec604[1] = fRec604[0];
			fRec603[1] = fRec603[0];
			fRec601[1] = fRec601[0];
			fRec602[1] = fRec602[0];
			fVec37[1] = fVec37[0];
			fRec586[1] = fRec586[0];
			fRec614[1] = fRec614[0];
			iVec38[1] = iVec38[0];
			iRec615[1] = iRec615[0];
			fRec613[1] = fRec613[0];
			fRec612[1] = fRec612[0];
			fRec610[1] = fRec610[0];
			fRec611[1] = fRec611[0];
			fRec620[1] = fRec620[0];
			iVec39[1] = iVec39[0];
			iRec621[1] = iRec621[0];
			fRec619[1] = fRec619[0];
			fRec618[1] = fRec618[0];
			fRec616[1] = fRec616[0];
			fRec617[1] = fRec617[0];
			fRec622[1] = fRec622[0];
			fRec627[1] = fRec627[0];
			iVec40[1] = iVec40[0];
			iRec628[1] = iRec628[0];
			fRec626[1] = fRec626[0];
			fRec625[1] = fRec625[0];
			fRec623[1] = fRec623[0];
			fRec624[1] = fRec624[0];
			fRec633[1] = fRec633[0];
			iVec41[1] = iVec41[0];
			iRec634[1] = iRec634[0];
			fRec632[1] = fRec632[0];
			fRec631[1] = fRec631[0];
			fRec629[1] = fRec629[0];
			fRec630[1] = fRec630[0];
			fRec607[1] = fRec607[0];
			fRec608[1] = fRec608[0];
			fRec635[1] = fRec635[0];
			fRec636[1] = fRec636[0];
			fRec638[1] = fRec638[0];
			fRec639[1] = fRec639[0];
			fRec641[1] = fRec641[0];
			fRec642[1] = fRec642[0];
			fRec644[1] = fRec644[0];
			fRec645[1] = fRec645[0];
			fRec647[1] = fRec647[0];
			fRec648[1] = fRec648[0];
			fRec650[1] = fRec650[0];
			fRec651[1] = fRec651[0];
			fRec653[1] = fRec653[0];
			fRec654[1] = fRec654[0];
			fRec656[1] = fRec656[0];
			fRec657[1] = fRec657[0];
			fRec659[1] = fRec659[0];
			fRec660[1] = fRec660[0];
			fRec662[1] = fRec662[0];
			fRec663[1] = fRec663[0];
			fRec665[1] = fRec665[0];
			fRec666[1] = fRec666[0];
			fRec668[1] = fRec668[0];
			fRec669[1] = fRec669[0];
			fRec671[1] = fRec671[0];
			fRec672[1] = fRec672[0];
			fRec674[1] = fRec674[0];
			fRec675[1] = fRec675[0];
			fRec677[1] = fRec677[0];
			fRec678[1] = fRec678[0];
			fRec680[1] = fRec680[0];
			fRec681[1] = fRec681[0];
			fRec683[1] = fRec683[0];
			fRec684[1] = fRec684[0];
			fRec686[1] = fRec686[0];
			fRec687[1] = fRec687[0];
			fRec689[1] = fRec689[0];
			fRec690[1] = fRec690[0];
			fRec692[1] = fRec692[0];
			fRec693[1] = fRec693[0];
			fRec695[1] = fRec695[0];
			fRec696[1] = fRec696[0];
			fRec698[1] = fRec698[0];
			fRec699[1] = fRec699[0];
			fRec701[1] = fRec701[0];
			fRec702[1] = fRec702[0];
			fRec704[1] = fRec704[0];
			fRec705[1] = fRec705[0];
			fRec707[1] = fRec707[0];
			fRec708[1] = fRec708[0];
			fRec710[1] = fRec710[0];
			fRec711[1] = fRec711[0];
			fRec713[1] = fRec713[0];
			fRec714[1] = fRec714[0];
			fRec716[1] = fRec716[0];
			fRec717[1] = fRec717[0];
			fRec719[1] = fRec719[0];
			fRec720[1] = fRec720[0];
			fRec722[1] = fRec722[0];
			fRec723[1] = fRec723[0];
			fRec725[1] = fRec725[0];
			fRec726[1] = fRec726[0];
			fRec587[1] = fRec587[0];
			fRec7[1] = fRec7[0];
			fRec734[1] = fRec734[0];
			iVec42[1] = iVec42[0];
			iRec735[1] = iRec735[0];
			fRec733[1] = fRec733[0];
			fRec732[1] = fRec732[0];
			fRec730[1] = fRec730[0];
			fRec731[1] = fRec731[0];
			fRec741[1] = fRec741[0];
			iVec43[1] = iVec43[0];
			iRec742[1] = iRec742[0];
			fRec740[1] = fRec740[0];
			fRec739[1] = fRec739[0];
			fRec737[1] = fRec737[0];
			fRec738[1] = fRec738[0];
			fRec736[1] = fRec736[0];
			fRec747[1] = fRec747[0];
			iVec44[1] = iVec44[0];
			iRec748[1] = iRec748[0];
			fRec746[1] = fRec746[0];
			fRec745[1] = fRec745[0];
			fRec743[1] = fRec743[0];
			fRec744[1] = fRec744[0];
			fVec45[1] = fVec45[0];
			fRec728[1] = fRec728[0];
			fRec756[1] = fRec756[0];
			iVec46[1] = iVec46[0];
			iRec757[1] = iRec757[0];
			fRec755[1] = fRec755[0];
			fRec754[1] = fRec754[0];
			fRec752[1] = fRec752[0];
			fRec753[1] = fRec753[0];
			fRec762[1] = fRec762[0];
			iVec47[1] = iVec47[0];
			iRec763[1] = iRec763[0];
			fRec761[1] = fRec761[0];
			fRec760[1] = fRec760[0];
			fRec758[1] = fRec758[0];
			fRec759[1] = fRec759[0];
			fRec764[1] = fRec764[0];
			fRec769[1] = fRec769[0];
			iVec48[1] = iVec48[0];
			iRec770[1] = iRec770[0];
			fRec768[1] = fRec768[0];
			fRec767[1] = fRec767[0];
			fRec765[1] = fRec765[0];
			fRec766[1] = fRec766[0];
			fRec775[1] = fRec775[0];
			iVec49[1] = iVec49[0];
			iRec776[1] = iRec776[0];
			fRec774[1] = fRec774[0];
			fRec773[1] = fRec773[0];
			fRec771[1] = fRec771[0];
			fRec772[1] = fRec772[0];
			fRec749[1] = fRec749[0];
			fRec750[1] = fRec750[0];
			fRec777[1] = fRec777[0];
			fRec778[1] = fRec778[0];
			fRec780[1] = fRec780[0];
			fRec781[1] = fRec781[0];
			fRec783[1] = fRec783[0];
			fRec784[1] = fRec784[0];
			fRec786[1] = fRec786[0];
			fRec787[1] = fRec787[0];
			fRec789[1] = fRec789[0];
			fRec790[1] = fRec790[0];
			fRec792[1] = fRec792[0];
			fRec793[1] = fRec793[0];
			fRec795[1] = fRec795[0];
			fRec796[1] = fRec796[0];
			fRec798[1] = fRec798[0];
			fRec799[1] = fRec799[0];
			fRec801[1] = fRec801[0];
			fRec802[1] = fRec802[0];
			fRec804[1] = fRec804[0];
			fRec805[1] = fRec805[0];
			fRec807[1] = fRec807[0];
			fRec808[1] = fRec808[0];
			fRec810[1] = fRec810[0];
			fRec811[1] = fRec811[0];
			fRec813[1] = fRec813[0];
			fRec814[1] = fRec814[0];
			fRec816[1] = fRec816[0];
			fRec817[1] = fRec817[0];
			fRec819[1] = fRec819[0];
			fRec820[1] = fRec820[0];
			fRec822[1] = fRec822[0];
			fRec823[1] = fRec823[0];
			fRec825[1] = fRec825[0];
			fRec826[1] = fRec826[0];
			fRec828[1] = fRec828[0];
			fRec829[1] = fRec829[0];
			fRec831[1] = fRec831[0];
			fRec832[1] = fRec832[0];
			fRec834[1] = fRec834[0];
			fRec835[1] = fRec835[0];
			fRec837[1] = fRec837[0];
			fRec838[1] = fRec838[0];
			fRec840[1] = fRec840[0];
			fRec841[1] = fRec841[0];
			fRec843[1] = fRec843[0];
			fRec844[1] = fRec844[0];
			fRec846[1] = fRec846[0];
			fRec847[1] = fRec847[0];
			fRec849[1] = fRec849[0];
			fRec850[1] = fRec850[0];
			fRec852[1] = fRec852[0];
			fRec853[1] = fRec853[0];
			fRec855[1] = fRec855[0];
			fRec856[1] = fRec856[0];
			fRec858[1] = fRec858[0];
			fRec859[1] = fRec859[0];
			fRec861[1] = fRec861[0];
			fRec862[1] = fRec862[0];
			fRec864[1] = fRec864[0];
			fRec865[1] = fRec865[0];
			fRec867[1] = fRec867[0];
			fRec868[1] = fRec868[0];
			fRec729[1] = fRec729[0];
			fRec8[1] = fRec8[0];
			fRec876[1] = fRec876[0];
			iVec50[1] = iVec50[0];
			iRec877[1] = iRec877[0];
			fRec875[1] = fRec875[0];
			fRec874[1] = fRec874[0];
			fRec872[1] = fRec872[0];
			fRec873[1] = fRec873[0];
			fRec883[1] = fRec883[0];
			iVec51[1] = iVec51[0];
			iRec884[1] = iRec884[0];
			fRec882[1] = fRec882[0];
			fRec881[1] = fRec881[0];
			fRec879[1] = fRec879[0];
			fRec880[1] = fRec880[0];
			fRec878[1] = fRec878[0];
			fRec889[1] = fRec889[0];
			iVec52[1] = iVec52[0];
			iRec890[1] = iRec890[0];
			fRec888[1] = fRec888[0];
			fRec887[1] = fRec887[0];
			fRec885[1] = fRec885[0];
			fRec886[1] = fRec886[0];
			fVec53[1] = fVec53[0];
			fRec870[1] = fRec870[0];
			fRec898[1] = fRec898[0];
			iVec54[1] = iVec54[0];
			iRec899[1] = iRec899[0];
			fRec897[1] = fRec897[0];
			fRec896[1] = fRec896[0];
			fRec894[1] = fRec894[0];
			fRec895[1] = fRec895[0];
			fRec904[1] = fRec904[0];
			iVec55[1] = iVec55[0];
			iRec905[1] = iRec905[0];
			fRec903[1] = fRec903[0];
			fRec902[1] = fRec902[0];
			fRec900[1] = fRec900[0];
			fRec901[1] = fRec901[0];
			fRec906[1] = fRec906[0];
			fRec911[1] = fRec911[0];
			iVec56[1] = iVec56[0];
			iRec912[1] = iRec912[0];
			fRec910[1] = fRec910[0];
			fRec909[1] = fRec909[0];
			fRec907[1] = fRec907[0];
			fRec908[1] = fRec908[0];
			fRec917[1] = fRec917[0];
			iVec57[1] = iVec57[0];
			iRec918[1] = iRec918[0];
			fRec916[1] = fRec916[0];
			fRec915[1] = fRec915[0];
			fRec913[1] = fRec913[0];
			fRec914[1] = fRec914[0];
			fRec891[1] = fRec891[0];
			fRec892[1] = fRec892[0];
			fRec919[1] = fRec919[0];
			fRec920[1] = fRec920[0];
			fRec922[1] = fRec922[0];
			fRec923[1] = fRec923[0];
			fRec925[1] = fRec925[0];
			fRec926[1] = fRec926[0];
			fRec928[1] = fRec928[0];
			fRec929[1] = fRec929[0];
			fRec931[1] = fRec931[0];
			fRec932[1] = fRec932[0];
			fRec934[1] = fRec934[0];
			fRec935[1] = fRec935[0];
			fRec937[1] = fRec937[0];
			fRec938[1] = fRec938[0];
			fRec940[1] = fRec940[0];
			fRec941[1] = fRec941[0];
			fRec943[1] = fRec943[0];
			fRec944[1] = fRec944[0];
			fRec946[1] = fRec946[0];
			fRec947[1] = fRec947[0];
			fRec949[1] = fRec949[0];
			fRec950[1] = fRec950[0];
			fRec952[1] = fRec952[0];
			fRec953[1] = fRec953[0];
			fRec955[1] = fRec955[0];
			fRec956[1] = fRec956[0];
			fRec958[1] = fRec958[0];
			fRec959[1] = fRec959[0];
			fRec961[1] = fRec961[0];
			fRec962[1] = fRec962[0];
			fRec964[1] = fRec964[0];
			fRec965[1] = fRec965[0];
			fRec967[1] = fRec967[0];
			fRec968[1] = fRec968[0];
			fRec970[1] = fRec970[0];
			fRec971[1] = fRec971[0];
			fRec973[1] = fRec973[0];
			fRec974[1] = fRec974[0];
			fRec976[1] = fRec976[0];
			fRec977[1] = fRec977[0];
			fRec979[1] = fRec979[0];
			fRec980[1] = fRec980[0];
			fRec982[1] = fRec982[0];
			fRec983[1] = fRec983[0];
			fRec985[1] = fRec985[0];
			fRec986[1] = fRec986[0];
			fRec988[1] = fRec988[0];
			fRec989[1] = fRec989[0];
			fRec991[1] = fRec991[0];
			fRec992[1] = fRec992[0];
			fRec994[1] = fRec994[0];
			fRec995[1] = fRec995[0];
			fRec997[1] = fRec997[0];
			fRec998[1] = fRec998[0];
			fRec1000[1] = fRec1000[0];
			fRec1001[1] = fRec1001[0];
			fRec1003[1] = fRec1003[0];
			fRec1004[1] = fRec1004[0];
			fRec1006[1] = fRec1006[0];
			fRec1007[1] = fRec1007[0];
			fRec1009[1] = fRec1009[0];
			fRec1010[1] = fRec1010[0];
			fRec871[1] = fRec871[0];
			fRec9[1] = fRec9[0];
			fRec1018[1] = fRec1018[0];
			iVec58[1] = iVec58[0];
			iRec1019[1] = iRec1019[0];
			fRec1017[1] = fRec1017[0];
			fRec1016[1] = fRec1016[0];
			fRec1014[1] = fRec1014[0];
			fRec1015[1] = fRec1015[0];
			fRec1025[1] = fRec1025[0];
			iVec59[1] = iVec59[0];
			iRec1026[1] = iRec1026[0];
			fRec1024[1] = fRec1024[0];
			fRec1023[1] = fRec1023[0];
			fRec1021[1] = fRec1021[0];
			fRec1022[1] = fRec1022[0];
			fRec1020[1] = fRec1020[0];
			fRec1031[1] = fRec1031[0];
			iVec60[1] = iVec60[0];
			iRec1032[1] = iRec1032[0];
			fRec1030[1] = fRec1030[0];
			fRec1029[1] = fRec1029[0];
			fRec1027[1] = fRec1027[0];
			fRec1028[1] = fRec1028[0];
			fVec61[1] = fVec61[0];
			fRec1012[1] = fRec1012[0];
			fRec1040[1] = fRec1040[0];
			iVec62[1] = iVec62[0];
			iRec1041[1] = iRec1041[0];
			fRec1039[1] = fRec1039[0];
			fRec1038[1] = fRec1038[0];
			fRec1036[1] = fRec1036[0];
			fRec1037[1] = fRec1037[0];
			fRec1046[1] = fRec1046[0];
			iVec63[1] = iVec63[0];
			iRec1047[1] = iRec1047[0];
			fRec1045[1] = fRec1045[0];
			fRec1044[1] = fRec1044[0];
			fRec1042[1] = fRec1042[0];
			fRec1043[1] = fRec1043[0];
			fRec1048[1] = fRec1048[0];
			fRec1053[1] = fRec1053[0];
			iVec64[1] = iVec64[0];
			iRec1054[1] = iRec1054[0];
			fRec1052[1] = fRec1052[0];
			fRec1051[1] = fRec1051[0];
			fRec1049[1] = fRec1049[0];
			fRec1050[1] = fRec1050[0];
			fRec1059[1] = fRec1059[0];
			iVec65[1] = iVec65[0];
			iRec1060[1] = iRec1060[0];
			fRec1058[1] = fRec1058[0];
			fRec1057[1] = fRec1057[0];
			fRec1055[1] = fRec1055[0];
			fRec1056[1] = fRec1056[0];
			fRec1033[1] = fRec1033[0];
			fRec1034[1] = fRec1034[0];
			fRec1061[1] = fRec1061[0];
			fRec1062[1] = fRec1062[0];
			fRec1064[1] = fRec1064[0];
			fRec1065[1] = fRec1065[0];
			fRec1067[1] = fRec1067[0];
			fRec1068[1] = fRec1068[0];
			fRec1070[1] = fRec1070[0];
			fRec1071[1] = fRec1071[0];
			fRec1073[1] = fRec1073[0];
			fRec1074[1] = fRec1074[0];
			fRec1076[1] = fRec1076[0];
			fRec1077[1] = fRec1077[0];
			fRec1079[1] = fRec1079[0];
			fRec1080[1] = fRec1080[0];
			fRec1082[1] = fRec1082[0];
			fRec1083[1] = fRec1083[0];
			fRec1085[1] = fRec1085[0];
			fRec1086[1] = fRec1086[0];
			fRec1088[1] = fRec1088[0];
			fRec1089[1] = fRec1089[0];
			fRec1091[1] = fRec1091[0];
			fRec1092[1] = fRec1092[0];
			fRec1094[1] = fRec1094[0];
			fRec1095[1] = fRec1095[0];
			fRec1097[1] = fRec1097[0];
			fRec1098[1] = fRec1098[0];
			fRec1100[1] = fRec1100[0];
			fRec1101[1] = fRec1101[0];
			fRec1103[1] = fRec1103[0];
			fRec1104[1] = fRec1104[0];
			fRec1106[1] = fRec1106[0];
			fRec1107[1] = fRec1107[0];
			fRec1109[1] = fRec1109[0];
			fRec1110[1] = fRec1110[0];
			fRec1112[1] = fRec1112[0];
			fRec1113[1] = fRec1113[0];
			fRec1115[1] = fRec1115[0];
			fRec1116[1] = fRec1116[0];
			fRec1118[1] = fRec1118[0];
			fRec1119[1] = fRec1119[0];
			fRec1121[1] = fRec1121[0];
			fRec1122[1] = fRec1122[0];
			fRec1124[1] = fRec1124[0];
			fRec1125[1] = fRec1125[0];
			fRec1127[1] = fRec1127[0];
			fRec1128[1] = fRec1128[0];
			fRec1130[1] = fRec1130[0];
			fRec1131[1] = fRec1131[0];
			fRec1133[1] = fRec1133[0];
			fRec1134[1] = fRec1134[0];
			fRec1136[1] = fRec1136[0];
			fRec1137[1] = fRec1137[0];
			fRec1139[1] = fRec1139[0];
			fRec1140[1] = fRec1140[0];
			fRec1142[1] = fRec1142[0];
			fRec1143[1] = fRec1143[0];
			fRec1145[1] = fRec1145[0];
			fRec1146[1] = fRec1146[0];
			fRec1148[1] = fRec1148[0];
			fRec1149[1] = fRec1149[0];
			fRec1151[1] = fRec1151[0];
			fRec1152[1] = fRec1152[0];
			fRec1013[1] = fRec1013[0];
			fRec10[1] = fRec10[0];
			iRec1157[1] = iRec1157[0];
			fRec1158[1] = fRec1158[0];
			fRec1155[1] = fRec1155[0];
			fRec1154[1] = fRec1154[0];
			iRec1163[1] = iRec1163[0];
			fRec1164[1] = fRec1164[0];
			fRec1161[1] = fRec1161[0];
			fRec1160[1] = fRec1160[0];
			iRec1169[1] = iRec1169[0];
			fRec1170[1] = fRec1170[0];
			fRec1167[1] = fRec1167[0];
			fRec1166[1] = fRec1166[0];
			iRec1175[1] = iRec1175[0];
			fRec1176[1] = fRec1176[0];
			fRec1173[1] = fRec1173[0];
			fRec1172[1] = fRec1172[0];
			fRec0[1] = fRec0[0];
			iRec1182[1] = iRec1182[0];
			fRec1183[1] = fRec1183[0];
			fRec1180[1] = fRec1180[0];
			fRec1179[1] = fRec1179[0];
			iRec1188[1] = iRec1188[0];
			fRec1189[1] = fRec1189[0];
			fRec1186[1] = fRec1186[0];
			fRec1185[1] = fRec1185[0];
			iRec1194[1] = iRec1194[0];
			fRec1195[1] = fRec1195[0];
			fRec1192[1] = fRec1192[0];
			fRec1191[1] = fRec1191[0];
			iRec1200[1] = iRec1200[0];
			fRec1201[1] = fRec1201[0];
			fRec1198[1] = fRec1198[0];
			fRec1197[1] = fRec1197[0];
			fRec1177[1] = fRec1177[0];
			fRec1202[1] = fRec1202[0];
			fRec1203[1] = fRec1203[0];
			fRec1204[1] = fRec1204[0];
			fRec1205[1] = fRec1205[0];
			fRec1206[1] = fRec1206[0];
			fRec1207[1] = fRec1207[0];
		}
	}

};

/***************************END USER SECTION ***************************/

/*******************BEGIN ARCHITECTURE SECTION (part 2/2)***************/

/************************** BEGIN poly-dsp.h *************************
FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
*********************************************************************/

#ifndef __poly_dsp__
#define __poly_dsp__

#include <stdio.h>
#include <string>
#include <cmath>
#include <algorithm>
#include <functional>
#include <ostream>
#include <sstream>
#include <vector>
#include <limits.h>
#include <float.h>
#include <assert.h>

/************************** BEGIN dsp-combiner.h **************************
FAUST Architecture File
Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

EXCEPTION : As a special exception, you may create a larger work
that contains this FAUST architecture section and distribute
that work under terms of your choice, so long as this FAUST
architecture section is not modified.
************************************************************************/

#ifndef __dsp_combiner__
#define __dsp_combiner__

#include <string.h>
#include <string>
#include <assert.h>
#include <sstream>


/**
 * @file dsp-combiner.h
 * @brief DSP Combiner Library
 *
 * This library provides classes for combining DSP modules.
 * It includes classes for sequencing, parallelizing, splitting, merging, recursing, and crossfading DSP modules.
 *
 */

enum Layout { kVerticalGroup, kHorizontalGroup, kTabGroup };

/**
 * @class dsp_binary_combiner
 * @brief Base class and common code for binary combiners
 *
 * This class serves as the base class for various DSP combiners that work with two DSP modules.
 * It provides common methods for building user interfaces, allocating and deleting channels, and more.
 */
class dsp_binary_combiner : public dsp {

    protected:

        dsp* fDSP1;
        dsp* fDSP2;
        int fBufferSize;
        Layout fLayout;
        std::string fLabel;

        void buildUserInterfaceAux(UI* ui_interface)
        {
            switch (fLayout) {
                case kHorizontalGroup:
                    ui_interface->openHorizontalBox(fLabel.c_str());
                    fDSP1->buildUserInterface(ui_interface);
                    fDSP2->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                    break;
                case kVerticalGroup:
                    ui_interface->openVerticalBox(fLabel.c_str());
                    fDSP1->buildUserInterface(ui_interface);
                    fDSP2->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                    break;
                case kTabGroup:
                    ui_interface->openTabBox(fLabel.c_str());
                    ui_interface->openVerticalBox("DSP1");
                    fDSP1->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                    ui_interface->openVerticalBox("DSP2");
                    fDSP2->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                    ui_interface->closeBox();
                    break;
            }
        }

        FAUSTFLOAT** allocateChannels(int num)
        {
            FAUSTFLOAT** channels = new FAUSTFLOAT*[num];
            for (int chan = 0; chan < num; chan++) {
                channels[chan] = new FAUSTFLOAT[fBufferSize];
                memset(channels[chan], 0, sizeof(FAUSTFLOAT) * fBufferSize);
            }
            return channels;
        }

        void deleteChannels(FAUSTFLOAT** channels, int num)
        {
            for (int chan = 0; chan < num; chan++) {
                delete [] channels[chan];
            }
            delete [] channels;
        }

     public:

        dsp_binary_combiner(dsp* dsp1, dsp* dsp2, int buffer_size, Layout layout, const std::string& label)
        :fDSP1(dsp1), fDSP2(dsp2), fBufferSize(buffer_size), fLayout(layout), fLabel(label)
        {}

        virtual ~dsp_binary_combiner()
        {
            delete fDSP1;
            delete fDSP2;
        }

        virtual int getSampleRate()
        {
            return fDSP1->getSampleRate();
        }
        virtual void init(int sample_rate)
        {
            fDSP1->init(sample_rate);
            fDSP2->init(sample_rate);
        }
        virtual void instanceInit(int sample_rate)
        {
            fDSP1->instanceInit(sample_rate);
            fDSP2->instanceInit(sample_rate);
        }
        virtual void instanceConstants(int sample_rate)
        {
            fDSP1->instanceConstants(sample_rate);
            fDSP2->instanceConstants(sample_rate);
        }

        virtual void instanceResetUserInterface()
        {
            fDSP1->instanceResetUserInterface();
            fDSP2->instanceResetUserInterface();
        }

        virtual void instanceClear()
        {
            fDSP1->instanceClear();
            fDSP2->instanceClear();
        }

        virtual void metadata(Meta* m)
        {
            fDSP1->metadata(m);
            fDSP2->metadata(m);
        }

};

/**
 * @class dsp_sequencer
 * @brief Combine two 'compatible' DSP modules in sequence
 *
 * This class allows you to combine two DSP modules in sequence.
 * It computes the first DSP module's outputs and uses them as inputs for the second DSP module.
 */
class dsp_sequencer : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP1Outputs;

    public:

        dsp_sequencer(dsp* dsp1, dsp* dsp2,
                      int buffer_size = 4096,
                      Layout layout = Layout::kTabGroup,
                      const std::string& label = "Sequencer")
        :dsp_binary_combiner(dsp1, dsp2, buffer_size, layout, label)
        {
            fDSP1Outputs = allocateChannels(fDSP1->getNumOutputs());
        }

        virtual ~dsp_sequencer()
        {
            deleteChannels(fDSP1Outputs, fDSP1->getNumOutputs());
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP2->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface);
        }

        virtual dsp* clone()
        {
            return new dsp_sequencer(fDSP1->clone(), fDSP2->clone(), fBufferSize, fLayout, fLabel);
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            fDSP1->compute(count, inputs, fDSP1Outputs);
            fDSP2->compute(count, fDSP1Outputs, outputs);
        }

        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }

};

/**
 * @class dsp_parallelizer
 * @brief Combine two DSP modules in parallel
 *
 * This class combines two DSP modules in parallel.
 * It computes both DSP modules separately and combines their outputs.
 */
class dsp_parallelizer : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP2Inputs;
        FAUSTFLOAT** fDSP2Outputs;

    public:

        dsp_parallelizer(dsp* dsp1, dsp* dsp2,
                     int buffer_size = 4096,
                     Layout layout = Layout::kTabGroup,
                     const std::string& label = "Parallelizer")
        :dsp_binary_combiner(dsp1, dsp2, buffer_size, layout, label)
        {
            fDSP2Inputs = new FAUSTFLOAT*[fDSP2->getNumInputs()];
            fDSP2Outputs = new FAUSTFLOAT*[fDSP2->getNumOutputs()];
        }

        virtual ~dsp_parallelizer()
        {
            delete [] fDSP2Inputs;
            delete [] fDSP2Outputs;
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs() + fDSP2->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP1->getNumOutputs() + fDSP2->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface);
        }

        virtual dsp* clone()
        {
            return new dsp_parallelizer(fDSP1->clone(), fDSP2->clone(), fBufferSize, fLayout, fLabel);
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            fDSP1->compute(count, inputs, outputs);

            // Shift inputs/outputs channels for fDSP2
            for (int chan = 0; chan < fDSP2->getNumInputs(); chan++) {
                fDSP2Inputs[chan] = inputs[fDSP1->getNumInputs() + chan];
            }
            for (int chan = 0; chan < fDSP2->getNumOutputs(); chan++) {
                fDSP2Outputs[chan] = outputs[fDSP1->getNumOutputs() + chan];
            }

            fDSP2->compute(count, fDSP2Inputs, fDSP2Outputs);
        }

        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }

};

/**
 * @class dsp_splitter
 * @brief Combine two 'compatible' DSP modules in a splitter
 *
 * This class combines two DSP modules in a splitter configuration.
 * The outputs of the first DSP module are connected to the inputs of the second DSP module.
 */
class dsp_splitter : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP1Outputs;
        FAUSTFLOAT** fDSP2Inputs;

    public:

        dsp_splitter(dsp* dsp1, dsp* dsp2,
                     int buffer_size = 4096,
                     Layout layout = Layout::kTabGroup,
                     const std::string& label = "Splitter")
        :dsp_binary_combiner(dsp1, dsp2, buffer_size, layout, label)
        {
            fDSP1Outputs = allocateChannels(fDSP1->getNumOutputs());
            fDSP2Inputs = new FAUSTFLOAT*[fDSP2->getNumInputs()];
        }

        virtual ~dsp_splitter()
        {
            deleteChannels(fDSP1Outputs, fDSP1->getNumOutputs());
            delete [] fDSP2Inputs;
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP2->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface);
        }

        virtual dsp* clone()
        {
            return new dsp_splitter(fDSP1->clone(), fDSP2->clone(), fBufferSize, fLayout, fLabel);
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            fDSP1->compute(count, inputs, fDSP1Outputs);

            for (int chan = 0; chan < fDSP2->getNumInputs(); chan++) {
                 fDSP2Inputs[chan] = fDSP1Outputs[chan % fDSP1->getNumOutputs()];
            }

            fDSP2->compute(count, fDSP2Inputs, outputs);
        }
};

/**
 * @class dsp_merger
 * @brief Combine two 'compatible' DSP modules in a merger
 *
 * This class combines two DSP modules in a merger configuration.
 * The outputs of the first DSP module are combined with the inputs of the second DSP module.
 */
class dsp_merger : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP1Inputs;
        FAUSTFLOAT** fDSP1Outputs;
        FAUSTFLOAT** fDSP2Inputs;

        void mix(int count, FAUSTFLOAT* dst, FAUSTFLOAT* src)
        {
            for (int frame = 0; frame < count; frame++) {
                dst[frame] += src[frame];
            }
        }

    public:

        dsp_merger(dsp* dsp1, dsp* dsp2,
                   int buffer_size = 4096,
                   Layout layout = Layout::kTabGroup,
                   const std::string& label = "Merger")
        :dsp_binary_combiner(dsp1, dsp2, buffer_size, layout, label)
        {
            fDSP1Inputs = allocateChannels(fDSP1->getNumInputs());
            fDSP1Outputs = allocateChannels(fDSP1->getNumOutputs());
            fDSP2Inputs = new FAUSTFLOAT*[fDSP2->getNumInputs()];
        }

        virtual ~dsp_merger()
        {
            deleteChannels(fDSP1Inputs, fDSP1->getNumInputs());
            deleteChannels(fDSP1Outputs, fDSP1->getNumOutputs());
            delete [] fDSP2Inputs;
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP2->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface);
        }

        virtual dsp* clone()
        {
            return new dsp_merger(fDSP1->clone(), fDSP2->clone(), fBufferSize, fLayout, fLabel);
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            fDSP1->compute(count, fDSP1Inputs, fDSP1Outputs);

            memset(fDSP2Inputs, 0, sizeof(FAUSTFLOAT*) * fDSP2->getNumInputs());

            for (int chan = 0; chan < fDSP1->getNumOutputs(); chan++) {
                int mchan = chan % fDSP2->getNumInputs();
                if (fDSP2Inputs[mchan]) {
                    mix(count, fDSP2Inputs[mchan], fDSP1Outputs[chan]);
                } else {
                    fDSP2Inputs[mchan] = fDSP1Outputs[chan];
                }
            }

            fDSP2->compute(count, fDSP2Inputs, outputs);
        }
};

/**
 * @class dsp_recursiver
 * @brief Combine two 'compatible' DSP modules in a recursive way
 *
 * This class recursively combines two DSP modules.
 * The outputs of each module are fed as inputs to the other module in a recursive manner.
 */
class dsp_recursiver : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP1Inputs;
        FAUSTFLOAT** fDSP1Outputs;

        FAUSTFLOAT** fDSP2Inputs;
        FAUSTFLOAT** fDSP2Outputs;

    public:

        dsp_recursiver(dsp* dsp1, dsp* dsp2,
                       Layout layout = Layout::kTabGroup,
                       const std::string& label = "Recursiver")
        :dsp_binary_combiner(dsp1, dsp2, 1, layout, label)
        {
            fDSP1Inputs = allocateChannels(fDSP1->getNumInputs());
            fDSP1Outputs = allocateChannels(fDSP1->getNumOutputs());
            fDSP2Inputs = allocateChannels(fDSP2->getNumInputs());
            fDSP2Outputs = allocateChannels(fDSP2->getNumOutputs());
        }

        virtual ~dsp_recursiver()
        {
            deleteChannels(fDSP1Inputs, fDSP1->getNumInputs());
            deleteChannels(fDSP1Outputs, fDSP1->getNumOutputs());
            deleteChannels(fDSP2Inputs, fDSP2->getNumInputs());
            deleteChannels(fDSP2Outputs, fDSP2->getNumOutputs());
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs() - fDSP2->getNumOutputs(); }
        virtual int getNumOutputs() { return fDSP1->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface);
        }

        virtual dsp* clone()
        {
            return new dsp_recursiver(fDSP1->clone(), fDSP2->clone(), fLayout, fLabel);
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            for (int frame = 0; (frame < count); frame++) {

                for (int chan = 0; chan < fDSP2->getNumOutputs(); chan++) {
                    fDSP1Inputs[chan][0] = fDSP2Outputs[chan][0];
                }

                for (int chan = 0; chan < fDSP1->getNumInputs() - fDSP2->getNumOutputs(); chan++) {
                    fDSP1Inputs[chan + fDSP2->getNumOutputs()][0] = inputs[chan][frame];
                }

                fDSP1->compute(1, fDSP1Inputs, fDSP1Outputs);

                for (int chan = 0; chan < fDSP1->getNumOutputs(); chan++) {
                    outputs[chan][frame] = fDSP1Outputs[chan][0];
                }

                for (int chan = 0; chan < fDSP2->getNumInputs(); chan++) {
                    fDSP2Inputs[chan][0] = fDSP1Outputs[chan][0];
                }

                fDSP2->compute(1, fDSP2Inputs, fDSP2Outputs);
            }
        }

        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }

};

/**
 * @class dsp_crossfader
 * @brief Crossfade between two DSP modules
 *
 * This class allows you to crossfade between two DSP modules.
 * The crossfade parameter (as a slider) controls the mix between the two modules' outputs.
 * When Crossfade = 1, the first DSP only is computed, when Crossfade = 0,
 * the second DSP only is computed, otherwise both DSPs are computed and mixed.
 */
class dsp_crossfader: public dsp_binary_combiner {

    private:
    
        FAUSTFLOAT fCrossfade;
        FAUSTFLOAT** fDSPOutputs1;
        FAUSTFLOAT** fDSPOutputs2;
    
    public:
    
        dsp_crossfader(dsp* dsp1, dsp* dsp2,
                       Layout layout = Layout::kTabGroup,
                       const std::string& label = "Crossfade")
        :dsp_binary_combiner(dsp1, dsp2, 4096, layout, label),fCrossfade(FAUSTFLOAT(0.5))
        {
            fDSPOutputs1 = allocateChannels(fDSP1->getNumOutputs());
            fDSPOutputs2 = allocateChannels(fDSP1->getNumOutputs());
        }
    
        virtual ~dsp_crossfader()
        {
            deleteChannels(fDSPOutputs1, fDSP1->getNumInputs());
            deleteChannels(fDSPOutputs2, fDSP1->getNumOutputs());
        }
    
        virtual int getNumInputs() { return fDSP1->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP1->getNumOutputs(); }

        void buildUserInterface(UI* ui_interface)
        {
            switch (fLayout) {
                case kHorizontalGroup:
                    ui_interface->openHorizontalBox(fLabel.c_str());
                    ui_interface->addHorizontalSlider("Crossfade", &fCrossfade, FAUSTFLOAT(0.5), FAUSTFLOAT(0), FAUSTFLOAT(1), FAUSTFLOAT(0.01));
                    fDSP1->buildUserInterface(ui_interface);
                    fDSP2->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                    break;
                case kVerticalGroup:
                    ui_interface->openVerticalBox(fLabel.c_str());
                    ui_interface->addHorizontalSlider("Crossfade", &fCrossfade, FAUSTFLOAT(0.5), FAUSTFLOAT(0), FAUSTFLOAT(1), FAUSTFLOAT(0.01));
                    fDSP1->buildUserInterface(ui_interface);
                    fDSP2->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                    break;
                case kTabGroup:
                    ui_interface->openTabBox(fLabel.c_str());
                    ui_interface->openVerticalBox("Crossfade");
                    ui_interface->addHorizontalSlider("Crossfade", &fCrossfade, FAUSTFLOAT(0.5), FAUSTFLOAT(0), FAUSTFLOAT(1), FAUSTFLOAT(0.01));
                    ui_interface->closeBox();
                    ui_interface->openVerticalBox("DSP1");
                    fDSP1->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                    ui_interface->openVerticalBox("DSP2");
                    fDSP2->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                    ui_interface->closeBox();
                    break;
            }
        }
    
        virtual dsp* clone()
        {
            return new dsp_crossfader(fDSP1->clone(), fDSP2->clone(), fLayout, fLabel);
        }
    
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            if (fCrossfade == FAUSTFLOAT(1)) {
                fDSP1->compute(count, inputs, outputs);
            } else if (fCrossfade == FAUSTFLOAT(0)) {
                fDSP2->compute(count, inputs, outputs);
            } else {
                // Compute each effect
                fDSP1->compute(count, inputs, fDSPOutputs1);
                fDSP2->compute(count, inputs, fDSPOutputs2);
                // Mix between the two effects
                FAUSTFLOAT gain1 = fCrossfade;
                FAUSTFLOAT gain2 = FAUSTFLOAT(1) - gain1;
                for (int frame = 0; (frame < count); frame++) {
                    for (int chan = 0; chan < fDSP1->getNumOutputs(); chan++) {
                        outputs[chan][frame] = fDSPOutputs1[chan][frame] * gain1 + fDSPOutputs2[chan][frame] * gain2;
                    }
                }
            }
        }
    
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }
};

#ifndef __dsp_algebra_api__
#define __dsp_algebra_api__

/**
 * DSP algebra API
 * Each operation takes two DSP and a optional Layout and Label parameters, returns the combined DSPs,
 * or null if failure with an error message.
 * It includes methods to create sequencers, parallelizers, splitters, mergers, recursives, and crossfaders.
 */

/**
 * Create a DSP Sequencer
 *
 * This method creates a DSP Sequencer, which combines two DSP modules in a sequencer configuration.
 * The outputs of the first DSP module are connected to the inputs of the second DSP module.
 *
 * @param dsp1 The first DSP module to combine
 * @param dsp2 The second DSP module to combine
 * @param error A reference to a string to store error messages (if any)
 * @param layout The layout for the user interface (default: kTabGroup)
 * @param label The label for the combiner (default: "Sequencer")
 * @return A pointer to the created DSP Sequencer, or nullptr if an error occurs
 */
static dsp* createDSPSequencer(dsp* dsp1, dsp* dsp2,
                               std::string& error,
                               Layout layout = Layout::kTabGroup,
                               const std::string& label = "Sequencer")
{
    if (dsp1->getNumOutputs() != dsp2->getNumInputs()) {
        std::stringstream error_aux;
        error_aux << "Connection error in dsp_sequencer : the number of outputs ("
                  << dsp1->getNumOutputs() << ") of A "
                  << "must be equal to the number of inputs (" << dsp2->getNumInputs() << ") of B" << std::endl;
        error = error_aux.str();
        return nullptr;
    } else {
        return new dsp_sequencer(dsp1, dsp2, 4096, layout, label);
    }
}

/**
 * Create a DSP Parallelizer
 *
 * This method creates a DSP Parallelizer, which combines two DSP modules in parallel.
 * The resulting DSP module computes both input modules separately and combines their outputs.
 *
 * @param dsp1 The first DSP module to combine
 * @param dsp2 The second DSP module to combine
 * @param error A reference to a string to store error messages (if any)
 * @param layout The layout for the user interface (default: kTabGroup)
 * @param label The label for the combiner (default: "Parallelizer")
 * @return A pointer to the created DSP Parallelizer, or nullptr if an error occurs
 */
static dsp* createDSPParallelizer(dsp* dsp1, dsp* dsp2,
                                  std::string& error,
                                  Layout layout = Layout::kTabGroup,
                                  const std::string& label = "Parallelizer")
{
    return new dsp_parallelizer(dsp1, dsp2, 4096, layout, label);
}

/**
 * Create a DSP Splitter
 *
 * This method creates a DSP Splitter, which combines two 'compatible' DSP modules in a splitter configuration.
 * The outputs of the first DSP module are connected to the inputs of the second DSP module.
 *
 * @param dsp1 The first DSP module to combine
 * @param dsp2 The second DSP module to combine
 * @param error A reference to a string to store error messages (if any)
 * @param layout The layout for the user interface (default: kTabGroup)
 * @param label The label for the combiner (default: "Splitter")
 * @return A pointer to the created DSP Splitter, or nullptr if an error occurs
 */
static dsp* createDSPSplitter(dsp* dsp1, dsp* dsp2, std::string& error, Layout layout = Layout::kTabGroup, const std::string& label = "Splitter")
{
    if (dsp1->getNumOutputs() == 0) {
        error = "Connection error in dsp_splitter : the first expression has no outputs\n";
        return nullptr;
    } else if (dsp2->getNumInputs() == 0) {
        error = "Connection error in dsp_splitter : the second expression has no inputs\n";
        return nullptr;
    } else if (dsp2->getNumInputs() % dsp1->getNumOutputs() != 0) {
        std::stringstream error_aux;
        error_aux << "Connection error in dsp_splitter : the number of outputs (" << dsp1->getNumOutputs()
                  << ") of the first expression should be a divisor of the number of inputs ("
                  << dsp2->getNumInputs()
                  << ") of the second expression" << std::endl;
        error = error_aux.str();
        return nullptr;
    } else if (dsp2->getNumInputs() == dsp1->getNumOutputs()) {
        return new dsp_sequencer(dsp1, dsp2, 4096, layout, label);
    } else {
        return new dsp_splitter(dsp1, dsp2, 4096, layout, label);
    }
}

/**
 * Create a DSP Merger
 *
 * This method creates a DSP Merger, which combines two 'compatible' DSP modules in a merger configuration.
 * The outputs of the first DSP module are combined with the inputs of the second DSP module.
 *
 * @param dsp1 The first DSP module to combine
 * @param dsp2 The second DSP module to combine
 * @param error A reference to a string to store error messages (if any)
 * @param layout The layout for the user interface (default: kTabGroup)
 * @param label The label for the combiner (default: "Merger")
 * @return A pointer to the created DSP Merger, or nullptr if an error occurs
 */
static dsp* createDSPMerger(dsp* dsp1, dsp* dsp2,
                            std::string& error,
                            Layout layout = Layout::kTabGroup,
                            const std::string& label = "Merger")
{
    if (dsp1->getNumOutputs() == 0) {
        error = "Connection error in dsp_merger : the first expression has no outputs\n";
        return nullptr;
    } else if (dsp2->getNumInputs() == 0) {
        error = "Connection error in dsp_merger : the second expression has no inputs\n";
        return nullptr;
    } else if (dsp1->getNumOutputs() % dsp2->getNumInputs() != 0) {
        std::stringstream error_aux;
        error_aux << "Connection error in dsp_merger : the number of outputs (" << dsp1->getNumOutputs()
                  << ") of the first expression should be a multiple of the number of inputs ("
                  << dsp2->getNumInputs()
                  << ") of the second expression" << std::endl;
        error = error_aux.str();
        return nullptr;
    } else if (dsp2->getNumInputs() == dsp1->getNumOutputs()) {
        return new dsp_sequencer(dsp1, dsp2, 4096, layout, label);
    } else {
        return new dsp_merger(dsp1, dsp2, 4096, layout, label);
    }
}

/**
 * Create a DSP Recursiver
 *
 * This method creates a DSP Recursiver, which combines two 'compatible' DSP modules in a recursive way.
 * The outputs of each module are fed as inputs to the other module in a recursive manner.
 *
 * @param dsp1 The first DSP module to combine
 * @param dsp2 The second DSP module to combine
 * @param error A reference to a string to store error messages (if any)
 * @param layout The layout for the user interface (default: kTabGroup)
 * @param label The label for the combiner (default: "Recursiver")
 * @return A pointer to the created DSP Recursiver, or nullptr if an error occurs
 */
static dsp* createDSPRecursiver(dsp* dsp1, dsp* dsp2,
                                std::string& error,
                                Layout layout = Layout::kTabGroup,
                                const std::string& label = "Recursiver")
{
    if ((dsp2->getNumInputs() > dsp1->getNumOutputs()) || (dsp2->getNumOutputs() > dsp1->getNumInputs())) {
        std::stringstream error_aux;
        error_aux << "Connection error in : dsp_recursiver" << std::endl;
        if (dsp2->getNumInputs() > dsp1->getNumOutputs()) {
            error_aux << "The number of outputs " << dsp1->getNumOutputs()
                      << " of the first expression should be greater or equal to the number of inputs ("
                      << dsp2->getNumInputs()
                      << ") of the second expression" << std::endl;
        }
        if (dsp2->getNumOutputs() > dsp1->getNumInputs()) {
            error_aux << "The number of inputs " << dsp1->getNumInputs()
                      << " of the first expression should be greater or equal to the number of outputs ("
                      << dsp2->getNumOutputs()
                      << ") of the second expression" << std::endl;
        }
        error = error_aux.str();
        return nullptr;
    } else {
        return new dsp_recursiver(dsp1, dsp2, layout, label);
    }
}

/**
 * Create a DSP Crossfader
 *
 * This method creates a DSP Crossfader, which allows you to crossfade between two DSP modules.
 * The crossfade parameter (as a slider) controls the mix between the two modules' outputs.
 * When Crossfade = 1, the first DSP only is computed, when Crossfade = 0,
 * the second DSP only is computed, otherwise both DSPs are computed and mixed.
 *
 * @param dsp1 The first DSP module to combine
 * @param dsp2 The second DSP module to combine
 * @param error A reference to a string to store error messages (if any)
 * @param layout The layout for the user interface (default: kTabGroup)
 * @param label The label for the crossfade slider (default: "Crossfade")
 * @return A pointer to the created DSP Crossfader, or nullptr if an error occurs
 */
static dsp* createDSPCrossfader(dsp* dsp1, dsp* dsp2,
                                std::string& error,
                                Layout layout = Layout::kTabGroup,
                                const std::string& label = "Crossfade")
{
    if (dsp1->getNumInputs() != dsp2->getNumInputs()) {
        std::stringstream error_aux;
        error_aux << "Error in dsp_crossfader : the number of inputs ("
        << dsp1->getNumInputs() << ") of A "
        << "must be equal to the number of inputs (" << dsp2->getNumInputs() << ") of B" << std::endl;
        error = error_aux.str();
        return nullptr;
    } else if (dsp1->getNumOutputs() != dsp2->getNumOutputs()) {
        std::stringstream error_aux;
        error_aux << "Error in dsp_crossfader : the number of outputs ("
        << dsp1->getNumOutputs() << ") of A "
        << "must be equal to the number of outputs (" << dsp2->getNumOutputs() << ") of B" << std::endl;
        error = error_aux.str();
        return nullptr;
    } else {
        return new dsp_crossfader(dsp1, dsp2, layout, label);
    }
}

#endif

#endif
/************************** END dsp-combiner.h **************************/

/************************** BEGIN JSONControl.h **************************
 FAUST Architecture File
 Copyright (C) 2003-2022 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; either version 2.1 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 *************************************************************************/

#ifndef __JSON_CONTROL__
#define __JSON_CONTROL__

#include <string>

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

struct FAUST_API JSONControl {
    
    virtual std::string getJSON() { return ""; }

    virtual void setParamValue(const std::string& path, FAUSTFLOAT value) {}

    virtual FAUSTFLOAT getParamValue(const std::string& path) { return 0; }
    
    virtual ~JSONControl()
    {}
    
};

#endif
/**************************  END  JSONControl.h **************************/

#define kActiveVoice    0
#define kFreeVoice     -1
#define kReleaseVoice  -2
#define kLegatoVoice   -3
#define kNoVoice       -4

#define VOICE_STOP_LEVEL  0.0005    // -70 db
#define MIX_BUFFER_SIZE   4096

/**
 * Allows to control zones in a grouped manner.
 */
class GroupUI : public GUI, public PathBuilder {

    private:

        // Map to associate labels with UI group items
        std::map<std::string, uiGroupItem*> fLabelZoneMap;

        // Insert a zone into the map based on the label folloing the freq/gain/gate polyphonic convention
        void insertMap(std::string label, FAUSTFLOAT* zone)
        {
            if (!MapUI::endsWith(label, "/gate")
                && !MapUI::endsWith(label, "/freq")
                && !MapUI::endsWith(label, "/key")
                && !MapUI::endsWith(label, "/gain")
                && !MapUI::endsWith(label, "/vel")
                && !MapUI::endsWith(label, "/velocity")) {

                // Groups all controllers except 'freq/key', 'gate', and 'gain/vel|velocity'
                if (fLabelZoneMap.find(label) != fLabelZoneMap.end()) {
                    fLabelZoneMap[label]->addZone(zone);
                } else {
                    fLabelZoneMap[label] = new uiGroupItem(this, zone);
                }
            }
        }

        uiCallbackItem* fPanic;

    public:

        GroupUI(FAUSTFLOAT* zone, uiCallback cb, void* arg)
        {
            fPanic = new uiCallbackItem(this, zone, cb, arg);
        }
    
        virtual ~GroupUI()
        {
            // 'fPanic' is kept and deleted in GUI, so do not delete here
        }

        // -- widget's layouts
        void openTabBox(const char* label)
        {
            pushLabel(label);
        }
        void openHorizontalBox(const char* label)
        {
            pushLabel(label);
        }
        void openVerticalBox(const char* label)
        {
            pushLabel(label);
        }
        void closeBox()
        {
            popLabel();
        }

        // -- active widgets
        void addButton(const char* label, FAUSTFLOAT* zone)
        {
            insertMap(buildPath(label), zone);
        }
        void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            insertMap(buildPath(label), zone);
        }
        void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            insertMap(buildPath(label), zone);
        }
        void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            insertMap(buildPath(label), zone);
        }
        void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            insertMap(buildPath(label), zone);
        }

        // -- passive widgets
        void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
        {
            insertMap(buildPath(label), zone);
        }
        void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
        {
            insertMap(buildPath(label), zone);
        }

};

/**
 * One voice of polyphony.
 */
struct dsp_voice : public MapUI, public decorator_dsp {
    
    typedef std::function<double(int)> TransformFunction;
  
    // Convert MIDI note to frequency
    static double midiToFreq(double note)
    {
        return 440.0 * std::pow(2.0, (note-69.0)/12.0);
    }
    
    // Voice state and properties
    int fCurNote;                       // Current playing note pitch
    int fNextNote;                      // In kLegatoVoice state, next note to play
    int fNextVel;                       // In kLegatoVoice state, next velocity to play
    int fDate;                          // KeyOn date
    int fRelease;                       // Current number of samples used in release mode to detect end of note
    FAUSTFLOAT fLevel;                  // Last audio block level
    double fReleaseLengthSec;           // Maximum release length in seconds (estimated time to silence after note release)
    std::vector<std::string> fGatePath; // Paths of 'gate' control
    std::vector<std::string> fGainPath; // Paths of 'gain/vel|velocity' control
    std::vector<std::string> fFreqPath; // Paths of 'freq/key' control
    TransformFunction        fKeyFun;   // MIDI key to freq conversion function
    TransformFunction        fVelFun;   // MIDI velocity to gain conversion function
    
    FAUSTFLOAT** fInputsSlice;
    FAUSTFLOAT** fOutputsSlice;
 
    dsp_voice(dsp* dsp):decorator_dsp(dsp)
    {
        // Default conversion functions
        fVelFun = [](int velocity) { return double(velocity)/127.0; };
        fKeyFun = [](int pitch) { return midiToFreq(pitch); };
        dsp->buildUserInterface(this);
        fCurNote = kFreeVoice;
        fNextNote = fNextVel = -1;
        fLevel = FAUSTFLOAT(0);
        fDate = fRelease = 0;
        fReleaseLengthSec = 0.5;  // A half second is a reasonable default maximum release length.
        extractPaths(fGatePath, fFreqPath, fGainPath);
    }
    virtual ~dsp_voice()
    {}
    
    // Compute a slice of audio
    void computeSlice(int offset, int slice, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
    {
        FAUSTFLOAT** inputsSlice = static_cast<FAUSTFLOAT**>(alloca(sizeof(FAUSTFLOAT*) * getNumInputs()));
        for (int chan = 0; chan < getNumInputs(); chan++) {
            inputsSlice[chan] = &(inputs[chan][offset]);
        }
        FAUSTFLOAT** outputsSlice = static_cast<FAUSTFLOAT**>(alloca(sizeof(FAUSTFLOAT*) * getNumOutputs()));
        for (int chan = 0; chan < getNumOutputs(); chan++) {
            outputsSlice[chan] = &(outputs[chan][offset]);
        }
        compute(slice, inputsSlice, outputsSlice);
    }
    
    // Compute audio in legato mode
    void computeLegato(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
    {
        int slice = count/2;
        
        // Reset envelops
        for (size_t i = 0; i < fGatePath.size(); i++) {
            setParamValue(fGatePath[i], FAUSTFLOAT(0));
        }
        
        // Compute current voice on half buffer
        computeSlice(0, slice, inputs, outputs);
         
        // Start next keyOn
        keyOn(fNextNote, fNextVel);
        
        // Compute on second half buffer
        computeSlice(slice, slice, inputs, outputs);
    }

    // Extract control paths from fullpath map
    void extractPaths(std::vector<std::string>& gate, std::vector<std::string>& freq, std::vector<std::string>& gain)
    {
        // Keep gain/vel|velocity, freq/key and gate labels
        for (const auto& it : getFullpathMap()) {
            std::string path = it.first;
            if (endsWith(path, "/gate")) {
                gate.push_back(path);
            } else if (endsWith(path, "/freq")) {
                fKeyFun = [](int pitch) { return midiToFreq(pitch); };
                freq.push_back(path);
            } else if (endsWith(path, "/key")) {
                fKeyFun = [](int pitch) { return pitch; };
                freq.push_back(path);
            } else if (endsWith(path, "/gain")) {
                fVelFun = [](int velocity) { return double(velocity)/127.0; };
                gain.push_back(path);
            } else if (endsWith(path, "/vel") || endsWith(path, "/velocity")) {
                fVelFun = [](int velocity) { return double(velocity); };
                gain.push_back(path);
            }
        }
    }
    
    // Reset voice
    void reset()
    {
        init(getSampleRate());
    }
 
    // Clear instance state
    void instanceClear()
    {
        decorator_dsp::instanceClear();
        fCurNote = kFreeVoice;
        fNextNote = fNextVel = -1;
        fLevel = FAUSTFLOAT(0);
        fDate = fRelease = 0;
    }
    
    // Keep 'pitch' and 'velocity' to fadeOut the current voice and start next one in the next buffer
    void keyOn(int pitch, int velocity, bool legato = false)
    {
        if (legato) {
            fNextNote = pitch;
            fNextVel = velocity;
        } else {
            keyOn(pitch, fVelFun(velocity));
        }
    }

    // KeyOn with normalized MIDI velocity [0..1]
    void keyOn(int pitch, double velocity)
    {
        for (size_t i = 0; i < fFreqPath.size(); i++) {
            setParamValue(fFreqPath[i], fKeyFun(pitch));
        }
        for (size_t i = 0; i < fGatePath.size(); i++) {
            setParamValue(fGatePath[i], FAUSTFLOAT(1));
        }
        for (size_t i = 0; i < fGainPath.size(); i++) {
            setParamValue(fGainPath[i], velocity);
        }
        
        fCurNote = pitch;
    }

    void keyOff(bool hard = false)
    {
        // No use of velocity for now...
        for (size_t i = 0; i < fGatePath.size(); i++) {
            setParamValue(fGatePath[i], FAUSTFLOAT(0));
        }
        
        if (hard) {
            // Immediately stop voice
            fCurNote = kFreeVoice;
        } else {
            // Release voice
            fRelease = fReleaseLengthSec * fDSP->getSampleRate();
            fCurNote = kReleaseVoice;
        }
    }
 
    // Change the voice release
    void setReleaseLength(double sec)
    {
        fReleaseLengthSec = sec;
    }

};

/**
 * A group of voices.
 */
struct dsp_voice_group {

    // GUI group for controlling voice parameters
    GroupUI fGroups;

    std::vector<dsp_voice*> fVoiceTable; // Individual voices
    dsp* fVoiceGroup;                    // Voices group to be used for GUI grouped control

    FAUSTFLOAT fPanic;  // Panic button value

    bool fVoiceControl; // Voice control mode
    bool fGroupControl; // Group control mode

    dsp_voice_group(uiCallback cb, void* arg, bool control, bool group)
        :fGroups(&fPanic, cb, arg),
        fVoiceGroup(0), fPanic(FAUSTFLOAT(0)),
        fVoiceControl(control), fGroupControl(group)
    {}

    virtual ~dsp_voice_group()
    {
        for (size_t i = 0; i < fVoiceTable.size(); i++) {
            delete fVoiceTable[i];
        }
        delete fVoiceGroup;
    }

    // Add a voice to the group
    void addVoice(dsp_voice* voice)
    {
        fVoiceTable.push_back(voice);
    }
        
    // Clear all voices from the group
    void clearVoices()
    {
        fVoiceTable.clear();
    }

    // Initialize the voice group
    void init()
    {
        // Groups all uiItem for a given path
        fVoiceGroup = new proxy_dsp(fVoiceTable[0]);
        fVoiceGroup->buildUserInterface(&fGroups);
        for (size_t i = 0; i < fVoiceTable.size(); i++) {
            fVoiceTable[i]->buildUserInterface(&fGroups);
        }
    }
    
    // Reset the user interface for each voice instance
    void instanceResetUserInterface()
    {
        for (size_t i = 0; i < fVoiceTable.size(); i++) {
            fVoiceTable[i]->instanceResetUserInterface();
        }
    }

    // Build the user interface for the voice group
    void buildUserInterface(UI* ui_interface)
    {
        if (fVoiceTable.size() > 1) {
            ui_interface->openTabBox("Polyphonic");

            // Grouped voices UI
            ui_interface->openVerticalBox("Voices");
            ui_interface->addButton("Panic", &fPanic);
            fVoiceGroup->buildUserInterface(ui_interface);
            ui_interface->closeBox();

            // If not grouped, also add individual voices UI
            if (!fGroupControl || dynamic_cast<SoundUIInterface*>(ui_interface)) {
                for (size_t i = 0; i < fVoiceTable.size(); i++) {
                    char buffer[32];
                    snprintf(buffer, 32, ((fVoiceTable.size() < 8) ? "Voice%ld" : "V%ld"), long(i+1));
                    ui_interface->openHorizontalBox(buffer);
                    fVoiceTable[i]->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                }
            }

            ui_interface->closeBox();
        } else {
            fVoiceTable[0]->buildUserInterface(ui_interface);
        }
    }

};

/**
 * Base class for MIDI controllable polyphonic DSP.
 */
#ifdef EMCC
#endif

class dsp_poly : public decorator_dsp, public midi, public JSONControl {

    protected:
    
    #ifdef EMCC
        MapUI fMapUI;               // Map for UI control
        std::string fJSON;          // JSON representation of the UI
        midi_handler fMidiHandler;  // MIDI handler for the UI
        MidiUI fMIDIUI;             // MIDI UI for the DSP
    #endif
    
    public:
    
    #ifdef EMCC
        dsp_poly(dsp* dsp):decorator_dsp(dsp), fMIDIUI(&fMidiHandler)
        {
            JSONUI jsonui(getNumInputs(), getNumOutputs());
            buildUserInterface(&jsonui);
            fJSON = jsonui.JSON(true);
            buildUserInterface(&fMapUI);
            buildUserInterface(&fMIDIUI);
        }
    #else
        dsp_poly(dsp* dsp):decorator_dsp(dsp)
        {}
    #endif
    
        virtual ~dsp_poly() {}
    
        // Reimplemented for EMCC
    #ifdef EMCC
        virtual int getNumInputs() { return decorator_dsp::getNumInputs(); }
        virtual int getNumOutputs() { return decorator_dsp::getNumOutputs(); }
        virtual void buildUserInterface(UI* ui_interface) { decorator_dsp::buildUserInterface(ui_interface); }
        virtual int getSampleRate() { return decorator_dsp::getSampleRate(); }
        virtual void init(int sample_rate) { decorator_dsp::init(sample_rate); }
        virtual void instanceInit(int sample_rate) { decorator_dsp::instanceInit(sample_rate); }
        virtual void instanceConstants(int sample_rate) { decorator_dsp::instanceConstants(sample_rate); }
        virtual void instanceResetUserInterface() { decorator_dsp::instanceResetUserInterface(); }
        virtual void instanceClear() { decorator_dsp::instanceClear(); }
        virtual dsp_poly* clone() { return new dsp_poly(fDSP->clone()); }
        virtual void metadata(Meta* m) { decorator_dsp::metadata(m); }
    
        // Additional API
        std::string getJSON()
        {
            return fJSON;
        }
    
        virtual void setParamValue(const std::string& path, FAUSTFLOAT value)
        {
            fMapUI.setParamValue(path, value);
            GUI::updateAllGuis();
        }
        
        virtual FAUSTFLOAT getParamValue(const std::string& path) { return fMapUI.getParamValue(path); }

        virtual void computeJS(int count, uintptr_t inputs, uintptr_t outputs)
        {
            decorator_dsp::compute(count, reinterpret_cast<FAUSTFLOAT**>(inputs),reinterpret_cast<FAUSTFLOAT**>(outputs));
        }
    #endif
    
        virtual MapUI* keyOn(int channel, int pitch, int velocity)
        {
            return midi::keyOn(channel, pitch, velocity);
        }
        virtual void keyOff(int channel, int pitch, int velocity)
        {
            midi::keyOff(channel, pitch, velocity);
        }
        virtual void keyPress(int channel, int pitch, int press)
        {
            midi::keyPress(channel, pitch, press);
        }
        virtual void chanPress(int channel, int press)
        {
            midi::chanPress(channel, press);
        }
        virtual void ctrlChange(int channel, int ctrl, int value)
        {
            midi::ctrlChange(channel, ctrl, value);
        }
        virtual void ctrlChange14bits(int channel, int ctrl, int value)
        {
            midi::ctrlChange14bits(channel, ctrl, value);
        }
        virtual void pitchWheel(int channel, int wheel)
        {
        #ifdef EMCC
            fMIDIUI.pitchWheel(0., channel, wheel);
            GUI::updateAllGuis();
        #else
            midi::pitchWheel(channel, wheel);
        #endif
        }
        virtual void progChange(int channel, int pgm)
        {
            midi::progChange(channel, pgm);
        }
    
        // Change the voice release
        virtual void setReleaseLength(double seconds)
        {}
    
};

/**
 * Polyphonic DSP: groups a set of DSP to be played together or triggered by MIDI.
 *
 * All voices are preallocated by cloning the single DSP voice given at creation time.
 * Dynamic voice allocation is done in 'getFreeVoice'
 */
class mydsp_poly : public dsp_voice_group, public dsp_poly {

    private:

        FAUSTFLOAT** fMixBuffer;        // Intermediate buffer for mixing voices
        FAUSTFLOAT** fOutBuffer;        // Intermediate buffer for output
        midi_interface* fMidiHandler;   // The midi_interface the DSP is connected to
        int fDate;                      // Current date for managing voices
    
        // Fade out the audio in the buffer
        void fadeOut(int count, FAUSTFLOAT** outBuffer)
        {
            // FadeOut on half buffer
            for (int chan = 0; chan < getNumOutputs(); chan++) {
                double factor = 1., step = 1./double(count);
                for (int frame = 0; frame < count; frame++) {
                    outBuffer[chan][frame] *= factor;
                    factor -= step;
                }
            }
        }
    
        // Mix the audio from the mix buffer to the output buffer, and also calculate the maximum level on the buffer
        FAUSTFLOAT mixCheckVoice(int count, FAUSTFLOAT** mixBuffer, FAUSTFLOAT** outBuffer)
        {
            FAUSTFLOAT level = 0;
            for (int chan = 0; chan < getNumOutputs(); chan++) {
                FAUSTFLOAT* mixChannel = mixBuffer[chan];
                FAUSTFLOAT* outChannel = outBuffer[chan];
                for (int frame = 0; frame < count; frame++) {
                    level = std::max<FAUSTFLOAT>(level, (FAUSTFLOAT)fabs(mixChannel[frame]));
                    outChannel[frame] += mixChannel[frame];
                }
            }
            return level;
        }
    
        // Mix the audio from the mix buffer to the output buffer
        void mixVoice(int count, FAUSTFLOAT** mixBuffer, FAUSTFLOAT** outBuffer)
        {
            for (int chan = 0; chan < getNumOutputs(); chan++) {
                FAUSTFLOAT* mixChannel = mixBuffer[chan];
                FAUSTFLOAT* outChannel = outBuffer[chan];
                for (int frame = 0; frame < count; frame++) {
                    outChannel[frame] += mixChannel[frame];
                }
            }
        }
    
        // Copy the audio from one buffer to another
        void copy(int count, FAUSTFLOAT** mixBuffer, FAUSTFLOAT** outBuffer)
        {
            for (int chan = 0; chan < getNumOutputs(); chan++) {
                memcpy(outBuffer[chan], mixBuffer[chan], count * sizeof(FAUSTFLOAT));
            }
        }

        // Clear the audio buffer
        void clear(int count, FAUSTFLOAT** outBuffer)
        {
            for (int chan = 0; chan < getNumOutputs(); chan++) {
                memset(outBuffer[chan], 0, count * sizeof(FAUSTFLOAT));
            }
        }
    
        // Get the index of a voice currently playing a specific pitch
        int getPlayingVoice(int pitch)
        {
            int voice_playing = kNoVoice;
            int oldest_date_playing = INT_MAX;
            
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                if (fVoiceTable[i]->fCurNote == pitch) {
                    // Keeps oldest playing voice
                    if (fVoiceTable[i]->fDate < oldest_date_playing) {
                        oldest_date_playing = fVoiceTable[i]->fDate;
                        voice_playing = int(i);
                    }
                }
            }
            
            return voice_playing;
        }
    
        // Allocate a voice with a given type
        int allocVoice(int voice, int type)
        {
            fVoiceTable[voice]->fDate++;
            fVoiceTable[voice]->fCurNote = type;
            return voice;
        }
    
        // Get a free voice for allocation, always returns a voice
        int getFreeVoice()
        {
            // Looks for the first available voice
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                if (fVoiceTable[i]->fCurNote == kFreeVoice) {
                    return allocVoice(i, kActiveVoice);
                }
            }

            // Otherwise steal one
            int voice_release = kNoVoice;
            int voice_playing = kNoVoice;
            int oldest_date_release = INT_MAX;
            int oldest_date_playing = INT_MAX;

            // Scan all voices
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                if (fVoiceTable[i]->fCurNote == kReleaseVoice) {
                    // Keeps oldest release voice
                    if (fVoiceTable[i]->fDate < oldest_date_release) {
                        oldest_date_release = fVoiceTable[i]->fDate;
                        voice_release = int(i);
                    }
                } else {
                    // Otherwise keeps oldest playing voice
                    if (fVoiceTable[i]->fDate < oldest_date_playing) {
                        oldest_date_playing = fVoiceTable[i]->fDate;
                        voice_playing = int(i);
                    }
                }
            }
        
            // Then decide which one to steal
            if (oldest_date_release != INT_MAX) {
                fprintf(stderr, "Steal release voice : voice_date = %d cur_date = %d voice = %d \n",
                        fVoiceTable[voice_release]->fDate,
                        fDate,
                        voice_release);
                return allocVoice(voice_release, kLegatoVoice);
            } else if (oldest_date_playing != INT_MAX) {
                fprintf(stderr, "Steal playing voice : voice_date = %d cur_date = %d voice = %d \n",
                        fVoiceTable[voice_playing]->fDate,
                        fDate,
                        voice_release);
                return allocVoice(voice_playing, kLegatoVoice);
            } else {
                assert(false);
                return kNoVoice;
            }
        }

        // Callback for panic button
        static void panic(FAUSTFLOAT val, void* arg)
        {
            if (val == FAUSTFLOAT(1)) {
                static_cast<mydsp_poly*>(arg)->allNotesOff(true);
            }
        }

        // Check if the DSP is polyphonic
        bool checkPolyphony()
        {
            if (fVoiceTable.size() > 0) {
                return true;
            } else {
                fprintf(stderr, "DSP is not polyphonic...\n");
                return false;
            }
        }

    public:
    
        /**
         * Constructor.
         *
         * @param dsp - the dsp to be used for one voice. Beware: mydsp_poly will use and finally delete the pointer.
         * @param nvoices - number of polyphony voices, should be at least 1
         * @param control - whether voices will be dynamically allocated and controlled (typically by a MIDI controler).
         *                If false all voices are always running.
         * @param group - if true, voices are not individually accessible, a global "Voices" tab will automatically dispatch
         *                a given control on all voices, assuming GUI::updateAllGuis() is called.
         *                If false, all voices can be individually controlled.
         *
         */
        mydsp_poly(dsp* dsp,
                   int nvoices,
                   bool control = false,
                   bool group = true)
        : dsp_voice_group(panic, this, control, group), dsp_poly(dsp) // dsp parameter is deallocated by ~dsp_poly
        {
            fDate = 0;
            fMidiHandler = nullptr;

            // Create voices
            assert(nvoices > 0);
            for (int i = 0; i < nvoices; i++) {
                addVoice(new dsp_voice(dsp->clone()));
            }

            // Init audio output buffers
            fMixBuffer = new FAUSTFLOAT*[getNumOutputs()];
            fOutBuffer = new FAUSTFLOAT*[getNumOutputs()];
            for (int chan = 0; chan < getNumOutputs(); chan++) {
                fMixBuffer[chan] = new FAUSTFLOAT[MIX_BUFFER_SIZE];
                fOutBuffer[chan] = new FAUSTFLOAT[MIX_BUFFER_SIZE];
            }

            dsp_voice_group::init();
        }

        virtual ~mydsp_poly()
        {
            // Remove from fMidiHandler
            if (fMidiHandler) fMidiHandler->removeMidiIn(this);
            for (int chan = 0; chan < getNumOutputs(); chan++) {
                delete[] fMixBuffer[chan];
                delete[] fOutBuffer[chan];
            }
            delete[] fMixBuffer;
            delete[] fOutBuffer;
            
        }

        // DSP API
        void buildUserInterface(UI* ui_interface)
        {
            // MidiUI ui_interface contains the midi_handler connected to the MIDI driver
            if (dynamic_cast<midi_interface*>(ui_interface)) {
                fMidiHandler = dynamic_cast<midi_interface*>(ui_interface);
                fMidiHandler->addMidiIn(this);
            }
            dsp_voice_group::buildUserInterface(ui_interface);
        }

        void init(int sample_rate)
        {
            decorator_dsp::init(sample_rate);
            fVoiceGroup->init(sample_rate);
            fPanic = FAUSTFLOAT(0);
            
            // Init voices
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->init(sample_rate);
            }
        }
    
        void instanceInit(int samplingFreq)
        {
            instanceConstants(samplingFreq);
            instanceResetUserInterface();
            instanceClear();
        }

        void instanceConstants(int sample_rate)
        {
            decorator_dsp::instanceConstants(sample_rate);
            fVoiceGroup->instanceConstants(sample_rate);
            
            // Init voices
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->instanceConstants(sample_rate);
            }
        }

        void instanceResetUserInterface()
        {
            decorator_dsp::instanceResetUserInterface();
            fVoiceGroup->instanceResetUserInterface();
            fPanic = FAUSTFLOAT(0);
            
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->instanceResetUserInterface();
            }
        }

        void instanceClear()
        {
            decorator_dsp::instanceClear();
            fVoiceGroup->instanceClear();
            
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->instanceClear();
            }
        }

        virtual mydsp_poly* clone()
        {
            return new mydsp_poly(fDSP->clone(), int(fVoiceTable.size()), fVoiceControl, fGroupControl);
        }

        void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            assert(count <= MIX_BUFFER_SIZE);

            // First clear the intermediate fOutBuffer
            clear(count, fOutBuffer);

            if (fVoiceControl) {
                // Mix all playing voices
                for (size_t i = 0; i < fVoiceTable.size(); i++) {
                    dsp_voice* voice = fVoiceTable[i];
                    if (voice->fCurNote == kLegatoVoice) {
                        // Play from current note and next note
                        voice->computeLegato(count, inputs, fMixBuffer);
                        // FadeOut on first half buffer
                        fadeOut(count/2, fMixBuffer);
                        // Mix it in result
                        voice->fLevel = mixCheckVoice(count, fMixBuffer, fOutBuffer);
                    } else if (voice->fCurNote != kFreeVoice) {
                        // Compute current note
                        voice->compute(count, inputs, fMixBuffer);
                        // Mix it in result
                        voice->fLevel = mixCheckVoice(count, fMixBuffer, fOutBuffer);
                        // Check the level to possibly set the voice in kFreeVoice again
                        voice->fRelease -= count;
                        if ((voice->fCurNote == kReleaseVoice)
                            && (voice->fRelease < 0)
                            && (voice->fLevel < VOICE_STOP_LEVEL)) {
                            voice->fCurNote = kFreeVoice;
                        }
                    }
                }
            } else {
                // Mix all voices
                for (size_t i = 0; i < fVoiceTable.size(); i++) {
                    fVoiceTable[i]->compute(count, inputs, fMixBuffer);
                    mixVoice(count, fMixBuffer, fOutBuffer);
                }
            }
            
            // Finally copy intermediate buffer to outputs
            copy(count, fOutBuffer, outputs);
        }

        void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            compute(count, inputs, outputs);
        }
    
        // Terminate all active voices, gently or immediately (depending of 'hard' value)
        void allNotesOff(bool hard = false)
        {
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->keyOff(hard);
            }
        }
 
        // Additional polyphonic API
        MapUI* newVoice()
        {
            return fVoiceTable[getFreeVoice()];
        }

        void deleteVoice(MapUI* voice)
        {
            auto it = find(fVoiceTable.begin(), fVoiceTable.end(), reinterpret_cast<dsp_voice*>(voice));
            if (it != fVoiceTable.end()) {
                dsp_voice* voice = *it;
                voice->keyOff();
                voice->reset();
            } else {
                fprintf(stderr, "Voice not found\n");
            }
        }

        // MIDI API
        MapUI* keyOn(int channel, int pitch, int velocity)
        {
            if (checkPolyphony()) {
                int voice = getFreeVoice();
                fVoiceTable[voice]->keyOn(pitch, velocity, fVoiceTable[voice]->fCurNote == kLegatoVoice);
                return fVoiceTable[voice];
            } else {
                return 0;
            }
        }

        void keyOff(int channel, int pitch, int velocity = 127)
        {
            if (checkPolyphony()) {
                int voice = getPlayingVoice(pitch);
                if (voice != kNoVoice) {
                    fVoiceTable[voice]->keyOff();
                } else {
                    fprintf(stderr, "Playing pitch = %d not found\n", pitch);
                }
            }
        }

        void ctrlChange(int channel, int ctrl, int value)
        {
            if (ctrl == ALL_NOTES_OFF || ctrl == ALL_SOUND_OFF) {
                allNotesOff();
            }
        }

        // Change the voice release
        void setReleaseLength(double seconds)
        {
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->setReleaseLength(seconds);
            }
        }

};

/**
 * Polyphonic DSP with an integrated effect.
 */
class dsp_poly_effect : public dsp_poly {
    
    private:
    
        // fPolyDSP will respond to MIDI messages.
        dsp_poly* fPolyDSP;
        
    public:
        
        dsp_poly_effect(dsp_poly* voice, dsp* combined)
        :dsp_poly(combined), fPolyDSP(voice)
        {}
        
        virtual ~dsp_poly_effect()
        {
            // dsp_poly_effect is also a decorator_dsp, which will free fPolyDSP
        }
    
        // MIDI API
        MapUI* keyOn(int channel, int pitch, int velocity)
        {
            return fPolyDSP->keyOn(channel, pitch, velocity);
        }
        void keyOff(int channel, int pitch, int velocity)
        {
            fPolyDSP->keyOff(channel, pitch, velocity);
        }
        void keyPress(int channel, int pitch, int press)
        {
            fPolyDSP->keyPress(channel, pitch, press);
        }
        void chanPress(int channel, int press)
        {
            fPolyDSP->chanPress(channel, press);
        }
        void ctrlChange(int channel, int ctrl, int value)
        {
            fPolyDSP->ctrlChange(channel, ctrl, value);
        }
        void ctrlChange14bits(int channel, int ctrl, int value)
        {
            fPolyDSP->ctrlChange14bits(channel, ctrl, value);
        }
        void pitchWheel(int channel, int wheel)
        {
            fPolyDSP->pitchWheel(channel, wheel);
        }
        void progChange(int channel, int pgm)
        {
            fPolyDSP->progChange(channel, pgm);
        }
    
        // Change the voice release
        void setReleaseLength(double sec)
        {
            fPolyDSP->setReleaseLength(sec);
        }
    
};

/**
 * Polyphonic DSP factory class. Helper code to support polyphonic DSP source with an integrated effect.
 */
struct dsp_poly_factory : public dsp_factory {
    
    dsp_factory* fProcessFactory;
    dsp_factory* fEffectFactory;
    
    dsp* adaptDSP(dsp* dsp, bool is_double)
    {
        return (is_double) ? new dsp_sample_adapter<double, float>(dsp) : dsp;
    }

    dsp_poly_factory(dsp_factory* process_factory = nullptr,
                     dsp_factory* effect_factory = nullptr):
    fProcessFactory(process_factory)
    ,fEffectFactory(effect_factory)
    {}

    virtual ~dsp_poly_factory()
    {}

    std::string getName() { return fProcessFactory->getName(); }
    std::string getSHAKey() { return fProcessFactory->getSHAKey(); }
    std::string getDSPCode() { return fProcessFactory->getDSPCode(); }
    std::string getCompileOptions() { return fProcessFactory->getCompileOptions(); }
    std::vector<std::string> getLibraryList() { return fProcessFactory->getLibraryList(); }
    std::vector<std::string> getIncludePathnames() { return fProcessFactory->getIncludePathnames(); }
    std::vector<std::string> getWarningMessages() { return fProcessFactory->getWarningMessages(); }
   
    std::string getEffectCode(const std::string& dsp_content)
    {
        std::stringstream effect_code;
        effect_code << "adapt(1,1) = _; adapt(2,2) = _,_; adapt(1,2) = _ <: _,_; adapt(2,1) = _,_ :> _;";
        effect_code << "adaptor(F,G) = adapt(outputs(F),inputs(G)); dsp_code = environment{ " << dsp_content << " };";
        effect_code << "process = adaptor(dsp_code.process, dsp_code.effect) : dsp_code.effect;";
        return effect_code.str();
    }

    virtual void setMemoryManager(dsp_memory_manager* manager)
    {
        fProcessFactory->setMemoryManager(manager);
        if (fEffectFactory) {
            fEffectFactory->setMemoryManager(manager);
        }
    }
    virtual dsp_memory_manager* getMemoryManager() { return fProcessFactory->getMemoryManager(); }

    /* Create a new polyphonic DSP instance with global effect, to be deleted with C++ 'delete'
     *
     * @param nvoices - number of polyphony voices, should be at least 1
     * @param control - whether voices will be dynamically allocated and controlled (typically by a MIDI controler).
     *                If false all voices are always running.
     * @param group - if true, voices are not individually accessible, a global "Voices" tab will automatically dispatch
     *                a given control on all voices, assuming GUI::updateAllGuis() is called.
     *                If false, all voices can be individually controlled.
     * @param is_double - if true, internally allocated DSPs will be adapted to receive 'double' samples.
     */
    dsp_poly* createPolyDSPInstance(int nvoices, bool control, bool group, bool is_double = false)
    {
        dsp_poly* dsp_poly = new mydsp_poly(adaptDSP(fProcessFactory->createDSPInstance(), is_double), nvoices, control, group);
        if (fEffectFactory) {
            // the 'dsp_poly' object has to be controlled with MIDI, so kept separated from new dsp_sequencer(...) object
            return new dsp_poly_effect(dsp_poly, new dsp_sequencer(dsp_poly, adaptDSP(fEffectFactory->createDSPInstance(), is_double)));
        } else {
            return new dsp_poly_effect(dsp_poly, dsp_poly);
        }
    }

    /* Create a new DSP instance, to be deleted with C++ 'delete' */
    dsp* createDSPInstance()
    {
        return fProcessFactory->createDSPInstance();
    }

};

#endif // __poly_dsp__
/************************** END poly-dsp.h **************************/

#ifdef POLY2
#include "effect.h"
#endif

using namespace std;

dsp* DSP;

list<GUI*> GUI::fGuiList;
ztimedmap GUI::gTimedZoneMap;

/******************************************************************************
 *******************************************************************************
 
 MAIN PLAY THREAD
 
 *******************************************************************************
 *******************************************************************************/

int main(int argc, char* argv[])
{
    char name[256];
    char rcfilename[256];
    char* home = getenv("HOME");
    bool midi_sync = false;
    int nvoices = 0;
    bool control = true;
    
    if (isopt(argv, "-help") || isopt(argv, "-h")) {
        cout << argv[0] << " [--frequency <val>] [--buffer <val>] [--nvoices <val>] [--control <0/1>] [--group <0/1>] [--virtual-midi <0/1>]\n";
        exit(1);
    }
    
    mydsp* tmp_dsp = new mydsp();
    MidiMeta::analyse(tmp_dsp, midi_sync, nvoices);
    delete tmp_dsp;
    
    snprintf(name, 256, "%s", basename(argv[0]));
    snprintf(rcfilename, 256, "%s/.%src", home, name);
    
    long srate = (long)lopt(argv, "--frequency", -1);
    int fpb = lopt(argv, "--buffer", 512);
    bool is_virtual = lopt(argv, "--virtual-midi", false);
    
#ifdef POLY2
    nvoices = lopt(argv, "--nvoices", nvoices);
    control = lopt(argv, "--control", control);
    int group = lopt(argv, "--group", 1);
    
    cout << "Started with " << nvoices << " voices\n";
    DSP = new mydsp_poly(new mydsp(), nvoices, control, group);
    
#if MIDICTRL
    if (midi_sync) {
        DSP = new timed_dsp(new dsp_sequencer(DSP, new effect()));
    } else {
        DSP = new dsp_sequencer(DSP, new effect());
    }
#else
    DSP = new dsp_sequencer(DSP, new effect());
#endif
    
#else
    nvoices = lopt(argv, "--nvoices", nvoices);
    control = lopt(argv, "--control", control);
    int group = lopt(argv, "--group", 1);
    
    if (nvoices > 0) {
        cout << "Started with " << nvoices << " voices\n";
        DSP = new mydsp_poly(new mydsp(), nvoices, control, group);
        
#if MIDICTRL
        if (midi_sync) {
            DSP = new timed_dsp(DSP);
        }
#endif
        
    } else {
#if MIDICTRL
        if (midi_sync) {
            DSP = new timed_dsp(new mydsp());
        } else {
            DSP = new mydsp();
        }
#else
        DSP = new mydsp();
#endif
    }
    
#endif
    
    if (!DSP) {
        cerr << "Unable to allocate Faust DSP object" << endl;
        exit(1);
    }
    
    GTKUI* interface = new GTKUI(name, &argc, &argv);
    FUI finterface;
    
#ifdef PRESETUI
    string preset_dir = PresetUI::getPresetDir();
    cout << "Final preset_dir: " << preset_dir << endl;
    PresetUI::tryCreateDirectory(preset_dir);
    PresetUI pinterface(interface, preset_dir + "/" + ((nvoices > 0) ? "poly_" : ""));
    DSP->buildUserInterface(&pinterface);
#else
    DSP->buildUserInterface(interface);
    DSP->buildUserInterface(&finterface);
#endif
    
#ifdef MIDICTRL
    rt_midi midi_handler(name, is_virtual);
    MidiUI midiinterface(&midi_handler);
    DSP->buildUserInterface(&midiinterface);
    cout << "MIDI is on" << endl;
#endif
    
#ifdef HTTPCTRL
    httpdUI httpdinterface(name, DSP->getNumInputs(), DSP->getNumOutputs(), argc, argv);
    DSP->buildUserInterface(&httpdinterface);
    cout << "HTTPD is on" << endl;
#endif
    
    coreaudio audio(srate, fpb);
    if (!audio.init(name, DSP)) {
        cerr << "Unable to init audio" << endl;
        exit(1);
    }
   
// After audio init to get SR
#ifdef SOUNDFILE
    // Use bundle path
    SoundUI soundinterface("", audio.getSampleRate());
    DSP->buildUserInterface(&soundinterface);
#endif
    
#ifdef OSCCTRL
    OSCUI oscinterface(name, argc, argv);
    DSP->buildUserInterface(&oscinterface);
    cout << "OSC is on" << endl;
    audio.addControlCallback(osc_compute_callback, &oscinterface);
#endif
    
    if (!audio.start()) {
        cerr << "Unable to start audio" << endl;
        exit(1);
    }
    
    cout << "ins " << audio.getNumInputs() << endl;
    cout << "outs " << audio.getNumOutputs() << endl;
    
#ifdef HTTPCTRL
    httpdinterface.run();
#ifdef QRCODECTRL
    interface->displayQRCode(httpdinterface.getTCPPort());
#endif
#endif
    
#ifdef OSCCTRL
    oscinterface.run();
#endif
    
#ifdef MIDICTRL
    if (!midiinterface.run()) {
        cerr << "MidiUI run error " << endl;
    }
#endif
    
    // After the allocation of controllers
    finterface.recallState(rcfilename);
    
    interface->run();
    
#ifdef MIDICTRL
    midiinterface.stop();
#endif
    interface->stop();
    
    audio.stop();
    finterface.saveState(rcfilename);
    
    delete DSP;
    return 0;
}

/******************** END bench.cpp ****************/


#endif
